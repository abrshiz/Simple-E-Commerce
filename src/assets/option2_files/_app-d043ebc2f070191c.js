(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[636], {
  603: (e, t, n) => { "use strict"; n.d(t, { FE: () => d, Fm: () => g, KP: () => o, Kh: () => c, Mv: () => N, ND: () => u, Oe: () => b, Ow: () => P, Q3: () => m, RE: () => f, US: () => S, Ub: () => _, Ww: () => R, Zn: () => h, bm: () => k, fP: () => l, jl: () => C, lZ: () => E, qk: () => p, qs: () => a, rd: () => s, tX: () => v, vC: () => r, wX: () => y, xw: () => w, yQ: () => T, yU: () => I }); var i = n(7876); let r = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 32 32", children: (0, i.jsx)("path", { fill: "currentColor", d: "M16 0c-1.995 0-3.667 1.287-4.328 2.896a4.467 4.467 0 00-.317 1.885 4.602 4.602 0 00-1.557-1.109 4.657 4.657 0 00-1.953-.344 4.668 4.668 0 00-3.156 1.36c-1.412 1.411-1.683 3.5-1.016 5.109.235.572.625 1.088 1.088 1.536a4.646 4.646 0 00-1.864.339C1.288 12.333.001 14.005.001 16s1.287 3.667 2.896 4.328c.577.245 1.229.333 1.885.317-.479.448-.869.975-1.109 1.557-.667 1.609-.396 3.699 1.016 5.109 1.411 1.412 3.5 1.683 5.109 1.016.577-.24 1.104-.631 1.557-1.109-.021.656.072 1.308.317 1.885.661 1.609 2.333 2.896 4.328 2.896s3.667-1.287 4.328-2.896c.24-.599.349-1.24.317-1.885.453.475.975.869 1.557 1.109 1.609.667 3.699.396 5.109-1.016 1.412-1.411 1.683-3.5 1.016-5.109a4.63 4.63 0 00-1.109-1.557 4.464 4.464 0 001.885-.317c1.609-.661 2.896-2.333 2.896-4.328s-1.287-3.667-2.896-4.328a4.546 4.546 0 00-1.885-.317c.479-.448.869-.975 1.109-1.557.667-1.609.396-3.699-1.016-5.109a4.668 4.668 0 00-3.156-1.36 4.655 4.655 0 00-1.953.344c-.577.24-1.104.631-1.557 1.109a4.464 4.464 0 00-.317-1.885C19.667 1.288 17.995.001 16 .001zm-.052 2.151c2.281-.052 3.464 2.709 1.849 4.328v5.193L21.464 8c0-2.26 2.733-3.391 4.328-1.792 1.599 1.595.468 4.328-1.792 4.328l-3.672 3.667h5.193c1.599-1.593 4.328-.463 4.328 1.797s-2.729 3.391-4.328 1.797h-5.193L24 21.464c2.26 0 3.391 2.733 1.792 4.328-1.595 1.599-4.328.468-4.328-1.792l-3.667-3.672v5.193c1.593 1.599.463 4.328-1.797 4.328s-3.391-2.729-1.797-4.328v-5.193L10.536 24c0 2.26-2.733 3.391-4.328 1.792C4.609 24.197 5.74 21.464 8 21.464l3.672-3.667H6.479C4.88 19.39 2.151 18.26 2.151 16s2.729-3.391 4.328-1.797h5.193L8 10.536c-2.26 0-3.391-2.733-1.792-4.328C7.803 4.609 10.536 5.74 10.536 8l3.667 3.672V6.479c-1.577-1.577-.489-4.281 1.745-4.328z" }) }), s = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("path", { d: "M15 17c-.8.622-1.85 1-3 1s-2.2-.378-3-1" }), (0, i.jsx)("path", { d: "M2.352 13.214c-.354-2.298-.53-3.446-.096-4.465s1.398-1.715 3.325-3.108L7.021 4.6C9.418 2.867 10.617 2 12.001 2c1.382 0 2.58.867 4.978 2.6l1.44 1.041c1.927 1.393 2.89 2.09 3.325 3.108c.434 1.019.258 2.167-.095 4.464l-.301 1.96c-.5 3.256-.751 4.884-1.919 5.856S16.554 22 13.14 22h-2.28c-3.415 0-5.122 0-6.29-.971c-1.168-.972-1.418-2.6-1.918-5.857z" })] }) }), o = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M17.5 17.5L22 22m-2-11a9 9 0 1 0-18 0a9 9 0 0 0 18 0", color: "currentColor" }) }), a = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("path", { d: "M20.943 16.835a15.76 15.76 0 0 0-4.476-8.616c-.517-.503-.775-.754-1.346-.986C14.55 7 14.059 7 13.078 7h-2.156c-.981 0-1.472 0-2.043.233c-.57.232-.83.483-1.346.986a15.76 15.76 0 0 0-4.476 8.616C2.57 19.773 5.28 22 8.308 22h7.384c3.029 0 5.74-2.227 5.25-5.165" }), (0, i.jsx)("path", { d: "M7.257 4.443c-.207-.3-.506-.708.112-.8c.635-.096 1.294.338 1.94.33c.583-.009.88-.268 1.2-.638C10.845 2.946 11.365 2 12 2s1.155.946 1.491 1.335c.32.37.617.63 1.2.637c.646.01 1.305-.425 1.94-.33c.618.093.319.5.112.8l-.932 1.359c-.4.58-.599.87-1.017 1.035S13.837 7 12.758 7h-1.516c-1.08 0-1.619 0-2.036-.164S8.589 6.38 8.189 5.8z" })] }) }), l = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeWidth: "2", children: [(0, i.jsx)("path", { strokeDasharray: "60", strokeDashoffset: "60", strokeOpacity: ".3", d: "M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z", children: (0, i.jsx)("animate", { fill: "freeze", attributeName: "stroke-dashoffset", dur: "1.3s", values: "60;0" }) }), (0, i.jsxs)("path", { strokeDasharray: "15", strokeDashoffset: "15", d: "M12 3C16.9706 3 21 7.02944 21 12", children: [(0, i.jsx)("animate", { fill: "freeze", attributeName: "stroke-dashoffset", dur: "0.3s", values: "15;0" }), (0, i.jsx)("animateTransform", { attributeName: "transform", dur: "1.5s", repeatCount: "indefinite", type: "rotate", values: "0 12 12;360 12 12" })] })] }) }), h = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M4 17.98V9.709c0-3.634 0-5.45 1.172-6.58S8.229 2 12 2s5.657 0 6.828 1.129C20 4.257 20 6.074 20 9.708v8.273c0 2.306 0 3.459-.773 3.871c-1.497.8-4.304-1.867-5.637-2.67c-.773-.465-1.16-.698-1.59-.698s-.817.233-1.59.698c-1.333.803-4.14 3.47-5.637 2.67C4 21.44 4 20.287 4 17.981", color: "currentColor" }) }), c = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M12 15V5m0 10c-.7 0-2.008-1.994-2.5-2.5M12 15c.7 0 2.008-1.994 2.5-2.5M5 19h14", color: "currentColor" }) }), u = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("path", { d: "M9 15c0-2.828 0-4.243.879-5.121C10.757 9 12.172 9 15 9h1c2.828 0 4.243 0 5.121.879C22 10.757 22 12.172 22 15v1c0 2.828 0 4.243-.879 5.121C20.243 22 18.828 22 16 22h-1c-2.828 0-4.243 0-5.121-.879C9 20.243 9 18.828 9 16z" }), (0, i.jsx)("path", { d: "M17 9c-.003-2.957-.047-4.489-.908-5.538a4 4 0 0 0-.554-.554C14.43 2 12.788 2 9.5 2c-3.287 0-4.931 0-6.038.908a4 4 0 0 0-.554.554C2 4.57 2 6.212 2 9.5c0 3.287 0 4.931.908 6.038a4 4 0 0 0 .554.554c1.05.86 2.58.906 5.538.908" })] }) }), d = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 16 16", ...e, children: (0, i.jsx)("path", { fill: "currentColor", d: "M12.9 15.4L8 12.8l-4.9 2.6L4 10L0 6.1l5.5-.8l2.4-5l2.4 5l5.5.8L12 10l.9 5.4z" }) }), p = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("circle", { cx: "12", cy: "13", r: "9" }), (0, i.jsx)("path", { d: "m5 19l-2 2m16-2l2 2M19 3.57l.596-.298c.845-.423 1.162-.374 1.834.298s.72.99.298 1.834L21.43 6M5 3.57l-.596-.298c-.845-.423-1.162-.374-1.834.298s-.72.99-.298 1.834L2.57 6M12 9.5v4l2 2m-2-12V2m-2 0h4" })] }) }), f = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("path", { d: "M15 2.5h-3c-4.478 0-6.718 0-8.109 1.391S2.5 7.521 2.5 12c0 4.478 0 6.718 1.391 8.109S7.521 21.5 12 21.5c4.478 0 6.718 0 8.109-1.391S21.5 16.479 21.5 12v-2" }), (0, i.jsx)("path", { d: "m8.5 10l3.5 3.5l9-10" })] }) }), m = e => (0, i.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...e, children: (0, i.jsx)("path", { fill: "currentColor", d: "M6.848 2.47a1 1 0 0 1-.318 1.378A7.284 7.284 0 0 0 3.75 7.01A3 3 0 1 1 1 10v-.027a3.521 3.521 0 0 1 .01-.232c.009-.15.027-.36.062-.618c.07-.513.207-1.22.484-2.014c.552-1.59 1.67-3.555 3.914-4.957a1 1 0 0 1 1.378.318m7 0a1 1 0 0 1-.318 1.378a7.283 7.283 0 0 0-2.78 3.162A3 3 0 1 1 8 10v-.027a3.521 3.521 0 0 1 .01-.232c.009-.15.027-.36.062-.618c.07-.513.207-1.22.484-2.014c.552-1.59 1.67-3.555 3.914-4.957a1 1 0 0 1 1.378.318" }) }), g = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M12.828 6.001a3 3 0 1 0-5.658 0c-2.285.008-3.504.09-4.292.878S2.008 8.886 2 11.17a3 3 0 1 1 0 5.66c.008 2.284.09 3.503.878 4.291s2.007.87 4.291.878a3 3 0 1 1 5.66 0c2.284-.008 3.503-.09 4.291-.878s.87-2.007.878-4.292a3 3 0 1 0 0-5.658c-.008-2.285-.09-3.504-.878-4.292c-.788-.789-2.007-.87-4.292-.878", color: "currentColor" }) }), _ = e => (0, i.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 384", ...e, children: [(0, i.jsx)("path", { fill: "#0ACF83", d: "M64 384c35.328 0 64-28.672 64-64v-64H64c-35.328 0-64 28.672-64 64s28.672 64 64 64Z" }), (0, i.jsx)("path", { fill: "#A259FF", d: "M0 192c0-35.328 28.672-64 64-64h64v128H64c-35.328 0-64-28.672-64-64Z" }), (0, i.jsx)("path", { fill: "#F24E1E", d: "M0 64C0 28.672 28.672 0 64 0h64v128H64C28.672 128 0 99.328 0 64Z" }), (0, i.jsx)("path", { fill: "#FF7262", d: "M128 0h64c35.328 0 64 28.672 64 64s-28.672 64-64 64h-64V0Z" }), (0, i.jsx)("path", { fill: "#1ABCFE", d: "M256 192c0 35.328-28.672 64-64 64s-64-28.672-64-64s28.672-64 64-64s64 28.672 64 64Z" })] }), v = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 384", ...e, children: (0, i.jsx)("path", { d: "M0 0h256v128H128L0 0Zm0 128h128l128 128H128v128L0 256V128Z" }) }), y = e => (0, i.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256", ...e, children: [(0, i.jsx)("path", { fill: "#FFF", d: "M128.003 199.216c39.335 0 71.221-31.888 71.221-71.223c0-39.335-31.886-71.223-71.221-71.223c-39.335 0-71.222 31.888-71.222 71.223c0 39.335 31.887 71.223 71.222 71.223Z" }), (0, i.jsx)("path", { fill: "#229342", d: "M35.89 92.997c-5.313-9.203-11.558-18.862-18.736-28.977a127.98 127.98 0 0 0 110.857 191.981c11.78-16.523 19.78-28.437 23.996-35.74c8.099-14.028 18.573-34.112 31.423-60.251v-.015a63.993 63.993 0 0 1-110.857.017c-17.453-32.548-29.68-54.887-36.683-67.015Z" }), (0, i.jsx)("path", { fill: "#FBC116", d: "M128.008 255.996A127.972 127.972 0 0 0 256 127.997A127.983 127.983 0 0 0 238.837 64c-24.248-2.39-42.143-3.585-53.686-3.585c-13.088 0-32.139 1.195-57.152 3.585l-.014.01a63.993 63.993 0 0 1 55.444 31.987a63.993 63.993 0 0 1-.001 64.01l-55.42 95.989Z" }), (0, i.jsx)("path", { fill: "#1A73E8", d: "M128.003 178.677c27.984 0 50.669-22.685 50.669-50.67c0-27.986-22.685-50.67-50.67-50.67c-27.983 0-50.669 22.686-50.669 50.67s22.686 50.67 50.67 50.67Z" }), (0, i.jsx)("path", { fill: "#E33B2E", d: "M128.003 64.004H238.84a127.973 127.973 0 0 0-221.685.015l55.419 95.99l.015.008a63.993 63.993 0 0 1 55.415-96.014l-.002.001Z" })] }), w = e => (0, i.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 32 32", ...e, children: [(0, i.jsx)("path", { fill: "#0065a9", d: "m29.01 5.03l-5.766-2.776a1.742 1.742 0 0 0-1.989.338L2.38 19.8a1.166 1.166 0 0 0-.08 1.647c.025.027.05.053.077.077l1.541 1.4a1.165 1.165 0 0 0 1.489.066L28.142 5.75A1.158 1.158 0 0 1 30 6.672v-.067a1.748 1.748 0 0 0-.99-1.575Z" }), (0, i.jsx)("path", { fill: "#007acc", d: "m29.01 26.97l-5.766 2.777a1.745 1.745 0 0 1-1.989-.338L2.38 12.2a1.166 1.166 0 0 1-.08-1.647c.025-.027.05-.053.077-.077l1.541-1.4A1.165 1.165 0 0 1 5.41 9.01l22.732 17.24A1.158 1.158 0 0 0 30 25.328v.072a1.749 1.749 0 0 1-.99 1.57Z" }), (0, i.jsx)("path", { fill: "#1f9cf0", d: "M23.244 29.747a1.745 1.745 0 0 1-1.989-.338A1.025 1.025 0 0 0 23 28.684V3.316a1.024 1.024 0 0 0-1.749-.724a1.744 1.744 0 0 1 1.989-.339l5.765 2.772A1.748 1.748 0 0 1 30 6.6v18.8a1.748 1.748 0 0 1-.991 1.576Z" })] }), b = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "currentColor", d: "M5 16L3 3l5.5 4L12 3l3.5 4L21 3l-2 13H5zm2.7-2h8.6l.9-5.4l-2.1 1.6L12 8l-3.1 2.2l-2.1-1.6L6.7 14z" }) }), I = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "m3 21l5-5m5.259 2.871c-3.744-.85-7.28-4.386-8.13-8.13c-.135-.592-.202-.888-.007-1.369c.194-.48.433-.63.909-.927c1.076-.672 2.242-.886 3.451-.78c1.697.151 2.546.226 2.97.005c.423-.22.71-.736 1.286-1.767l.728-1.307c.48-.86.72-1.291 1.285-1.494s.905-.08 1.585.166a5.63 5.63 0 0 1 3.396 3.396c.246.68.369 1.02.166 1.585c-.203.564-.633.804-1.494 1.285l-1.337.745c-1.03.574-1.544.862-1.765 1.289c-.22.428-.14 1.258.02 2.918c.118 1.22-.085 2.394-.766 3.484c-.298.476-.447.714-.928.909c-.48.194-.777.127-1.37-.008", color: "currentColor" }) }), C = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("path", { d: "M18 10.997c-.392-.8-1.452-1.976-3.63-1.926c0 0-1.727-.075-3.68-.075c-1.952 0-2.866.046-4.43.075c-1.001-.025-2.904.2-3.78 2.276c-.576 1.75-.6 5.427-.25 7.277c.075.95.576 2.276 2.128 2.976c.95.5 2.478.3 3.63.4M5.984 8.196c-.05-2.375-.15-4.25 2.603-5.801c.926-.375 2.303-.7 4.005.1c1.777 1.075 1.999 2.213 2.153 2.5c.425 1.126.2 2.726.25 3.376" }), (0, i.jsx)("path", { d: "M15.5 19.735a2.23 2.23 0 0 1-2.245 2.23c-1.236 0-2.255-.986-2.255-2.23a2.253 2.253 0 0 1 2.255-2.244c1.236 0 2.245 1 2.245 2.244m-.275-1.945l1.99-1.942m4.785 0l-1.627-1.54c-.773-.74-1.423-.094-1.747.182l-1.41 1.358m0 0l1.609 1.545" })] }) }), T = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "m6 9l6 6l6-6", color: "currentColor" }) }), k = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 12L7 7m5 5l5 5m-5-5l5-5m-5 5l-5 5" }) }), E = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsxs)("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [(0, i.jsx)("path", { d: "M15 17.625c-.074 1.852-1.617 3.424-3.684 3.374c-.481-.012-1.076-.18-2.265-.515c-2.861-.807-5.345-2.164-5.941-5.202C3 14.723 3 14.094 3 12.837v-1.674c0-1.257 0-1.886.11-2.445c.596-3.038 3.08-4.395 5.941-5.202c1.19-.335 1.784-.503 2.265-.515c2.067-.05 3.61 1.522 3.684 3.374" }), (0, i.jsx)("path", { d: "M10 12h11m-11 0c0-.7 1.994-2.008 2.5-2.5M10 12c0 .7 1.994 2.008 2.5 2.5" })] }) }), S = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 26 26", ...e, children: (0, i.jsx)("path", { fill: "currentColor", d: "M23.934 18.947c-.598 1.324-.884 1.916-1.652 3.086c-1.073 1.634-2.588 3.673-4.461 3.687c-1.666.014-2.096-1.087-4.357-1.069c-2.261.011-2.732 1.089-4.4 1.072c-1.873-.017-3.307-1.854-4.381-3.485c-3.003-4.575-3.32-9.937-1.464-12.79C4.532 7.425 6.61 6.237 8.561 6.237c1.987 0 3.236 1.092 4.879 1.092c1.594 0 2.565-1.095 4.863-1.095c1.738 0 3.576.947 4.889 2.581c-4.296 2.354-3.598 8.49.742 10.132zM16.559 4.408c.836-1.073 1.47-2.587 1.24-4.131c-1.364.093-2.959.964-3.891 2.092c-.844 1.027-1.544 2.553-1.271 4.029c1.488.048 3.028-.839 3.922-1.99z" }) }), P = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "M17 7L6 18m5-11.868s5.634-.475 6.488.38c.855.854.38 6.488.38 6.488", color: "currentColor" }) }), N = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...e, children: (0, i.jsx)("path", { fill: "none", stroke: "#000000", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "m15.167 1l.598 1.118c.404.755.606 1.133.472 1.295c-.133.162-.573.031-1.454-.23A9.8 9.8 0 0 0 12 2.78c-5.247 0-9.5 4.128-9.5 9.22a8.97 8.97 0 0 0 1.27 4.61M8.834 23l-.598-1.118c-.404-.756-.606-1.134-.472-1.295c.133-.162.573-.032 1.454.23c.88.261 1.815.402 2.783.402c5.247 0 9.5-4.128 9.5-9.22a8.97 8.97 0 0 0-1.27-4.609", color: "currentColor" }) }), R = e => (0, i.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 20 20", ...e, children: (0, i.jsxs)("g", { fill: "none", children: [(0, i.jsx)("path", { fill: "url(#fluentColorLockClosed200)", fillRule: "evenodd", d: "M10 3a2 2 0 0 0-2 2v1.734H6.5V5a3.5 3.5 0 1 1 7 0v1.734H12V5a2 2 0 0 0-2-2", clipRule: "evenodd" }), (0, i.jsx)("path", { fill: "url(#fluentColorLockClosed201)", d: "M6 6a3 3 0 0 0-3 3v6a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3z" }), (0, i.jsx)("path", { fill: "url(#fluentColorLockClosed202)", d: "M10 13a1 1 0 1 0 0-2a1 1 0 0 0 0 2" }), (0, i.jsxs)("defs", { children: [(0, i.jsxs)("linearGradient", { id: "fluentColorLockClosed200", x1: "8", x2: "14.039", y1: ".5", y2: "9.669", gradientUnits: "userSpaceOnUse", children: [(0, i.jsx)("stop", { stopColor: "#FFC205" }), (0, i.jsx)("stop", { offset: "1", stopColor: "#FB5937" })] }), (0, i.jsxs)("linearGradient", { id: "fluentColorLockClosed201", x1: "18", x2: "5.469", y1: "18.75", y2: "6.838", gradientUnits: "userSpaceOnUse", children: [(0, i.jsx)("stop", { stopColor: "#FF6F47" }), (0, i.jsx)("stop", { offset: "1", stopColor: "#FFCD0F" })] }), (0, i.jsxs)("radialGradient", { id: "fluentColorLockClosed202", cx: "0", cy: "0", r: "1", gradientTransform: "matrix(-.99997 -3.5 4.85626 -1.38747 10.5 13)", gradientUnits: "userSpaceOnUse", children: [(0, i.jsx)("stop", { stopColor: "#944600" }), (0, i.jsx)("stop", { offset: "1", stopColor: "#CD8E02" })] })] })] }) }) }, 672: (e, t, n) => { "use strict"; n.d(t, { A: () => i }); let i = (0, n(1713).A)("x", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]) }, 820: (e, t, n) => { "use strict"; n.d(t, { d: () => s }); var i = n(7447), r = n(4232); let s = () => { let e = (0, r.useContext)(i.$); if (void 0 === e) throw Error("useToast must be used within a ToastProvider"); return e } }, 1713: (e, t, n) => { "use strict"; n.d(t, { A: () => c }); var i = n(4232); let r = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), s = e => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n) => n ? n.toUpperCase() : t.toLowerCase()), o = e => { let t = s(e); return t.charAt(0).toUpperCase() + t.slice(1) }, a = function () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.filter((e, t, n) => !!e && "" !== e.trim() && n.indexOf(e) === t).join(" ").trim() }; var l = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }; let h = (0, i.forwardRef)((e, t) => { let { color: n = "currentColor", size: r = 24, strokeWidth: s = 2, absoluteStrokeWidth: o, className: h = "", children: c, iconNode: u, ...d } = e; return (0, i.createElement)("svg", { ref: t, ...l, width: r, height: r, stroke: n, strokeWidth: o ? 24 * Number(s) / Number(r) : s, className: a("lucide", h), ...d }, [...u.map(e => { let [t, n] = e; return (0, i.createElement)(t, n) }), ...Array.isArray(c) ? c : [c]]) }), c = (e, t) => { let n = (0, i.forwardRef)((n, s) => { let { className: l, ...c } = n; return (0, i.createElement)(h, { ref: s, iconNode: t, className: a("lucide-".concat(r(o(e))), "lucide-".concat(e), l), ...c }) }); return n.displayName = o(e), n } }, 1784: (e, t, n) => {
    "use strict"; let i, r, s, o, a, l, h, c, u, d, p, f; n.d(t, { A: () => c3 }); var m, g, _ = {}; n.r(_), n.d(_, { FirebaseError: () => $, SDK_VERSION: () => e9, _DEFAULT_ENTRY_NAME: () => eG, _addComponent: () => eX, _addOrOverwriteComponent: () => eZ, _apps: () => eY, _clearComponents: () => e5, _components: () => eQ, _getProvider: () => e1, _isFirebaseApp: () => e3, _isFirebaseServerApp: () => e4, _registerComponent: () => e0, _removeServiceInstance: () => e2, _serverApps: () => eJ, deleteApp: () => tr, getApp: () => tn, getApps: () => ti, initializeApp: () => te, initializeServerApp: () => tt, onLog: () => to, registerVersion: () => ts, setLogLevel: () => ta }); var v = n(5364); let y = { NODE_CLIENT: !1, NODE_ADMIN: !1, SDK_VERSION: "${JSCORE_VERSION}" }, w = function (e, t) { if (!e) throw b(t) }, b = function (e) { return Error("Firebase Database (" + y.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + e) }, I = function (e) { let t = [], n = 0; for (let i = 0; i < e.length; i++) { let r = e.charCodeAt(i); r < 128 ? t[n++] = r : (r < 2048 ? t[n++] = r >> 6 | 192 : ((64512 & r) == 55296 && i + 1 < e.length && (64512 & e.charCodeAt(i + 1)) == 56320 ? (r = 65536 + ((1023 & r) << 10) + (1023 & e.charCodeAt(++i)), t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128) : t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128), t[n++] = 63 & r | 128) } return t }, C = function (e) { let t = [], n = 0, i = 0; for (; n < e.length;) { let r = e[n++]; if (r < 128) t[i++] = String.fromCharCode(r); else if (r > 191 && r < 224) { let s = e[n++]; t[i++] = String.fromCharCode((31 & r) << 6 | 63 & s) } else if (r > 239 && r < 365) { let s = e[n++], o = ((7 & r) << 18 | (63 & s) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536; t[i++] = String.fromCharCode(55296 + (o >> 10)), t[i++] = String.fromCharCode(56320 + (1023 & o)) } else { let s = e[n++], o = e[n++]; t[i++] = String.fromCharCode((15 & r) << 12 | (63 & s) << 6 | 63 & o) } } return t.join("") }, T = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: "function" == typeof atob, encodeByteArray(e, t) { if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); let n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, i = []; for (let t = 0; t < e.length; t += 3) { let r = e[t], s = t + 1 < e.length, o = s ? e[t + 1] : 0, a = t + 2 < e.length, l = a ? e[t + 2] : 0, h = r >> 2, c = (3 & r) << 4 | o >> 4, u = (15 & o) << 2 | l >> 6, d = 63 & l; !a && (d = 64, s || (u = 64)), i.push(n[h], n[c], n[u], n[d]) } return i.join("") }, encodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(I(e), t) }, decodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : C(this.decodeStringToByteArray(e, t)) }, decodeStringToByteArray(e, t) { this.init_(); let n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, i = []; for (let t = 0; t < e.length;) { let r = n[e.charAt(t++)], s = t < e.length ? n[e.charAt(t)] : 0, o = ++t < e.length ? n[e.charAt(t)] : 64, a = ++t < e.length ? n[e.charAt(t)] : 64; if (++t, null == r || null == s || null == o || null == a) throw new k; let l = r << 2 | s >> 4; if (i.push(l), 64 !== o) { let e = s << 4 & 240 | o >> 2; if (i.push(e), 64 !== a) { let e = o << 6 & 192 | a; i.push(e) } } } return i }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e) } } }; class k extends Error { constructor() { super(...arguments), this.name = "DecodeBase64StringError" } } let E = function (e) { let t = I(e); return T.encodeByteArray(t, !0) }, S = function (e) { return E(e).replace(/\./g, "") }, P = function (e) { try { return T.decodeString(e, !0) } catch (e) { console.error("base64Decode failed: ", e) } return null }; function N(e, t) { if (!(t instanceof Object)) return t; switch (t.constructor) { case Date: return new Date(t.getTime()); case Object: void 0 === e && (e = {}); break; case Array: e = []; break; default: return t }for (let n in t) t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = N(e[n], t[n])); return e } function R() { if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if (void 0 !== n.g) return n.g; throw Error("Unable to locate global object.") } let x = () => R().__FIREBASE_DEFAULTS__, A = () => { if (void 0 === v || void 0 === v.env) return; let e = v.env.__FIREBASE_DEFAULTS__; if (e) return JSON.parse(e) }, O = () => { let e; if ("undefined" == typeof document) return; try { e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch (e) { return } let t = e && P(e[1]); return t && JSON.parse(t) }, D = () => { try { return x() || A() || O() } catch (e) { console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`); return } }, L = () => { var e; return null == (e = D()) ? void 0 : e.config }; class M { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } wrapCallback(e) { return (t, n) => { t ? this.reject(t) : this.resolve(n), "function" == typeof e && (this.promise.catch(() => { }), 1 === e.length ? e(t) : e(t, n)) } } } function j() { return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "" } function F() { return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(j()) } function U() { var e; let t = null == (e = D()) ? void 0 : e.forceEnvironment; if ("node" === t) return !0; if ("browser" === t) return !1; try { return "[object process]" === Object.prototype.toString.call(n.g.process) } catch (e) { return !1 } } function q() { return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope } function W() { let e = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0; return "object" == typeof e && void 0 !== e.id } function z() { return "object" == typeof navigator && "ReactNative" === navigator.product } function V() { let e = j(); return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0 } function B() { return !0 === y.NODE_CLIENT || !0 === y.NODE_ADMIN } function H() { try { return "object" == typeof indexedDB } catch (e) { return !1 } } class $ extends Error { constructor(e, t, n) { super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, $.prototype), Error.captureStackTrace && Error.captureStackTrace(this, G.prototype.create) } } class G { constructor(e, t, n) { this.service = e, this.serviceName = t, this.errors = n } create(e, ...t) { var n, i; let r = t[0] || {}, s = `${this.service}/${e}`, o = this.errors[e], a = o ? (n = o, i = r, n.replace(K, (e, t) => { let n = i[t]; return null != n ? String(n) : `<${t}?>` })) : "Error", l = `${this.serviceName}: ${a} (${s}).`; return new $(s, l, r) } } let K = /\{\$([^}]+)}/g; function Y(e) { return JSON.parse(e) } function J(e) { return JSON.stringify(e) } let Q = function (e) { let t = {}, n = {}, i = {}, r = ""; try { let s = e.split("."); t = Y(P(s[0]) || ""), n = Y(P(s[1]) || ""), r = s[2], i = n.d || {}, delete n.d } catch (e) { } return { header: t, claims: n, data: i, signature: r } }, X = function (e) { let t = Q(e).claims; return !!t && "object" == typeof t && t.hasOwnProperty("iat") }, Z = function (e) { let t = Q(e).claims; return "object" == typeof t && !0 === t.admin }; function ee(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function et(e, t) { return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0 } function en(e) { for (let t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } function ei(e, t, n) { let i = {}; for (let r in e) Object.prototype.hasOwnProperty.call(e, r) && (i[r] = t.call(n, e[r], r, e)); return i } function er(e, t) { if (e === t) return !0; let n = Object.keys(e), i = Object.keys(t); for (let r of n) { if (!i.includes(r)) return !1; let n = e[r], s = t[r]; if (es(n) && es(s)) { if (!er(n, s)) return !1 } else if (n !== s) return !1 } for (let e of i) if (!n.includes(e)) return !1; return !0 } function es(e) { return null !== e && "object" == typeof e } function eo(e) { let t = []; for (let [n, i] of Object.entries(e)) Array.isArray(i) ? i.forEach(e => { t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e)) }) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(i)); return t.length ? "&" + t.join("&") : "" } function ea(e) { let t = {}; return e.replace(/^\?/, "").split("&").forEach(e => { if (e) { let [n, i] = e.split("="); t[decodeURIComponent(n)] = decodeURIComponent(i) } }), t } function el(e) { let t = e.indexOf("?"); if (!t) return ""; let n = e.indexOf("#", t); return e.substring(t, n > 0 ? n : void 0) } class eh { constructor() { this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 64, this.pad_[0] = 128; for (let e = 1; e < this.blockSize; ++e)this.pad_[e] = 0; this.reset() } reset() { this.chain_[0] = 0x67452301, this.chain_[1] = 0xefcdab89, this.chain_[2] = 0x98badcfe, this.chain_[3] = 0x10325476, this.chain_[4] = 0xc3d2e1f0, this.inbuf_ = 0, this.total_ = 0 } compress_(e, t) { let n, i; t || (t = 0); let r = this.W_; if ("string" == typeof e) for (let n = 0; n < 16; n++)r[n] = e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3), t += 4; else for (let n = 0; n < 16; n++)r[n] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3], t += 4; for (let e = 16; e < 80; e++) { let t = r[e - 3] ^ r[e - 8] ^ r[e - 14] ^ r[e - 16]; r[e] = t << 1 | t >>> 31 } let s = this.chain_[0], o = this.chain_[1], a = this.chain_[2], l = this.chain_[3], h = this.chain_[4]; for (let e = 0; e < 80; e++) { e < 40 ? e < 20 ? (n = l ^ o & (a ^ l), i = 0x5a827999) : (n = o ^ a ^ l, i = 0x6ed9eba1) : e < 60 ? (n = o & a | l & (o | a), i = 0x8f1bbcdc) : (n = o ^ a ^ l, i = 0xca62c1d6); let t = (s << 5 | s >>> 27) + n + h + i + r[e] | 0; h = l, l = a, a = o << 30 | o >>> 2, o = s, s = t } this.chain_[0] = this.chain_[0] + s | 0, this.chain_[1] = this.chain_[1] + o | 0, this.chain_[2] = this.chain_[2] + a | 0, this.chain_[3] = this.chain_[3] + l | 0, this.chain_[4] = this.chain_[4] + h | 0 } update(e, t) { if (null == e) return; void 0 === t && (t = e.length); let n = t - this.blockSize, i = 0, r = this.buf_, s = this.inbuf_; for (; i < t;) { if (0 === s) for (; i <= n;)this.compress_(e, i), i += this.blockSize; if ("string" == typeof e) { for (; i < t;)if (r[s] = e.charCodeAt(i), ++s, ++i, s === this.blockSize) { this.compress_(r), s = 0; break } } else for (; i < t;)if (r[s] = e[i], ++s, ++i, s === this.blockSize) { this.compress_(r), s = 0; break } } this.inbuf_ = s, this.total_ += t } digest() { let e = [], t = 8 * this.total_; this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56)); for (let e = this.blockSize - 1; e >= 56; e--)this.buf_[e] = 255 & t, t /= 256; this.compress_(this.buf_); let n = 0; for (let t = 0; t < 5; t++)for (let i = 24; i >= 0; i -= 8)e[n] = this.chain_[t] >> i & 255, ++n; return e } } function ec(e, t) { let n = new eu(e, t); return n.subscribe.bind(n) } class eu { constructor(e, t) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = t, this.task.then(() => { e(this) }).catch(e => { this.error(e) }) } next(e) { this.forEachObserver(t => { t.next(e) }) } error(e) { this.forEachObserver(t => { t.error(e) }), this.close(e) } complete() { this.forEachObserver(e => { e.complete() }), this.close() } subscribe(e, t, n) { let i; if (void 0 === e && void 0 === t && void 0 === n) throw Error("Missing Observer."); void 0 === (i = !function (e, t) { if ("object" != typeof e || null === e) return !1; for (let n of t) if (n in e && "function" == typeof e[n]) return !0; return !1 }(e, ["next", "error", "complete"]) ? { next: e, error: t, complete: n } : e).next && (i.next = ed), void 0 === i.error && (i.error = ed), void 0 === i.complete && (i.complete = ed); let r = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then(() => { try { this.finalError ? i.error(this.finalError) : i.complete() } catch (e) { } }), this.observers.push(i), r } unsubscribeOne(e) { void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this)) } forEachObserver(e) { if (!this.finalized) for (let t = 0; t < this.observers.length; t++)this.sendOne(t, e) } sendOne(e, t) { this.task.then(() => { if (void 0 !== this.observers && void 0 !== this.observers[e]) try { t(this.observers[e]) } catch (e) { "undefined" != typeof console && console.error && console.error(e) } }) } close(e) { this.finalized || (this.finalized = !0, void 0 !== e && (this.finalError = e), this.task.then(() => { this.observers = void 0, this.onNoObservers = void 0 })) } } function ed() { } let ep = function (e, t, n, i) { let r; if (i < t ? r = "at least " + t : i > n && (r = 0 === n ? "none" : "no more than " + n), r) throw Error(e + " failed: Was called with " + i + (1 === i ? " argument." : " arguments.") + " Expects " + r + ".") }; function ef(e, t) { return `${e} failed: ${t} argument ` } function em(e, t, n, i) { if ((!i || n) && "function" != typeof n) throw Error(ef(e, t) + "must be a valid function.") } function eg(e, t, n, i) { if ((!i || n) && ("object" != typeof n || null === n)) throw Error(ef(e, t) + "must be a valid context object.") } let e_ = function (e) { let t = [], n = 0; for (let i = 0; i < e.length; i++) { let r = e.charCodeAt(i); if (r >= 55296 && r <= 56319) { let t = r - 55296; w(++i < e.length, "Surrogate pair missing trail surrogate."), r = 65536 + (t << 10) + (e.charCodeAt(i) - 56320) } r < 128 ? t[n++] = r : (r < 2048 ? t[n++] = r >> 6 | 192 : (r < 65536 ? t[n++] = r >> 12 | 224 : (t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128), t[n++] = r >> 6 & 63 | 128), t[n++] = 63 & r | 128) } return t }, ev = function (e) { let t = 0; for (let n = 0; n < e.length; n++) { let i = e.charCodeAt(n); i < 128 ? t++ : i < 2048 ? t += 2 : i >= 55296 && i <= 56319 ? (t += 4, n++) : t += 3 } return t }; function ey(e) { return e && e._delegate ? e._delegate : e } class ew { constructor(e, t, n) { this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(e) { return this.instantiationMode = e, this } setMultipleInstances(e) { return this.multipleInstances = e, this } setServiceProps(e) { return this.serviceProps = e, this } setInstanceCreatedCallback(e) { return this.onInstanceCreated = e, this } } let eb = "[DEFAULT]"; class eI { constructor(e, t) { this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(e) { let t = this.normalizeInstanceIdentifier(e); if (!this.instancesDeferred.has(t)) { let e = new M; if (this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()) try { let n = this.getOrInitializeService({ instanceIdentifier: t }); n && e.resolve(n) } catch (e) { } } return this.instancesDeferred.get(t).promise } getImmediate(e) { var t; let n = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier), i = null != (t = null == e ? void 0 : e.optional) && t; if (this.isInitialized(n) || this.shouldAutoInitialize()) try { return this.getOrInitializeService({ instanceIdentifier: n }) } catch (e) { if (i) return null; throw e } if (i) return null; throw Error(`Service ${this.name} is not available`) } getComponent() { return this.component } setComponent(e) { if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = e, this.shouldAutoInitialize()) { if ("EAGER" === e.instantiationMode) try { this.getOrInitializeService({ instanceIdentifier: eb }) } catch (e) { } for (let [e, t] of this.instancesDeferred.entries()) { let n = this.normalizeInstanceIdentifier(e); try { let e = this.getOrInitializeService({ instanceIdentifier: n }); t.resolve(e) } catch (e) { } } } } clearInstance(e = eb) { this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e) } async delete() { let e = Array.from(this.instances.values()); await Promise.all([...e.filter(e => "INTERNAL" in e).map(e => e.INTERNAL.delete()), ...e.filter(e => "_delete" in e).map(e => e._delete())]) } isComponentSet() { return null != this.component } isInitialized(e = eb) { return this.instances.has(e) } getOptions(e = eb) { return this.instancesOptions.get(e) || {} } initialize(e = {}) { let { options: t = {} } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier); if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); let i = this.getOrInitializeService({ instanceIdentifier: n, options: t }); for (let [e, t] of this.instancesDeferred.entries()) n === this.normalizeInstanceIdentifier(e) && t.resolve(i); return i } onInit(e, t) { var n; let i = this.normalizeInstanceIdentifier(t), r = null != (n = this.onInitCallbacks.get(i)) ? n : new Set; r.add(e), this.onInitCallbacks.set(i, r); let s = this.instances.get(i); return s && e(s, i), () => { r.delete(e) } } invokeOnInitCallbacks(e, t) { let n = this.onInitCallbacks.get(t); if (n) for (let i of n) try { i(e, t) } catch (e) { } } getOrInitializeService({ instanceIdentifier: e, options: t = {} }) { var n; let i = this.instances.get(e); if (!i && this.component && (i = this.component.instanceFactory(this.container, { instanceIdentifier: (n = e) === eb ? void 0 : n, options: t }), this.instances.set(e, i), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(i, e), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, e, i) } catch (e) { } return i || null } normalizeInstanceIdentifier(e = eb) { return this.component ? this.component.multipleInstances ? e : eb : e } shouldAutoInitialize() { return !!this.component && "EXPLICIT" !== this.component.instantiationMode } } class eC { constructor(e) { this.name = e, this.providers = new Map } addComponent(e) { let t = this.getProvider(e.name); if (t.isComponentSet()) throw Error(`Component ${e.name} has already been registered with ${this.name}`); t.setComponent(e) } addOrOverwriteComponent(e) { this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e) } getProvider(e) { if (this.providers.has(e)) return this.providers.get(e); let t = new eI(e, this); return this.providers.set(e, t), t } getProviders() { return Array.from(this.providers.values()) } } let eT = []; !function (e) { e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT" }(m || (m = {})); let ek = { debug: m.DEBUG, verbose: m.VERBOSE, info: m.INFO, warn: m.WARN, error: m.ERROR, silent: m.SILENT }, eE = m.INFO, eS = { [m.DEBUG]: "log", [m.VERBOSE]: "log", [m.INFO]: "info", [m.WARN]: "warn", [m.ERROR]: "error" }, eP = (e, t, ...n) => { if (t < e.logLevel) return; let i = new Date().toISOString(), r = eS[t]; if (r) console[r](`[${i}]  ${e.name}:`, ...n); else throw Error(`Attempted to log a message with an invalid logType (value: ${t})`) }; class eN { constructor(e) { this.name = e, this._logLevel = eE, this._logHandler = eP, this._userLogHandler = null, eT.push(this) } get logLevel() { return this._logLevel } set logLevel(e) { if (!(e in m)) throw TypeError(`Invalid value "${e}" assigned to \`logLevel\``); this._logLevel = e } setLogLevel(e) { this._logLevel = "string" == typeof e ? ek[e] : e } get logHandler() { return this._logHandler } set logHandler(e) { if ("function" != typeof e) throw TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = e } get userLogHandler() { return this._userLogHandler } set userLogHandler(e) { this._userLogHandler = e } debug(...e) { this._userLogHandler && this._userLogHandler(this, m.DEBUG, ...e), this._logHandler(this, m.DEBUG, ...e) } log(...e) { this._userLogHandler && this._userLogHandler(this, m.VERBOSE, ...e), this._logHandler(this, m.VERBOSE, ...e) } info(...e) { this._userLogHandler && this._userLogHandler(this, m.INFO, ...e), this._logHandler(this, m.INFO, ...e) } warn(...e) { this._userLogHandler && this._userLogHandler(this, m.WARN, ...e), this._logHandler(this, m.WARN, ...e) } error(...e) { this._userLogHandler && this._userLogHandler(this, m.ERROR, ...e), this._logHandler(this, m.ERROR, ...e) } } let eR = (e, t) => t.some(t => e instanceof t), ex = new WeakMap, eA = new WeakMap, eO = new WeakMap, eD = new WeakMap, eL = new WeakMap, eM = { get(e, t, n) { if (e instanceof IDBTransaction) { if ("done" === t) return eA.get(e); if ("objectStoreNames" === t) return e.objectStoreNames || eO.get(e); if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]) } return ej(e[t]) }, set: (e, t, n) => (e[t] = n, !0), has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e }; function ej(e) { if (e instanceof IDBRequest) { let t = new Promise((t, n) => { let i = () => { e.removeEventListener("success", r), e.removeEventListener("error", s) }, r = () => { t(ej(e.result)), i() }, s = () => { n(e.error), i() }; e.addEventListener("success", r), e.addEventListener("error", s) }); return t.then(t => { t instanceof IDBCursor && ex.set(t, e) }).catch(() => { }), eL.set(t, e), t } if (eD.has(e)) return eD.get(e); let t = function (e) { if ("function" == typeof e) return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (r || (r = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function (...t) { return e.apply(eF(this), t), ej(ex.get(this)) } : function (...t) { return ej(e.apply(eF(this), t)) } : function (t, ...n) { let i = e.call(eF(this), t, ...n); return eO.set(i, t.sort ? t.sort() : [t]), ej(i) }; return (e instanceof IDBTransaction && function (e) { if (eA.has(e)) return; let t = new Promise((t, n) => { let i = () => { e.removeEventListener("complete", r), e.removeEventListener("error", s), e.removeEventListener("abort", s) }, r = () => { t(), i() }, s = () => { n(e.error || new DOMException("AbortError", "AbortError")), i() }; e.addEventListener("complete", r), e.addEventListener("error", s), e.addEventListener("abort", s) }); eA.set(e, t) }(e), eR(e, i || (i = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]))) ? new Proxy(e, eM) : e }(e); return t !== e && (eD.set(e, t), eL.set(t, e)), t } let eF = e => eL.get(e), eU = ["get", "getKey", "getAll", "getAllKeys", "count"], eq = ["put", "add", "delete", "clear"], eW = new Map; function ez(e, t) { if (!(e instanceof IDBDatabase && !(t in e) && "string" == typeof t)) return; if (eW.get(t)) return eW.get(t); let n = t.replace(/FromIndex$/, ""), i = t !== n, r = eq.includes(n); if (!(n in (i ? IDBIndex : IDBObjectStore).prototype) || !(r || eU.includes(n))) return; let s = async function (e, ...t) { let s = this.transaction(e, r ? "readwrite" : "readonly"), o = s.store; return i && (o = o.index(t.shift())), (await Promise.all([o[n](...t), r && s.done]))[0] }; return eW.set(t, s), s } eM = (e => ({ ...e, get: (t, n, i) => ez(t, n) || e.get(t, n, i), has: (t, n) => !!ez(t, n) || e.has(t, n) }))(eM); class eV { constructor(e) { this.container = e } getPlatformInfoString() { return this.container.getProviders().map(e => { if (!function (e) { let t = e.getComponent(); return (null == t ? void 0 : t.type) === "VERSION" }(e)) return null; { let t = e.getImmediate(); return `${t.library}/${t.version}` } }).filter(e => e).join(" ") } } let eB = "@firebase/app", eH = "0.10.13", e$ = new eN("@firebase/app"), eG = "[DEFAULT]", eK = { [eB]: "fire-core", "@firebase/app-compat": "fire-core-compat", "@firebase/analytics": "fire-analytics", "@firebase/analytics-compat": "fire-analytics-compat", "@firebase/app-check": "fire-app-check", "@firebase/app-check-compat": "fire-app-check-compat", "@firebase/auth": "fire-auth", "@firebase/auth-compat": "fire-auth-compat", "@firebase/database": "fire-rtdb", "@firebase/data-connect": "fire-data-connect", "@firebase/database-compat": "fire-rtdb-compat", "@firebase/functions": "fire-fn", "@firebase/functions-compat": "fire-fn-compat", "@firebase/installations": "fire-iid", "@firebase/installations-compat": "fire-iid-compat", "@firebase/messaging": "fire-fcm", "@firebase/messaging-compat": "fire-fcm-compat", "@firebase/performance": "fire-perf", "@firebase/performance-compat": "fire-perf-compat", "@firebase/remote-config": "fire-rc", "@firebase/remote-config-compat": "fire-rc-compat", "@firebase/storage": "fire-gcs", "@firebase/storage-compat": "fire-gcs-compat", "@firebase/firestore": "fire-fst", "@firebase/firestore-compat": "fire-fst-compat", "@firebase/vertexai-preview": "fire-vertex", "fire-js": "fire-js", firebase: "fire-js-all" }, eY = new Map, eJ = new Map, eQ = new Map; function eX(e, t) { try { e.container.addComponent(t) } catch (n) { e$.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n) } } function eZ(e, t) { e.container.addOrOverwriteComponent(t) } function e0(e) { let t = e.name; if (eQ.has(t)) return e$.debug(`There were multiple attempts to register component ${t}.`), !1; for (let n of (eQ.set(t, e), eY.values())) eX(n, e); for (let t of eJ.values()) eX(t, e); return !0 } function e1(e, t) { let n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return n && n.triggerHeartbeat(), e.container.getProvider(t) } function e2(e, t, n = eG) { e1(e, t).clearInstance(n) } function e3(e) { return void 0 !== e.options } function e4(e) { return void 0 !== e.settings } function e5() { eQ.clear() } let e6 = new G("app", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first", "bad-app-name": "Illegal App name: '{$appName}'", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "server-app-deleted": "Firebase Server App has been deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.", "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.", "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments." }); class e8 { constructor(e, t, n) { this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new ew("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this.checkDestroyed(), this._automaticDataCollectionEnabled = e } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(e) { this._isDeleted = e } checkDestroyed() { if (this.isDeleted) throw e6.create("app-deleted", { appName: this._name }) } } class e7 extends e8 { constructor(e, t, n, i) { let r = void 0 !== t.automaticDataCollectionEnabled && t.automaticDataCollectionEnabled, s = { name: n, automaticDataCollectionEnabled: r }; void 0 !== e.apiKey ? super(e, s, i) : super(e.options, s, i), this._serverConfig = Object.assign({ automaticDataCollectionEnabled: r }, t), this._finalizationRegistry = null, "undefined" != typeof FinalizationRegistry && (this._finalizationRegistry = new FinalizationRegistry(() => { this.automaticCleanup() })), this._refCount = 0, this.incRefCount(this._serverConfig.releaseOnDeref), this._serverConfig.releaseOnDeref = void 0, t.releaseOnDeref = void 0, ts(eB, eH, "serverapp") } toJSON() { } get refCount() { return this._refCount } incRefCount(e) { this.isDeleted || (this._refCount++, void 0 !== e && null !== this._finalizationRegistry && this._finalizationRegistry.register(e, this)) } decRefCount() { return this.isDeleted ? 0 : --this._refCount } automaticCleanup() { tr(this) } get settings() { return this.checkDestroyed(), this._serverConfig } checkDestroyed() { if (this.isDeleted) throw e6.create("server-app-deleted") } } let e9 = "10.14.1"; function te(e, t = {}) { let n = e; "object" != typeof t && (t = { name: t }); let i = Object.assign({ name: eG, automaticDataCollectionEnabled: !1 }, t), r = i.name; if ("string" != typeof r || !r) throw e6.create("bad-app-name", { appName: String(r) }); if (n || (n = L()), !n) throw e6.create("no-options"); let s = eY.get(r); if (s) if (er(n, s.options) && er(i, s.config)) return s; else throw e6.create("duplicate-app", { appName: r }); let o = new eC(r); for (let e of eQ.values()) o.addComponent(e); let a = new e8(n, i, o); return eY.set(r, a), a } function tt(e, t) { let n; if (("undefined" != typeof window || q()) && !q()) throw e6.create("invalid-server-app-environment"); void 0 === t.automaticDataCollectionEnabled && (t.automaticDataCollectionEnabled = !1), n = e3(e) ? e.options : e; let i = Object.assign(Object.assign({}, t), n); if (void 0 !== i.releaseOnDeref && delete i.releaseOnDeref, void 0 !== t.releaseOnDeref && "undefined" == typeof FinalizationRegistry) throw e6.create("finalization-registry-not-supported", {}); let r = "" + [...JSON.stringify(i)].reduce((e, t) => Math.imul(31, e) + t.charCodeAt(0) | 0, 0), s = eJ.get(r); if (s) return s.incRefCount(t.releaseOnDeref), s; let o = new eC(r); for (let e of eQ.values()) o.addComponent(e); let a = new e7(n, t, r, o); return eJ.set(r, a), a } function tn(e = eG) { let t = eY.get(e); if (!t && e === eG && L()) return te(); if (!t) throw e6.create("no-app", { appName: e }); return t } function ti() { return Array.from(eY.values()) } async function tr(e) { let t = !1, n = e.name; eY.has(n) ? (t = !0, eY.delete(n)) : eJ.has(n) && 0 >= e.decRefCount() && (eJ.delete(n), t = !0), t && (await Promise.all(e.container.getProviders().map(e => e.delete())), e.isDeleted = !0) } function ts(e, t, n) { var i; let r = null != (i = eK[e]) ? i : e; n && (r += `-${n}`); let s = r.match(/\s|\//), o = t.match(/\s|\//); if (s || o) { let e = [`Unable to register library "${r}" with version "${t}":`]; s && e.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && o && e.push("and"), o && e.push(`version name "${t}" contains illegal characters (whitespace or "/")`), e$.warn(e.join(" ")); return } e0(new ew(`${r}-version`, () => ({ library: r, version: t }), "VERSION")) } function to(e, t) { if (null !== e && "function" != typeof e) throw e6.create("invalid-log-argument"); for (let n of eT) { let i = null; t && t.level && (i = ek[t.level]), null === e ? n.userLogHandler = null : n.userLogHandler = (t, n, ...r) => { let s = r.map(e => { if (null == e) return null; if ("string" == typeof e) return e; if ("number" == typeof e || "boolean" == typeof e) return e.toString(); if (e instanceof Error) return e.message; try { return JSON.stringify(e) } catch (e) { return null } }).filter(e => e).join(" "); n >= (null != i ? i : t.logLevel) && e({ level: m[n].toLowerCase(), message: s, args: r, type: t.name }) } } } function ta(e) { eT.forEach(t => { t.setLogLevel(e) }) } let tl = "firebase-heartbeat-store", th = null; function tc() { return th || (th = (function (e, t, { blocked: n, upgrade: i, blocking: r, terminated: s } = {}) { let o = indexedDB.open(e, 1), a = ej(o); return i && o.addEventListener("upgradeneeded", e => { i(ej(o.result), e.oldVersion, e.newVersion, ej(o.transaction), e) }), n && o.addEventListener("blocked", e => n(e.oldVersion, e.newVersion, e)), a.then(e => { s && e.addEventListener("close", () => s()), r && e.addEventListener("versionchange", e => r(e.oldVersion, e.newVersion, e)) }).catch(() => { }), a })("firebase-heartbeat-database", 0, { upgrade: (e, t) => { if (0 === t) try { e.createObjectStore(tl) } catch (e) { console.warn(e) } } }).catch(e => { throw e6.create("idb-open", { originalErrorMessage: e.message }) })), th } async function tu(e) { try { let t = (await tc()).transaction(tl), n = await t.objectStore(tl).get(tp(e)); return await t.done, n } catch (e) { if (e instanceof $) e$.warn(e.message); else { let t = e6.create("idb-get", { originalErrorMessage: null == e ? void 0 : e.message }); e$.warn(t.message) } } } async function td(e, t) { try { let n = (await tc()).transaction(tl, "readwrite"), i = n.objectStore(tl); await i.put(t, tp(e)), await n.done } catch (e) { if (e instanceof $) e$.warn(e.message); else { let t = e6.create("idb-set", { originalErrorMessage: null == e ? void 0 : e.message }); e$.warn(t.message) } } } function tp(e) { return `${e.name}!${e.options.appId}` } class tf { constructor(e) { this.container = e, this._heartbeatsCache = null; let t = this.container.getProvider("app").getImmediate(); this._storage = new tg(t), this._heartbeatsCachePromise = this._storage.read().then(e => (this._heartbeatsCache = e, e)) } async triggerHeartbeat() { var e, t; try { let n = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), i = tm(); if ((null == (e = this._heartbeatsCache) ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, (null == (t = this._heartbeatsCache) ? void 0 : t.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === i || this._heartbeatsCache.heartbeats.some(e => e.date === i)) return; return this._heartbeatsCache.heartbeats.push({ date: i, agent: n }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(e => { let t = new Date(e.date).valueOf(); return Date.now() - t <= 2592e6 }), this._storage.overwrite(this._heartbeatsCache) } catch (e) { e$.warn(e) } } async getHeartbeatsHeader() { var e; try { if (null === this._heartbeatsCache && await this._heartbeatsCachePromise, (null == (e = this._heartbeatsCache) ? void 0 : e.heartbeats) == null || 0 === this._heartbeatsCache.heartbeats.length) return ""; let t = tm(), { heartbeatsToSend: n, unsentEntries: i } = function (e, t = 1024) { let n = [], i = e.slice(); for (let r of e) { let e = n.find(e => e.agent === r.agent); if (e) { if (e.dates.push(r.date), t_(n) > t) { e.dates.pop(); break } } else if (n.push({ agent: r.agent, dates: [r.date] }), t_(n) > t) { n.pop(); break } i = i.slice(1) } return { heartbeatsToSend: n, unsentEntries: i } }(this._heartbeatsCache.heartbeats), r = S(JSON.stringify({ version: 2, heartbeats: n })); return this._heartbeatsCache.lastSentHeartbeatDate = t, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), r } catch (e) { return e$.warn(e), "" } } } function tm() { return new Date().toISOString().substring(0, 10) } class tg { constructor(e) { this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return !!H() && new Promise((e, t) => { try { let n = !0, i = "validate-browser-context-for-indexeddb-analytics-module", r = self.indexedDB.open(i); r.onsuccess = () => { r.result.close(), n || self.indexedDB.deleteDatabase(i), e(!0) }, r.onupgradeneeded = () => { n = !1 }, r.onerror = () => { var e; t((null == (e = r.error) ? void 0 : e.message) || "") } } catch (e) { t(e) } }).then(() => !0).catch(() => !1) } async read() { if (!await this._canUseIndexedDBPromise) return { heartbeats: [] }; { let e = await tu(this.app); return (null == e ? void 0 : e.heartbeats) ? e : { heartbeats: [] } } } async overwrite(e) { var t; if (await this._canUseIndexedDBPromise) { let n = await this.read(); return td(this.app, { lastSentHeartbeatDate: null != (t = e.lastSentHeartbeatDate) ? t : n.lastSentHeartbeatDate, heartbeats: e.heartbeats }) } } async add(e) { var t; if (await this._canUseIndexedDBPromise) { let n = await this.read(); return td(this.app, { lastSentHeartbeatDate: null != (t = e.lastSentHeartbeatDate) ? t : n.lastSentHeartbeatDate, heartbeats: [...n.heartbeats, ...e.heartbeats] }) } } } function t_(e) { return S(JSON.stringify({ version: 2, heartbeats: e })).length } e0(new ew("platform-logger", e => new eV(e), "PRIVATE")), e0(new ew("heartbeat", e => new tf(e), "PRIVATE")), ts(eB, eH, ""), ts(eB, eH, "esm2017"), ts("fire-js", ""); class tv { constructor(e, t) { this._delegate = e, this.firebase = t, eX(e, new ew("app-compat", () => this, "PUBLIC")), this.container = e.container } get automaticDataCollectionEnabled() { return this._delegate.automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this._delegate.automaticDataCollectionEnabled = e } get name() { return this._delegate.name } get options() { return this._delegate.options } delete() { return new Promise(e => { this._delegate.checkDestroyed(), e() }).then(() => (this.firebase.INTERNAL.removeApp(this.name), tr(this._delegate))) } _getService(e, t = eG) { var n; this._delegate.checkDestroyed(); let i = this._delegate.container.getProvider(e); return i.isInitialized() || (null == (n = i.getComponent()) ? void 0 : n.instantiationMode) !== "EXPLICIT" || i.initialize(), i.getImmediate({ identifier: t }) } _removeServiceInstance(e, t = eG) { this._delegate.container.getProvider(e).clearInstance(t) } _addComponent(e) { eX(this._delegate, e) } _addOrOverwriteComponent(e) { eZ(this._delegate, e) } toJSON() { return { name: this.name, automaticDataCollectionEnabled: this.automaticDataCollectionEnabled, options: this.options } } } let ty = new G("app-compat", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance." }), tw = function e() { let t = function (e) { let t = {}, n = { __esModule: !0, initializeApp: function (i, r = {}) { let s = te(i, r); if (ee(t, s.name)) return t[s.name]; let o = new e(s, n); return t[s.name] = o, o }, app: i, registerVersion: ts, setLogLevel: ta, onLog: to, apps: null, SDK_VERSION: e9, INTERNAL: { registerComponent: function (t) { let r = t.name, s = r.replace("-compat", ""); if (e0(t) && "PUBLIC" === t.type) { let o = (e = i()) => { if ("function" != typeof e[s]) throw ty.create("invalid-app-argument", { appName: r }); return e[s]() }; void 0 !== t.serviceProps && N(o, t.serviceProps), n[s] = o, e.prototype[s] = function (...e) { return this._getService.bind(this, r).apply(this, t.multipleInstances ? e : []) } } return "PUBLIC" === t.type ? n[s] : null }, removeApp: function (e) { delete t[e] }, useAsService: function (e, t) { return "serverAuth" === t ? null : t }, modularAPIs: _ } }; function i(e) { if (!ee(t, e = e || eG)) throw ty.create("no-app", { appName: e }); return t[e] } return n.default = n, Object.defineProperty(n, "apps", { get: function () { return Object.keys(t).map(e => t[e]) } }), i.App = e, n }(tv); return t.INTERNAL = Object.assign(Object.assign({}, t.INTERNAL), { createFirebaseNamespace: e, extendNamespace: function (e) { N(t, e) }, createSubscribe: ec, ErrorFactory: G, deepExtend: N }), t }(), tb = new eN("@firebase/app-compat"); try {
      let e = R(); if (void 0 !== e.firebase) {
        tb.warn(`
      Warning: Firebase is already defined in the global scope. Please make sure
      Firebase library is only loaded once.
    `); let t = e.firebase.SDK_VERSION; t && t.indexOf("LITE") >= 0 && tb.warn(`
        Warning: You are trying to load Firebase while using Firebase Performance standalone script.
        You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.
        `)
      }
    } catch (e) { } ts("@firebase/app-compat", "0.2.43", void 0), tw.registerVersion("firebase", "10.14.1", "app-compat"); var tI = n(5364); let tC = "@firebase/database", tT = "1.0.8", tk = ""; class tE { constructor(e) { this.domStorage_ = e, this.prefix_ = "firebase:" } set(e, t) { null == t ? this.domStorage_.removeItem(this.prefixedName_(e)) : this.domStorage_.setItem(this.prefixedName_(e), J(t)) } get(e) { let t = this.domStorage_.getItem(this.prefixedName_(e)); return null == t ? null : Y(t) } remove(e) { this.domStorage_.removeItem(this.prefixedName_(e)) } prefixedName_(e) { return this.prefix_ + e } toString() { return this.domStorage_.toString() } } class tS { constructor() { this.cache_ = {}, this.isInMemoryStorage = !0 } set(e, t) { null == t ? delete this.cache_[e] : this.cache_[e] = t } get(e) { return ee(this.cache_, e) ? this.cache_[e] : null } remove(e) { delete this.cache_[e] } } let tP = function (e) { try { if ("undefined" != typeof window && void 0 !== window[e]) { let t = window[e]; return t.setItem("firebase:sentinel", "cache"), t.removeItem("firebase:sentinel"), new tE(t) } } catch (e) { } return new tS }, tN = tP("localStorage"), tR = tP("sessionStorage"), tx = new eN("@firebase/database"), tA = function () { let e = 1; return function () { return e++ } }(), tO = function (e) { let t = e_(e), n = new eh; n.update(t); let i = n.digest(); return T.encodeByteArray(i) }, tD = function (...e) { let t = ""; for (let n = 0; n < e.length; n++) { let i = e[n]; Array.isArray(i) || i && "object" == typeof i && "number" == typeof i.length ? t += tD.apply(null, i) : "object" == typeof i ? t += J(i) : t += i, t += " " } return t }, tL = null, tM = !0, tj = function (e, t) { w(!t || !0 === e || !1 === e, "Can't turn on custom loggers persistently."), !0 === e ? (tx.logLevel = m.VERBOSE, tL = tx.log.bind(tx), t && tR.set("logging_enabled", !0)) : "function" == typeof e ? tL = e : (tL = null, tR.remove("logging_enabled")) }, tF = function (...e) { if (!0 === tM && (tM = !1, null === tL && !0 === tR.get("logging_enabled") && tj(!0)), tL) { let t = tD.apply(null, e); tL(t) } }, tU = function (e) { return function (...t) { tF(e, ...t) } }, tq = function (...e) { let t = "FIREBASE INTERNAL ERROR: " + tD(...e); tx.error(t) }, tW = function (...e) { let t = `FIREBASE FATAL ERROR: ${tD(...e)}`; throw tx.error(t), Error(t) }, tz = function (...e) { let t = "FIREBASE WARNING: " + tD(...e); tx.warn(t) }, tV = function () { "undefined" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && tz("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().") }, tB = function (e) { return "number" == typeof e && (e != e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY) }, tH = function (e) { if (B() || "complete" === document.readyState) e(); else { let t = !1, n = function () { if (!document.body) return void setTimeout(n, Math.floor(10)); t || (t = !0, e()) }; document.addEventListener ? (document.addEventListener("DOMContentLoaded", n, !1), window.addEventListener("load", n, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", () => { "complete" === document.readyState && n() }), window.attachEvent("onload", n)) } }, t$ = "[MIN_NAME]", tG = "[MAX_NAME]", tK = function (e, t) { if (e === t) return 0; { if (e === t$ || t === tG) return -1; if (t === t$ || e === tG) return 1; let n = t2(e), i = t2(t); if (null !== n) if (null !== i) return n - i == 0 ? e.length - t.length : n - i; else return -1; return null !== i ? 1 : e < t ? -1 : 1 } }, tY = function (e, t) { return e === t ? 0 : e < t ? -1 : 1 }, tJ = function (e, t) { if (t && e in t) return t[e]; throw Error("Missing required key (" + e + ") in object: " + J(t)) }, tQ = function (e) { if ("object" != typeof e || null === e) return J(e); let t = []; for (let n in e) t.push(n); t.sort(); let n = "{"; for (let i = 0; i < t.length; i++)0 !== i && (n += ","), n += J(t[i]), n += ":", n += tQ(e[t[i]]); return n + "}" }, tX = function (e, t) { let n = e.length; if (n <= t) return [e]; let i = []; for (let r = 0; r < n; r += t)r + t > n ? i.push(e.substring(r, n)) : i.push(e.substring(r, r + t)); return i }; function tZ(e, t) { for (let n in e) e.hasOwnProperty(n) && t(n, e[n]) } let t0 = function (e) { let t, n, i, r, s; w(!tB(e), "Invalid JSON number"); 0 === e ? (n = 0, i = 0, t = +(1 / e == -1 / 0)) : (t = e < 0, (e = Math.abs(e)) >= 22250738585072014e-324 ? (n = (r = Math.min(Math.floor(Math.log(e) / Math.LN2), 1023)) + 1023, i = Math.round(e * Math.pow(2, 52 - r) - 0x10000000000000)) : (n = 0, i = Math.round(e / 5e-324))); let o = []; for (s = 52; s; s -= 1)o.push(i % 2 ? 1 : 0), i = Math.floor(i / 2); for (s = 11; s; s -= 1)o.push(n % 2 ? 1 : 0), n = Math.floor(n / 2); o.push(+!!t), o.reverse(); let a = o.join(""), l = ""; for (s = 0; s < 64; s += 8) { let e = parseInt(a.substr(s, 8), 2).toString(16); 1 === e.length && (e = "0" + e), l += e } return l.toLowerCase() }, t1 = RegExp("^-?(0*)\\d{1,10}$"), t2 = function (e) { if (t1.test(e)) { let t = Number(e); if (t >= -0x80000000 && t <= 0x7fffffff) return t } return null }, t3 = function (e) { try { e() } catch (e) { setTimeout(() => { throw tz("Exception was thrown by user callback.", e.stack || ""), e }, Math.floor(0)) } }, t4 = function (e, t) { let n = setTimeout(e, t); return "number" == typeof n && "undefined" != typeof Deno && Deno.unrefTimer ? Deno.unrefTimer(n) : "object" == typeof n && n.unref && n.unref(), n }; class t5 { constructor(e, t) { this.appName_ = e, this.appCheckProvider = t, this.appCheck = null == t ? void 0 : t.getImmediate({ optional: !0 }), this.appCheck || null == t || t.get().then(e => this.appCheck = e) } getToken(e) { return this.appCheck ? this.appCheck.getToken(e) : new Promise((t, n) => { setTimeout(() => { this.appCheck ? this.getToken(e).then(t, n) : t(null) }, 0) }) } addTokenChangeListener(e) { var t; null == (t = this.appCheckProvider) || t.get().then(t => t.addTokenListener(e)) } notifyForInvalidToken() { tz(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`) } } class t6 { constructor(e, t, n) { this.appName_ = e, this.firebaseOptions_ = t, this.authProvider_ = n, this.auth_ = null, this.auth_ = n.getImmediate({ optional: !0 }), this.auth_ || n.onInit(e => this.auth_ = e) } getToken(e) { return this.auth_ ? this.auth_.getToken(e).catch(e => e && "auth/token-not-initialized" === e.code ? (tF("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(e)) : new Promise((t, n) => { setTimeout(() => { this.auth_ ? this.getToken(e).then(t, n) : t(null) }, 0) }) } addTokenChangeListener(e) { this.auth_ ? this.auth_.addAuthTokenListener(e) : this.authProvider_.get().then(t => t.addAuthTokenListener(e)) } removeTokenChangeListener(e) { this.authProvider_.get().then(t => t.removeAuthTokenListener(e)) } notifyForInvalidToken() { let e = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. '; "credential" in this.firebaseOptions_ ? e += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? e += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : e += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.', tz(e) } } class t8 { constructor(e) { this.accessToken = e } getToken(e) { return Promise.resolve({ accessToken: this.accessToken }) } addTokenChangeListener(e) { e(this.accessToken) } removeTokenChangeListener(e) { } notifyForInvalidToken() { } } t8.OWNER = "owner"; let t7 = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/, t9 = "websocket", ne = "long_polling"; class nt { constructor(e, t, n, i, r = !1, s = "", o = !1, a = !1) { this.secure = t, this.namespace = n, this.webSocketOnly = i, this.nodeAdmin = r, this.persistenceKey = s, this.includeNamespaceInQueryParams = o, this.isUsingEmulator = a, this._host = e.toLowerCase(), this._domain = this._host.substr(this._host.indexOf(".") + 1), this.internalHost = tN.get("host:" + e) || this._host } isCacheableHost() { return "s-" === this.internalHost.substr(0, 2) } isCustomHost() { return "firebaseio.com" !== this._domain && "firebaseio-demo.com" !== this._domain } get host() { return this._host } set host(e) { e !== this.internalHost && (this.internalHost = e, this.isCacheableHost() && tN.set("host:" + this._host, this.internalHost)) } toString() { let e = this.toURLString(); return this.persistenceKey && (e += "<" + this.persistenceKey + ">"), e } toURLString() { let e = this.secure ? "https://" : "http://", t = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : ""; return `${e}${this.host}/${t}` } } function nn(e, t, n) { let i; if (w("string" == typeof t, "typeof type must == string"), w("object" == typeof n, "typeof params must == object"), t === t9) i = (e.secure ? "wss://" : "ws://") + e.internalHost + "/.ws?"; else if (t === ne) i = (e.secure ? "https://" : "http://") + e.internalHost + "/.lp?"; else throw Error("Unknown connection type: " + t); (e.host !== e.internalHost || e.isCustomHost() || e.includeNamespaceInQueryParams) && (n.ns = e.namespace); let r = []; return tZ(n, (e, t) => { r.push(e + "=" + t) }), i + r.join("&") } class ni { constructor() { this.counters_ = {} } incrementCounter(e, t = 1) { ee(this.counters_, e) || (this.counters_[e] = 0), this.counters_[e] += t } get() { return N(void 0, this.counters_) } } let nr = {}, ns = {}; function no(e) { let t = e.toString(); return nr[t] || (nr[t] = new ni), nr[t] } class na { constructor(e) { this.onMessage_ = e, this.pendingResponses = [], this.currentResponseNum = 0, this.closeAfterResponse = -1, this.onClose = null } closeAfter(e, t) { this.closeAfterResponse = e, this.onClose = t, this.closeAfterResponse < this.currentResponseNum && (this.onClose(), this.onClose = null) } handleResponse(e, t) { for (this.pendingResponses[e] = t; this.pendingResponses[this.currentResponseNum];) { let e = this.pendingResponses[this.currentResponseNum]; delete this.pendingResponses[this.currentResponseNum]; for (let t = 0; t < e.length; ++t)e[t] && t3(() => { this.onMessage_(e[t]) }); if (this.currentResponseNum === this.closeAfterResponse) { this.onClose && (this.onClose(), this.onClose = null); break } this.currentResponseNum++ } } } let nl = "start"; class nh { constructor(e, t, n, i, r, s, o) { this.connId = e, this.repoInfo = t, this.applicationId = n, this.appCheckToken = i, this.authToken = r, this.transportSessionId = s, this.lastSessionId = o, this.bytesSent = 0, this.bytesReceived = 0, this.everConnected_ = !1, this.log_ = tU(e), this.stats_ = no(t), this.urlFn = e => (this.appCheckToken && (e.ac = this.appCheckToken), nn(t, ne, e)) } open(e, t) { this.curSegmentNum = 0, this.onDisconnect_ = t, this.myPacketOrderer = new na(e), this.isClosed_ = !1, this.connectTimeoutTimer_ = setTimeout(() => { this.log_("Timed out trying to connect."), this.onClosed_(), this.connectTimeoutTimer_ = null }, Math.floor(3e4)), tH(() => { if (this.isClosed_) return; this.scriptTagHolder = new nc((...e) => { let [t, n, i, r, s] = e; if (this.incrementIncomingBytes_(e), this.scriptTagHolder) if (this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null), this.everConnected_ = !0, t === nl) this.id = n, this.password = i; else if ("close" === t) n ? (this.scriptTagHolder.sendNewPolls = !1, this.myPacketOrderer.closeAfter(n, () => { this.onClosed_() })) : this.onClosed_(); else throw Error("Unrecognized command received: " + t) }, (...e) => { let [t, n] = e; this.incrementIncomingBytes_(e), this.myPacketOrderer.handleResponse(t, n) }, () => { this.onClosed_() }, this.urlFn); let e = {}; e[nl] = "t", e.ser = Math.floor(1e8 * Math.random()), this.scriptTagHolder.uniqueCallbackIdentifier && (e.cb = this.scriptTagHolder.uniqueCallbackIdentifier), e.v = "5", this.transportSessionId && (e.s = this.transportSessionId), this.lastSessionId && (e.ls = this.lastSessionId), this.applicationId && (e.p = this.applicationId), this.appCheckToken && (e.ac = this.appCheckToken), "undefined" != typeof location && location.hostname && t7.test(location.hostname) && (e.r = "f"); let t = this.urlFn(e); this.log_("Connecting via long-poll to " + t), this.scriptTagHolder.addTag(t, () => { }) }) } start() { this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password) } static forceAllow() { nh.forceAllow_ = !0 } static forceDisallow() { nh.forceDisallow_ = !0 } static isAvailable() { return !B() && (!!nh.forceAllow_ || !nh.forceDisallow_ && "undefined" != typeof document && null != document.createElement && !("object" == typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href)) && ("object" != typeof Windows || "object" != typeof Windows.UI)) } markConnectionHealthy() { } shutdown_() { this.isClosed_ = !0, this.scriptTagHolder && (this.scriptTagHolder.close(), this.scriptTagHolder = null), this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), this.myDisconnFrame = null), this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null) } onClosed_() { !this.isClosed_ && (this.log_("Longpoll is closing itself"), this.shutdown_(), this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), this.onDisconnect_ = null)) } close() { this.isClosed_ || (this.log_("Longpoll is being closed."), this.shutdown_()) } send(e) { let t = J(e); this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length); let n = tX(E(t), 1840); for (let e = 0; e < n.length; e++)this.scriptTagHolder.enqueueSegment(this.curSegmentNum, n.length, n[e]), this.curSegmentNum++ } addDisconnectPingFrame(e, t) { if (B()) return; this.myDisconnFrame = document.createElement("iframe"); let n = {}; n.dframe = "t", n.id = e, n.pw = t, this.myDisconnFrame.src = this.urlFn(n), this.myDisconnFrame.style.display = "none", document.body.appendChild(this.myDisconnFrame) } incrementIncomingBytes_(e) { let t = J(e).length; this.bytesReceived += t, this.stats_.incrementCounter("bytes_received", t) } } class nc { constructor(e, t, n, i) { if (this.onDisconnect = n, this.urlFn = i, this.outstandingRequests = new Set, this.pendingSegs = [], this.currentSerial = Math.floor(1e8 * Math.random()), this.sendNewPolls = !0, B()) this.commandCB = e, this.onMessageCB = t; else { this.uniqueCallbackIdentifier = tA(), window["pLPCommand" + this.uniqueCallbackIdentifier] = e, window["pRTLPCB" + this.uniqueCallbackIdentifier] = t, this.myIFrame = nc.createIFrame_(); let n = ""; this.myIFrame.src && "javascript:" === this.myIFrame.src.substr(0, 11) && (n = '<script>document.domain="' + document.domain + '";<\/script>'); let i = "<html><body>" + n + "</body></html>"; try { this.myIFrame.doc.open(), this.myIFrame.doc.write(i), this.myIFrame.doc.close() } catch (e) { tF("frame writing exception"), e.stack && tF(e.stack), tF(e) } } } static createIFrame_() { let e = document.createElement("iframe"); if (e.style.display = "none", document.body) { document.body.appendChild(e); try { e.contentWindow.document || tF("No IE domain setting required") } catch (t) { e.src = "javascript:void((function(){document.open();document.domain='" + document.domain + "';document.close();})())" } } else throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready."; return e.contentDocument ? e.doc = e.contentDocument : e.contentWindow ? e.doc = e.contentWindow.document : e.document && (e.doc = e.document), e } close() { this.alive = !1, this.myIFrame && (this.myIFrame.doc.body.textContent = "", setTimeout(() => { null !== this.myIFrame && (document.body.removeChild(this.myIFrame), this.myIFrame = null) }, Math.floor(0))); let e = this.onDisconnect; e && (this.onDisconnect = null, e()) } startLongPoll(e, t) { for (this.myID = e, this.myPW = t, this.alive = !0; this.newRequest_();); } newRequest_() { if (!this.alive || !this.sendNewPolls || !(this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1))) return !1; { this.currentSerial++; let e = {}; e.id = this.myID, e.pw = this.myPW, e.ser = this.currentSerial; let t = this.urlFn(e), n = "", i = 0; for (; this.pendingSegs.length > 0;)if (this.pendingSegs[0].d.length + 30 + n.length <= 1870) { let e = this.pendingSegs.shift(); n = n + "&seg" + i + "=" + e.seg + "&ts" + i + "=" + e.ts + "&d" + i + "=" + e.d, i++ } else break; return t += n, this.addLongPollTag_(t, this.currentSerial), !0 } } enqueueSegment(e, t, n) { this.pendingSegs.push({ seg: e, ts: t, d: n }), this.alive && this.newRequest_() } addLongPollTag_(e, t) { this.outstandingRequests.add(t); let n = () => { this.outstandingRequests.delete(t), this.newRequest_() }, i = setTimeout(n, Math.floor(25e3)); this.addTag(e, () => { clearTimeout(i), n() }) } addTag(e, t) { B() ? this.doNodeLongPoll(e, t) : setTimeout(() => { try { if (!this.sendNewPolls) return; let n = this.myIFrame.doc.createElement("script"); n.type = "text/javascript", n.async = !0, n.src = e, n.onload = n.onreadystatechange = function () { let e = n.readyState; e && "loaded" !== e && "complete" !== e || (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), t()) }, n.onerror = () => { tF("Long-poll script failed to load: " + e), this.sendNewPolls = !1, this.close() }, this.myIFrame.doc.body.appendChild(n) } catch (e) { } }, Math.floor(1)) } } let nu = null; "undefined" != typeof MozWebSocket ? nu = MozWebSocket : "undefined" != typeof WebSocket && (nu = WebSocket); class nd { constructor(e, t, n, i, r, s, o) { this.connId = e, this.applicationId = n, this.appCheckToken = i, this.authToken = r, this.keepaliveTimer = null, this.frames = null, this.totalFrames = 0, this.bytesSent = 0, this.bytesReceived = 0, this.log_ = tU(this.connId), this.stats_ = no(t), this.connURL = nd.connectionURL_(t, s, o, i, n), this.nodeAdmin = t.nodeAdmin } static connectionURL_(e, t, n, i, r) { let s = {}; return s.v = "5", !B() && "undefined" != typeof location && location.hostname && t7.test(location.hostname) && (s.r = "f"), t && (s.s = t), n && (s.ls = n), i && (s.ac = i), r && (s.p = r), nn(e, t9, s) } open(e, t) { this.onDisconnect = t, this.onMessage = e, this.log_("Websocket connecting to " + this.connURL), this.everConnected_ = !1, tN.set("previous_websocket_failure", !0); try { let e; if (B()) { let t = this.nodeAdmin ? "AdminNode" : "Node"; e = { headers: { "User-Agent": `Firebase/5/${tk}/${tI.platform}/${t}`, "X-Firebase-GMPID": this.applicationId || "" } }, this.authToken && (e.headers.Authorization = `Bearer ${this.authToken}`), this.appCheckToken && (e.headers["X-Firebase-AppCheck"] = this.appCheckToken); let n = tI.env, i = 0 === this.connURL.indexOf("wss://") ? n.HTTPS_PROXY || n.https_proxy : n.HTTP_PROXY || n.http_proxy; i && (e.proxy = { origin: i }) } this.mySock = new nu(this.connURL, [], e) } catch (t) { this.log_("Error instantiating WebSocket."); let e = t.message || t.data; e && this.log_(e), this.onClosed_(); return } this.mySock.onopen = () => { this.log_("Websocket connected."), this.everConnected_ = !0 }, this.mySock.onclose = () => { this.log_("Websocket connection was disconnected."), this.mySock = null, this.onClosed_() }, this.mySock.onmessage = e => { this.handleIncomingFrame(e) }, this.mySock.onerror = e => { this.log_("WebSocket error.  Closing connection."); let t = e.message || e.data; t && this.log_(t), this.onClosed_() } } start() { } static forceDisallow() { nd.forceDisallow_ = !0 } static isAvailable() { let e = !1; if ("undefined" != typeof navigator && navigator.userAgent) { let t = navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/); t && t.length > 1 && 4.4 > parseFloat(t[1]) && (e = !0) } return !e && null !== nu && !nd.forceDisallow_ } static previouslyFailed() { return tN.isInMemoryStorage || !0 === tN.get("previous_websocket_failure") } markConnectionHealthy() { tN.remove("previous_websocket_failure") } appendFrame_(e) { if (this.frames.push(e), this.frames.length === this.totalFrames) { let e = this.frames.join(""); this.frames = null; let t = Y(e); this.onMessage(t) } } handleNewFrameCount_(e) { this.totalFrames = e, this.frames = [] } extractFrameCount_(e) { if (w(null === this.frames, "We already have a frame buffer"), e.length <= 6) { let t = Number(e); if (!isNaN(t)) return this.handleNewFrameCount_(t), null } return this.handleNewFrameCount_(1), e } handleIncomingFrame(e) { if (null === this.mySock) return; let t = e.data; if (this.bytesReceived += t.length, this.stats_.incrementCounter("bytes_received", t.length), this.resetKeepAlive(), null !== this.frames) this.appendFrame_(t); else { let e = this.extractFrameCount_(t); null !== e && this.appendFrame_(e) } } send(e) { this.resetKeepAlive(); let t = J(e); this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length); let n = tX(t, 16384); n.length > 1 && this.sendString_(String(n.length)); for (let e = 0; e < n.length; e++)this.sendString_(n[e]) } shutdown_() { this.isClosed_ = !0, this.keepaliveTimer && (clearInterval(this.keepaliveTimer), this.keepaliveTimer = null), this.mySock && (this.mySock.close(), this.mySock = null) } onClosed_() { !this.isClosed_ && (this.log_("WebSocket is closing itself"), this.shutdown_(), this.onDisconnect && (this.onDisconnect(this.everConnected_), this.onDisconnect = null)) } close() { this.isClosed_ || (this.log_("WebSocket is being closed"), this.shutdown_()) } resetKeepAlive() { clearInterval(this.keepaliveTimer), this.keepaliveTimer = setInterval(() => { this.mySock && this.sendString_("0"), this.resetKeepAlive() }, Math.floor(45e3)) } sendString_(e) { try { this.mySock.send(e) } catch (e) { this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection."), setTimeout(this.onClosed_.bind(this), 0) } } } nd.responsesRequiredToBeHealthy = 2, nd.healthyTimeout = 3e4; class np { constructor(e) { this.initTransports_(e) } static get ALL_TRANSPORTS() { return [nh, nd] } static get IS_TRANSPORT_INITIALIZED() { return this.globalTransportInitialized_ } initTransports_(e) { let t = nd && nd.isAvailable(), n = t && !nd.previouslyFailed(); if (e.webSocketOnly && (t || tz("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), n = !0), n) this.transports_ = [nd]; else { let e = this.transports_ = []; for (let t of np.ALL_TRANSPORTS) t && t.isAvailable() && e.push(t); np.globalTransportInitialized_ = !0 } } initialTransport() { if (this.transports_.length > 0) return this.transports_[0]; throw Error("No transports available") } upgradeTransport() { return this.transports_.length > 1 ? this.transports_[1] : null } } np.globalTransportInitialized_ = !1; class nf { constructor(e, t, n, i, r, s, o, a, l, h) { this.id = e, this.repoInfo_ = t, this.applicationId_ = n, this.appCheckToken_ = i, this.authToken_ = r, this.onMessage_ = s, this.onReady_ = o, this.onDisconnect_ = a, this.onKill_ = l, this.lastSessionId = h, this.connectionCount = 0, this.pendingDataMessages = [], this.state_ = 0, this.log_ = tU("c:" + this.id + ":"), this.transportManager_ = new np(t), this.log_("Connection created"), this.start_() } start_() { let e = this.transportManager_.initialTransport(); this.conn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId), this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0; let t = this.connReceiver_(this.conn_), n = this.disconnReceiver_(this.conn_); this.tx_ = this.conn_, this.rx_ = this.conn_, this.secondaryConn_ = null, this.isHealthy_ = !1, setTimeout(() => { this.conn_ && this.conn_.open(t, n) }, Math.floor(0)); let i = e.healthyTimeout || 0; i > 0 && (this.healthyTimeout_ = t4(() => { this.healthyTimeout_ = null, this.isHealthy_ || (this.conn_ && this.conn_.bytesReceived > 102400 ? (this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()) : this.conn_ && this.conn_.bytesSent > 10240 ? this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.") : (this.log_("Closing unhealthy connection after timeout."), this.close())) }, Math.floor(i))) } nextTransportId_() { return "c:" + this.id + ":" + this.connectionCount++ } disconnReceiver_(e) { return t => { e === this.conn_ ? this.onConnectionLost_(t) : e === this.secondaryConn_ ? (this.log_("Secondary connection lost."), this.onSecondaryConnectionLost_()) : this.log_("closing an old connection") } } connReceiver_(e) { return t => { 2 !== this.state_ && (e === this.rx_ ? this.onPrimaryMessageReceived_(t) : e === this.secondaryConn_ ? this.onSecondaryMessageReceived_(t) : this.log_("message on old connection")) } } sendRequest(e) { this.sendData_({ t: "d", d: e }) } tryCleanupConnection() { this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_ && (this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId), this.conn_ = this.secondaryConn_, this.secondaryConn_ = null) } onSecondaryControl_(e) { if ("t" in e) { let t = e.t; "a" === t ? this.upgradeIfSecondaryHealthy_() : "r" === t ? (this.log_("Got a reset on secondary, closing it"), this.secondaryConn_.close(), (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) && this.close()) : "o" === t && (this.log_("got pong on secondary."), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_()) } } onSecondaryMessageReceived_(e) { let t = tJ("t", e), n = tJ("d", e); if ("c" === t) this.onSecondaryControl_(n); else if ("d" === t) this.pendingDataMessages.push(n); else throw Error("Unknown protocol layer: " + t) } upgradeIfSecondaryHealthy_() { this.secondaryResponsesRequired_ <= 0 ? (this.log_("Secondary connection is healthy."), this.isHealthy_ = !0, this.secondaryConn_.markConnectionHealthy(), this.proceedWithUpgrade_()) : (this.log_("sending ping on secondary."), this.secondaryConn_.send({ t: "c", d: { t: "p", d: {} } })) } proceedWithUpgrade_() { this.secondaryConn_.start(), this.log_("sending client ack on secondary"), this.secondaryConn_.send({ t: "c", d: { t: "a", d: {} } }), this.log_("Ending transmission on primary"), this.conn_.send({ t: "c", d: { t: "n", d: {} } }), this.tx_ = this.secondaryConn_, this.tryCleanupConnection() } onPrimaryMessageReceived_(e) { let t = tJ("t", e), n = tJ("d", e); "c" === t ? this.onControl_(n) : "d" === t && this.onDataMessage_(n) } onDataMessage_(e) { this.onPrimaryResponse_(), this.onMessage_(e) } onPrimaryResponse_() { !this.isHealthy_ && (this.primaryResponsesRequired_--, this.primaryResponsesRequired_ <= 0 && (this.log_("Primary connection is healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy())) } onControl_(e) { let t = tJ("t", e); if ("d" in e) { let n = e.d; if ("h" === t) { let e = Object.assign({}, n); this.repoInfo_.isUsingEmulator && (e.h = this.repoInfo_.host), this.onHandshake_(e) } else if ("n" === t) { this.log_("recvd end transmission on primary"), this.rx_ = this.secondaryConn_; for (let e = 0; e < this.pendingDataMessages.length; ++e)this.onDataMessage_(this.pendingDataMessages[e]); this.pendingDataMessages = [], this.tryCleanupConnection() } else "s" === t ? this.onConnectionShutdown_(n) : "r" === t ? this.onReset_(n) : "e" === t ? tq("Server Error: " + n) : "o" === t ? (this.log_("got pong on primary."), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_()) : tq("Unknown control packet command: " + t) } } onHandshake_(e) { let t = e.ts, n = e.v, i = e.h; this.sessionId = e.s, this.repoInfo_.host = i, 0 === this.state_ && (this.conn_.start(), this.onConnectionEstablished_(this.conn_, t), "5" !== n && tz("Protocol version mismatch detected"), this.tryStartUpgrade_()) } tryStartUpgrade_() { let e = this.transportManager_.upgradeTransport(); e && this.startUpgrade_(e) } startUpgrade_(e) { this.secondaryConn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId), this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0; let t = this.connReceiver_(this.secondaryConn_), n = this.disconnReceiver_(this.secondaryConn_); this.secondaryConn_.open(t, n), t4(() => { this.secondaryConn_ && (this.log_("Timed out trying to upgrade."), this.secondaryConn_.close()) }, Math.floor(6e4)) } onReset_(e) { this.log_("Reset packet received.  New host: " + e), this.repoInfo_.host = e, 1 === this.state_ ? this.close() : (this.closeConnections_(), this.start_()) } onConnectionEstablished_(e, t) { this.log_("Realtime connection established."), this.conn_ = e, this.state_ = 1, this.onReady_ && (this.onReady_(t, this.sessionId), this.onReady_ = null), 0 === this.primaryResponsesRequired_ ? (this.log_("Primary connection is healthy."), this.isHealthy_ = !0) : t4(() => { this.sendPingOnPrimaryIfNecessary_() }, Math.floor(5e3)) } sendPingOnPrimaryIfNecessary_() { this.isHealthy_ || 1 !== this.state_ || (this.log_("sending ping on primary."), this.sendData_({ t: "c", d: { t: "p", d: {} } })) } onSecondaryConnectionLost_() { let e = this.secondaryConn_; this.secondaryConn_ = null, (this.tx_ === e || this.rx_ === e) && this.close() } onConnectionLost_(e) { this.conn_ = null, e || 0 !== this.state_ ? 1 === this.state_ && this.log_("Realtime connection lost.") : (this.log_("Realtime connection failed."), this.repoInfo_.isCacheableHost() && (tN.remove("host:" + this.repoInfo_.host), this.repoInfo_.internalHost = this.repoInfo_.host)), this.close() } onConnectionShutdown_(e) { this.log_("Connection shutdown command received. Shutting down..."), this.onKill_ && (this.onKill_(e), this.onKill_ = null), this.onDisconnect_ = null, this.close() } sendData_(e) { if (1 !== this.state_) throw "Connection is not connected"; this.tx_.send(e) } close() { 2 !== this.state_ && (this.log_("Closing realtime connection."), this.state_ = 2, this.closeConnections_(), this.onDisconnect_ && (this.onDisconnect_(), this.onDisconnect_ = null)) } closeConnections_() { this.log_("Shutting down all connections"), this.conn_ && (this.conn_.close(), this.conn_ = null), this.secondaryConn_ && (this.secondaryConn_.close(), this.secondaryConn_ = null), this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), this.healthyTimeout_ = null) } } class nm { put(e, t, n, i) { } merge(e, t, n, i) { } refreshAuthToken(e) { } refreshAppCheckToken(e) { } onDisconnectPut(e, t, n) { } onDisconnectMerge(e, t, n) { } onDisconnectCancel(e, t) { } reportStats(e) { } } class ng { constructor(e) { this.allowedEvents_ = e, this.listeners_ = {}, w(Array.isArray(e) && e.length > 0, "Requires a non-empty array") } trigger(e, ...t) { if (Array.isArray(this.listeners_[e])) { let n = [...this.listeners_[e]]; for (let e = 0; e < n.length; e++)n[e].callback.apply(n[e].context, t) } } on(e, t, n) { this.validateEventType_(e), this.listeners_[e] = this.listeners_[e] || [], this.listeners_[e].push({ callback: t, context: n }); let i = this.getInitialEvent(e); i && t.apply(n, i) } off(e, t, n) { this.validateEventType_(e); let i = this.listeners_[e] || []; for (let e = 0; e < i.length; e++)if (i[e].callback === t && (!n || n === i[e].context)) return void i.splice(e, 1) } validateEventType_(e) { w(this.allowedEvents_.find(t => t === e), "Unknown event: " + e) } } class n_ extends ng { constructor() { super(["online"]), this.online_ = !0, "undefined" == typeof window || void 0 === window.addEventListener || F() || (window.addEventListener("online", () => { this.online_ || (this.online_ = !0, this.trigger("online", !0)) }, !1), window.addEventListener("offline", () => { this.online_ && (this.online_ = !1, this.trigger("online", !1)) }, !1)) } static getInstance() { return new n_ } getInitialEvent(e) { return w("online" === e, "Unknown event type: " + e), [this.online_] } currentlyOnline() { return this.online_ } } class nv { constructor(e, t) { if (void 0 === t) { this.pieces_ = e.split("/"); let t = 0; for (let e = 0; e < this.pieces_.length; e++)this.pieces_[e].length > 0 && (this.pieces_[t] = this.pieces_[e], t++); this.pieces_.length = t, this.pieceNum_ = 0 } else this.pieces_ = e, this.pieceNum_ = t } toString() { let e = ""; for (let t = this.pieceNum_; t < this.pieces_.length; t++)"" !== this.pieces_[t] && (e += "/" + this.pieces_[t]); return e || "/" } } function ny() { return new nv("") } function nw(e) { return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_] } function nb(e) { return e.pieces_.length - e.pieceNum_ } function nI(e) { let t = e.pieceNum_; return t < e.pieces_.length && t++, new nv(e.pieces_, t) } function nC(e) { return e.pieceNum_ < e.pieces_.length ? e.pieces_[e.pieces_.length - 1] : null } function nT(e, t = 0) { return e.pieces_.slice(e.pieceNum_ + t) } function nk(e) { if (e.pieceNum_ >= e.pieces_.length) return null; let t = []; for (let n = e.pieceNum_; n < e.pieces_.length - 1; n++)t.push(e.pieces_[n]); return new nv(t, 0) } function nE(e, t) { let n = []; for (let t = e.pieceNum_; t < e.pieces_.length; t++)n.push(e.pieces_[t]); if (t instanceof nv) for (let e = t.pieceNum_; e < t.pieces_.length; e++)n.push(t.pieces_[e]); else { let e = t.split("/"); for (let t = 0; t < e.length; t++)e[t].length > 0 && n.push(e[t]) } return new nv(n, 0) } function nS(e) { return e.pieceNum_ >= e.pieces_.length } function nP(e, t) { let n = nw(e), i = nw(t); if (null === n) return t; if (n === i) return nP(nI(e), nI(t)); throw Error("INTERNAL ERROR: innerPath (" + t + ") is not within outerPath (" + e + ")") } function nN(e, t) { let n = nT(e, 0), i = nT(t, 0); for (let e = 0; e < n.length && e < i.length; e++) { let t = tK(n[e], i[e]); if (0 !== t) return t } return n.length === i.length ? 0 : n.length < i.length ? -1 : 1 } function nR(e, t) { if (nb(e) !== nb(t)) return !1; for (let n = e.pieceNum_, i = t.pieceNum_; n <= e.pieces_.length; n++, i++)if (e.pieces_[n] !== t.pieces_[i]) return !1; return !0 } function nx(e, t) { let n = e.pieceNum_, i = t.pieceNum_; if (nb(e) > nb(t)) return !1; for (; n < e.pieces_.length;) { if (e.pieces_[n] !== t.pieces_[i]) return !1; ++n, ++i } return !0 } class nA { constructor(e, t) { this.errorPrefix_ = t, this.parts_ = nT(e, 0), this.byteLength_ = Math.max(1, this.parts_.length); for (let e = 0; e < this.parts_.length; e++)this.byteLength_ += ev(this.parts_[e]); nO(this) } } function nO(e) { if (e.byteLength_ > 768) throw Error(e.errorPrefix_ + "has a key path longer than 768 bytes (" + e.byteLength_ + ")."); if (e.parts_.length > 32) throw Error(e.errorPrefix_ + "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " + nD(e)) } function nD(e) { return 0 === e.parts_.length ? "" : "in property '" + e.parts_.join(".") + "'" } class nL extends ng { constructor() { let e, t; super(["visible"]), "undefined" != typeof document && void 0 !== document.addEventListener && (void 0 !== document.hidden ? (t = "visibilitychange", e = "hidden") : void 0 !== document.mozHidden ? (t = "mozvisibilitychange", e = "mozHidden") : void 0 !== document.msHidden ? (t = "msvisibilitychange", e = "msHidden") : void 0 !== document.webkitHidden && (t = "webkitvisibilitychange", e = "webkitHidden")), this.visible_ = !0, t && document.addEventListener(t, () => { let t = !document[e]; t !== this.visible_ && (this.visible_ = t, this.trigger("visible", t)) }, !1) } static getInstance() { return new nL } getInitialEvent(e) { return w("visible" === e, "Unknown event type: " + e), [this.visible_] } } class nM extends nm { constructor(e, t, n, i, r, s, o, a) { if (super(), this.repoInfo_ = e, this.applicationId_ = t, this.onDataUpdate_ = n, this.onConnectStatus_ = i, this.onServerInfoUpdate_ = r, this.authTokenProvider_ = s, this.appCheckTokenProvider_ = o, this.authOverride_ = a, this.id = nM.nextPersistentConnectionId_++, this.log_ = tU("p:" + this.id + ":"), this.interruptReasons_ = {}, this.listens = new Map, this.outstandingPuts_ = [], this.outstandingGets_ = [], this.outstandingPutCount_ = 0, this.outstandingGetCount_ = 0, this.onDisconnectRequestQueue_ = [], this.connected_ = !1, this.reconnectDelay_ = 1e3, this.maxReconnectDelay_ = 3e5, this.securityDebugCallback_ = null, this.lastSessionId = null, this.establishConnectionTimer_ = null, this.visible_ = !1, this.requestCBHash_ = {}, this.requestNumber_ = 0, this.realtime_ = null, this.authToken_ = null, this.appCheckToken_ = null, this.forceTokenRefresh_ = !1, this.invalidAuthTokenCount_ = 0, this.invalidAppCheckTokenCount_ = 0, this.firstConnection_ = !0, this.lastConnectionAttemptTime_ = null, this.lastConnectionEstablishedTime_ = null, a && !B()) throw Error("Auth override specified in options, but not supported on non Node.js platforms"); nL.getInstance().on("visible", this.onVisible_, this), -1 === e.host.indexOf("fblocal") && n_.getInstance().on("online", this.onOnline_, this) } sendRequest(e, t, n) { let i = ++this.requestNumber_, r = { r: i, a: e, b: t }; this.log_(J(r)), w(this.connected_, "sendRequest call when we're not connected not allowed."), this.realtime_.sendRequest(r), n && (this.requestCBHash_[i] = n) } get(e) { this.initConnection_(); let t = new M, n = { p: e._path.toString(), q: e._queryObject }; this.outstandingGets_.push({ action: "g", request: n, onComplete: e => { let n = e.d; "ok" === e.s ? t.resolve(n) : t.reject(n) } }), this.outstandingGetCount_++; let i = this.outstandingGets_.length - 1; return this.connected_ && this.sendGet_(i), t.promise } listen(e, t, n, i) { this.initConnection_(); let r = e._queryIdentifier, s = e._path.toString(); this.log_("Listen called for " + s + " " + r), this.listens.has(s) || this.listens.set(s, new Map), w(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "listen() called for non-default but complete query"), w(!this.listens.get(s).has(r), "listen() called twice for same path/queryId."); let o = { onComplete: i, hashFn: t, query: e, tag: n }; this.listens.get(s).set(r, o), this.connected_ && this.sendListen_(o) } sendGet_(e) { let t = this.outstandingGets_[e]; this.sendRequest("g", t.request, n => { delete this.outstandingGets_[e], this.outstandingGetCount_--, 0 === this.outstandingGetCount_ && (this.outstandingGets_ = []), t.onComplete && t.onComplete(n) }) } sendListen_(e) { let t = e.query, n = t._path.toString(), i = t._queryIdentifier; this.log_("Listen on " + n + " for " + i); let r = { p: n }; e.tag && (r.q = t._queryObject, r.t = e.tag), r.h = e.hashFn(), this.sendRequest("q", r, r => { let s = r.d, o = r.s; nM.warnOnListenWarnings_(s, t), (this.listens.get(n) && this.listens.get(n).get(i)) === e && (this.log_("listen response", r), "ok" !== o && this.removeListen_(n, i), e.onComplete && e.onComplete(o, s)) }) } static warnOnListenWarnings_(e, t) { if (e && "object" == typeof e && ee(e, "w")) { let n = et(e, "w"); if (Array.isArray(n) && ~n.indexOf("no_index")) { let e = '".indexOn": "' + t._queryParams.getIndex().toString() + '"', n = t._path.toString(); tz(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${e} at ${n} to your security rules for better performance.`) } } } refreshAuthToken(e) { this.authToken_ = e, this.log_("Auth token refreshed"), this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, () => { }), this.reduceReconnectDelayIfAdminCredential_(e) } reduceReconnectDelayIfAdminCredential_(e) { (e && 40 === e.length || Z(e)) && (this.log_("Admin auth credential detected.  Reducing max reconnect time."), this.maxReconnectDelay_ = 3e4) } refreshAppCheckToken(e) { this.appCheckToken_ = e, this.log_("App check token refreshed"), this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest("unappeck", {}, () => { }) } tryAuth() { if (this.connected_ && this.authToken_) { let e = this.authToken_, t = X(e) ? "auth" : "gauth", n = { cred: e }; null === this.authOverride_ ? n.noauth = !0 : "object" == typeof this.authOverride_ && (n.authvar = this.authOverride_), this.sendRequest(t, n, t => { let n = t.s, i = t.d || "error"; this.authToken_ === e && ("ok" === n ? this.invalidAuthTokenCount_ = 0 : this.onAuthRevoked_(n, i)) }) } } tryAppCheck() { this.connected_ && this.appCheckToken_ && this.sendRequest("appcheck", { token: this.appCheckToken_ }, e => { let t = e.s, n = e.d || "error"; "ok" === t ? this.invalidAppCheckTokenCount_ = 0 : this.onAppCheckRevoked_(t, n) }) } unlisten(e, t) { let n = e._path.toString(), i = e._queryIdentifier; this.log_("Unlisten called for " + n + " " + i), w(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "unlisten() called for non-default but complete query"), this.removeListen_(n, i) && this.connected_ && this.sendUnlisten_(n, i, e._queryObject, t) } sendUnlisten_(e, t, n, i) { this.log_("Unlisten on " + e + " for " + t); let r = { p: e }; i && (r.q = n, r.t = i), this.sendRequest("n", r) } onDisconnectPut(e, t, n) { this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("o", e, t, n) : this.onDisconnectRequestQueue_.push({ pathString: e, action: "o", data: t, onComplete: n }) } onDisconnectMerge(e, t, n) { this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("om", e, t, n) : this.onDisconnectRequestQueue_.push({ pathString: e, action: "om", data: t, onComplete: n }) } onDisconnectCancel(e, t) { this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("oc", e, null, t) : this.onDisconnectRequestQueue_.push({ pathString: e, action: "oc", data: null, onComplete: t }) } sendOnDisconnect_(e, t, n, i) { let r = { p: t, d: n }; this.log_("onDisconnect " + e, r), this.sendRequest(e, r, e => { i && setTimeout(() => { i(e.s, e.d) }, Math.floor(0)) }) } put(e, t, n, i) { this.putInternal("p", e, t, n, i) } merge(e, t, n, i) { this.putInternal("m", e, t, n, i) } putInternal(e, t, n, i, r) { this.initConnection_(); let s = { p: t, d: n }; void 0 !== r && (s.h = r), this.outstandingPuts_.push({ action: e, request: s, onComplete: i }), this.outstandingPutCount_++; let o = this.outstandingPuts_.length - 1; this.connected_ ? this.sendPut_(o) : this.log_("Buffering put: " + t) } sendPut_(e) { let t = this.outstandingPuts_[e].action, n = this.outstandingPuts_[e].request, i = this.outstandingPuts_[e].onComplete; this.outstandingPuts_[e].queued = this.connected_, this.sendRequest(t, n, n => { this.log_(t + " response", n), delete this.outstandingPuts_[e], this.outstandingPutCount_--, 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []), i && i(n.s, n.d) }) } reportStats(e) { if (this.connected_) { let t = { c: e }; this.log_("reportStats", t), this.sendRequest("s", t, e => { if ("ok" !== e.s) { let t = e.d; this.log_("reportStats", "Error sending stats: " + t) } }) } } onDataMessage_(e) { if ("r" in e) { this.log_("from server: " + J(e)); let t = e.r, n = this.requestCBHash_[t]; n && (delete this.requestCBHash_[t], n(e.b)) } else if ("error" in e) throw "A server-side error has occurred: " + e.error; else "a" in e && this.onDataPush_(e.a, e.b) } onDataPush_(e, t) { this.log_("handleServerMessage", e, t), "d" === e ? this.onDataUpdate_(t.p, t.d, !1, t.t) : "m" === e ? this.onDataUpdate_(t.p, t.d, !0, t.t) : "c" === e ? this.onListenRevoked_(t.p, t.q) : "ac" === e ? this.onAuthRevoked_(t.s, t.d) : "apc" === e ? this.onAppCheckRevoked_(t.s, t.d) : "sd" === e ? this.onSecurityDebugPacket_(t) : tq("Unrecognized action received from server: " + J(e) + "\nAre you using the latest client?") } onReady_(e, t) { this.log_("connection ready"), this.connected_ = !0, this.lastConnectionEstablishedTime_ = new Date().getTime(), this.handleTimestamp_(e), this.lastSessionId = t, this.firstConnection_ && this.sendConnectStats_(), this.restoreState_(), this.firstConnection_ = !1, this.onConnectStatus_(!0) } scheduleConnect_(e) { w(!this.realtime_, "Scheduling a connect when we're already connected/ing?"), this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = setTimeout(() => { this.establishConnectionTimer_ = null, this.establishConnection_() }, Math.floor(e)) } initConnection_() { !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0) } onVisible_(e) { e && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_ && (this.log_("Window became visible.  Reducing delay."), this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)), this.visible_ = e } onOnline_(e) { e ? (this.log_("Browser went online."), this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)) : (this.log_("Browser went offline.  Killing connection."), this.realtime_ && this.realtime_.close()) } onRealtimeDisconnect_() { if (this.log_("data client disconnected"), this.connected_ = !1, this.realtime_ = null, this.cancelSentTransactions_(), this.requestCBHash_ = {}, this.shouldReconnect_()) { this.visible_ ? this.lastConnectionEstablishedTime_ && (new Date().getTime() - this.lastConnectionEstablishedTime_ > 3e4 && (this.reconnectDelay_ = 1e3), this.lastConnectionEstablishedTime_ = null) : (this.log_("Window isn't visible.  Delaying reconnect."), this.reconnectDelay_ = this.maxReconnectDelay_, this.lastConnectionAttemptTime_ = new Date().getTime()); let e = new Date().getTime() - this.lastConnectionAttemptTime_, t = Math.max(0, this.reconnectDelay_ - e); t = Math.random() * t, this.log_("Trying to reconnect in " + t + "ms"), this.scheduleConnect_(t), this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, 1.3 * this.reconnectDelay_) } this.onConnectStatus_(!1) } async establishConnection_() { if (this.shouldReconnect_()) { this.log_("Making a connection attempt"), this.lastConnectionAttemptTime_ = new Date().getTime(), this.lastConnectionEstablishedTime_ = null; let e = this.onDataMessage_.bind(this), t = this.onReady_.bind(this), n = this.onRealtimeDisconnect_.bind(this), i = this.id + ":" + nM.nextConnectionId_++, r = this.lastSessionId, s = !1, o = null, a = function () { o ? o.close() : (s = !0, n()) }; this.realtime_ = { close: a, sendRequest: function (e) { w(o, "sendRequest call when we're not connected not allowed."), o.sendRequest(e) } }; let l = this.forceTokenRefresh_; this.forceTokenRefresh_ = !1; try { let [a, h] = await Promise.all([this.authTokenProvider_.getToken(l), this.appCheckTokenProvider_.getToken(l)]); s ? tF("getToken() completed but was canceled") : (tF("getToken() completed. Creating connection."), this.authToken_ = a && a.accessToken, this.appCheckToken_ = h && h.token, o = new nf(i, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, e, t, n, e => { tz(e + " (" + this.repoInfo_.toString() + ")"), this.interrupt("server_kill") }, r)) } catch (e) { this.log_("Failed to get token: " + e), s || (this.repoInfo_.nodeAdmin && tz(e), a()) } } } interrupt(e) { tF("Interrupting connection for reason: " + e), this.interruptReasons_[e] = !0, this.realtime_ ? this.realtime_.close() : (this.establishConnectionTimer_ && (clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = null), this.connected_ && this.onRealtimeDisconnect_()) } resume(e) { tF("Resuming connection for reason: " + e), delete this.interruptReasons_[e], en(this.interruptReasons_) && (this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)) } handleTimestamp_(e) { let t = e - new Date().getTime(); this.onServerInfoUpdate_({ serverTimeOffset: t }) } cancelSentTransactions_() { for (let e = 0; e < this.outstandingPuts_.length; e++) { let t = this.outstandingPuts_[e]; t && "h" in t.request && t.queued && (t.onComplete && t.onComplete("disconnect"), delete this.outstandingPuts_[e], this.outstandingPutCount_--) } 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []) } onListenRevoked_(e, t) { let n; n = t ? t.map(e => tQ(e)).join("$") : "default"; let i = this.removeListen_(e, n); i && i.onComplete && i.onComplete("permission_denied") } removeListen_(e, t) { let n, i = new nv(e).toString(); if (this.listens.has(i)) { let e = this.listens.get(i); n = e.get(t), e.delete(t), 0 === e.size && this.listens.delete(i) } else n = void 0; return n } onAuthRevoked_(e, t) { tF("Auth token revoked: " + e + "/" + t), this.authToken_ = null, this.forceTokenRefresh_ = !0, this.realtime_.close(), ("invalid_token" === e || "permission_denied" === e) && (this.invalidAuthTokenCount_++, this.invalidAuthTokenCount_ >= 3 && (this.reconnectDelay_ = 3e4, this.authTokenProvider_.notifyForInvalidToken())) } onAppCheckRevoked_(e, t) { tF("App check token revoked: " + e + "/" + t), this.appCheckToken_ = null, this.forceTokenRefresh_ = !0, ("invalid_token" === e || "permission_denied" === e) && (this.invalidAppCheckTokenCount_++, this.invalidAppCheckTokenCount_ >= 3 && this.appCheckTokenProvider_.notifyForInvalidToken()) } onSecurityDebugPacket_(e) { this.securityDebugCallback_ ? this.securityDebugCallback_(e) : "msg" in e && console.log("FIREBASE: " + e.msg.replace("\n", "\nFIREBASE: ")) } restoreState_() { for (let e of (this.tryAuth(), this.tryAppCheck(), this.listens.values())) for (let t of e.values()) this.sendListen_(t); for (let e = 0; e < this.outstandingPuts_.length; e++)this.outstandingPuts_[e] && this.sendPut_(e); for (; this.onDisconnectRequestQueue_.length;) { let e = this.onDisconnectRequestQueue_.shift(); this.sendOnDisconnect_(e.action, e.pathString, e.data, e.onComplete) } for (let e = 0; e < this.outstandingGets_.length; e++)this.outstandingGets_[e] && this.sendGet_(e) } sendConnectStats_() { let e = {}, t = "js"; B() && (t = this.repoInfo_.nodeAdmin ? "admin_node" : "node"), e["sdk." + t + "." + tk.replace(/\./g, "-")] = 1, F() ? e["framework.cordova"] = 1 : z() && (e["framework.reactnative"] = 1), this.reportStats(e) } shouldReconnect_() { let e = n_.getInstance().currentlyOnline(); return en(this.interruptReasons_) && e } } nM.nextPersistentConnectionId_ = 0, nM.nextConnectionId_ = 0; class nj { constructor(e, t) { this.name = e, this.node = t } static Wrap(e, t) { return new nj(e, t) } } class nF { getCompare() { return this.compare.bind(this) } indexedValueChanged(e, t) { let n = new nj(t$, e), i = new nj(t$, t); return 0 !== this.compare(n, i) } minPost() { return nj.MIN } } class nU extends nF { static get __EMPTY_NODE() { return s } static set __EMPTY_NODE(e) { s = e } compare(e, t) { return tK(e.name, t.name) } isDefinedOn(e) { throw b("KeyIndex.isDefinedOn not expected to be called.") } indexedValueChanged(e, t) { return !1 } minPost() { return nj.MIN } maxPost() { return new nj(tG, s) } makePost(e, t) { return w("string" == typeof e, "KeyIndex indexValue must always be a string."), new nj(e, s) } toString() { return ".key" } } let nq = new nU; class nW { constructor(e, t, n, i, r = null) { this.isReverse_ = i, this.resultGenerator_ = r, this.nodeStack_ = []; let s = 1; for (; !e.isEmpty();)if (s = t ? n(e.key, t) : 1, i && (s *= -1), s < 0) e = this.isReverse_ ? e.left : e.right; else if (0 === s) { this.nodeStack_.push(e); break } else this.nodeStack_.push(e), e = this.isReverse_ ? e.right : e.left } getNext() { let e; if (0 === this.nodeStack_.length) return null; let t = this.nodeStack_.pop(); if (e = this.resultGenerator_ ? this.resultGenerator_(t.key, t.value) : { key: t.key, value: t.value }, this.isReverse_) for (t = t.left; !t.isEmpty();)this.nodeStack_.push(t), t = t.right; else for (t = t.right; !t.isEmpty();)this.nodeStack_.push(t), t = t.left; return e } hasNext() { return this.nodeStack_.length > 0 } peek() { if (0 === this.nodeStack_.length) return null; let e = this.nodeStack_[this.nodeStack_.length - 1]; return this.resultGenerator_ ? this.resultGenerator_(e.key, e.value) : { key: e.key, value: e.value } } } class nz { constructor(e, t, n, i, r) { this.key = e, this.value = t, this.color = null != n ? n : nz.RED, this.left = null != i ? i : nB.EMPTY_NODE, this.right = null != r ? r : nB.EMPTY_NODE } copy(e, t, n, i, r) { return new nz(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != i ? i : this.left, null != r ? r : this.right) } count() { return this.left.count() + 1 + this.right.count() } isEmpty() { return !1 } inorderTraversal(e) { return this.left.inorderTraversal(e) || !!e(this.key, this.value) || this.right.inorderTraversal(e) } reverseTraversal(e) { return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e) } min_() { return this.left.isEmpty() ? this : this.left.min_() } minKey() { return this.min_().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(e, t, n) { let i = this, r = n(e, i.key); return (i = r < 0 ? i.copy(null, null, null, i.left.insert(e, t, n), null) : 0 === r ? i.copy(null, t, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, t, n))).fixUp_() } removeMin_() { if (this.left.isEmpty()) return nB.EMPTY_NODE; let e = this; return e.left.isRed_() || e.left.left.isRed_() || (e = e.moveRedLeft_()), (e = e.copy(null, null, null, e.left.removeMin_(), null)).fixUp_() } remove(e, t) { let n, i; if (n = this, 0 > t(e, n.key)) n.left.isEmpty() || n.left.isRed_() || n.left.left.isRed_() || (n = n.moveRedLeft_()), n = n.copy(null, null, null, n.left.remove(e, t), null); else { if (n.left.isRed_() && (n = n.rotateRight_()), n.right.isEmpty() || n.right.isRed_() || n.right.left.isRed_() || (n = n.moveRedRight_()), 0 === t(e, n.key)) if (n.right.isEmpty()) return nB.EMPTY_NODE; else i = n.right.min_(), n = n.copy(i.key, i.value, null, null, n.right.removeMin_()); n = n.copy(null, null, null, null, n.right.remove(e, t)) } return n.fixUp_() } isRed_() { return this.color } fixUp_() { let e = this; return e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()), e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()), e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()), e } moveRedLeft_() { let e = this.colorFlip_(); return e.right.left.isRed_() && (e = (e = (e = e.copy(null, null, null, null, e.right.rotateRight_())).rotateLeft_()).colorFlip_()), e } moveRedRight_() { let e = this.colorFlip_(); return e.left.left.isRed_() && (e = (e = e.rotateRight_()).colorFlip_()), e } rotateLeft_() { let e = this.copy(null, null, nz.RED, null, this.right.left); return this.right.copy(null, null, this.color, e, null) } rotateRight_() { let e = this.copy(null, null, nz.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, e) } colorFlip_() { let e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, e, t) } checkMaxDepth_() { return Math.pow(2, this.check_()) <= this.count() + 1 } check_() { if (this.isRed_() && this.left.isRed_()) throw Error("Red node has red child(" + this.key + "," + this.value + ")"); if (this.right.isRed_()) throw Error("Right child of (" + this.key + "," + this.value + ") is red"); let e = this.left.check_(); if (e === this.right.check_()) return e + +!this.isRed_(); throw Error("Black depths differ") } } nz.RED = !0, nz.BLACK = !1; class nV { copy(e, t, n, i, r) { return this } insert(e, t, n) { return new nz(e, t, null) } remove(e, t) { return this } count() { return 0 } isEmpty() { return !0 } inorderTraversal(e) { return !1 } reverseTraversal(e) { return !1 } minKey() { return null } maxKey() { return null } check_() { return 0 } isRed_() { return !1 } } class nB { constructor(e, t = nB.EMPTY_NODE) { this.comparator_ = e, this.root_ = t } insert(e, t) { return new nB(this.comparator_, this.root_.insert(e, t, this.comparator_).copy(null, null, nz.BLACK, null, null)) } remove(e) { return new nB(this.comparator_, this.root_.remove(e, this.comparator_).copy(null, null, nz.BLACK, null, null)) } get(e) { let t, n = this.root_; for (; !n.isEmpty();) { if (0 === (t = this.comparator_(e, n.key))) return n.value; t < 0 ? n = n.left : t > 0 && (n = n.right) } return null } getPredecessorKey(e) { let t, n = this.root_, i = null; for (; !n.isEmpty();) { if (0 === (t = this.comparator_(e, n.key))) if (n.left.isEmpty()) if (i) return i.key; else return null; else { for (n = n.left; !n.right.isEmpty();)n = n.right; return n.key } t < 0 ? n = n.left : t > 0 && (i = n, n = n.right) } throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?") } isEmpty() { return this.root_.isEmpty() } count() { return this.root_.count() } minKey() { return this.root_.minKey() } maxKey() { return this.root_.maxKey() } inorderTraversal(e) { return this.root_.inorderTraversal(e) } reverseTraversal(e) { return this.root_.reverseTraversal(e) } getIterator(e) { return new nW(this.root_, null, this.comparator_, !1, e) } getIteratorFrom(e, t) { return new nW(this.root_, e, this.comparator_, !1, t) } getReverseIteratorFrom(e, t) { return new nW(this.root_, e, this.comparator_, !0, t) } getReverseIterator(e) { return new nW(this.root_, null, this.comparator_, !0, e) } } function nH(e, t) { return tK(e.name, t.name) } function n$(e, t) { return tK(e, t) } nB.EMPTY_NODE = new nV; let nG = function (e) { return "number" == typeof e ? "number:" + t0(e) : "string:" + e }, nK = function (e) { if (e.isLeafNode()) { let t = e.val(); w("string" == typeof t || "number" == typeof t || "object" == typeof t && ee(t, ".sv"), "Priority must be a string or number.") } else w(e === o || e.isEmpty(), "priority of unexpected type."); w(e === o || e.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.") }; class nY { constructor(e, t = nY.__childrenNodeConstructor.EMPTY_NODE) { this.value_ = e, this.priorityNode_ = t, this.lazyHash_ = null, w(void 0 !== this.value_ && null !== this.value_, "LeafNode shouldn't be created with null/undefined value."), nK(this.priorityNode_) } static set __childrenNodeConstructor(e) { a = e } static get __childrenNodeConstructor() { return a } isLeafNode() { return !0 } getPriority() { return this.priorityNode_ } updatePriority(e) { return new nY(this.value_, e) } getImmediateChild(e) { return ".priority" === e ? this.priorityNode_ : nY.__childrenNodeConstructor.EMPTY_NODE } getChild(e) { return nS(e) ? this : ".priority" === nw(e) ? this.priorityNode_ : nY.__childrenNodeConstructor.EMPTY_NODE } hasChild() { return !1 } getPredecessorChildName(e, t) { return null } updateImmediateChild(e, t) { return ".priority" === e ? this.updatePriority(t) : t.isEmpty() && ".priority" !== e ? this : nY.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e, t).updatePriority(this.priorityNode_) } updateChild(e, t) { let n = nw(e); return null === n ? t : t.isEmpty() && ".priority" !== n ? this : (w(".priority" !== n || 1 === nb(e), ".priority must be the last token in a path"), this.updateImmediateChild(n, nY.__childrenNodeConstructor.EMPTY_NODE.updateChild(nI(e), t))) } isEmpty() { return !1 } numChildren() { return 0 } forEachChild(e, t) { return !1 } val(e) { return e && !this.getPriority().isEmpty() ? { ".value": this.getValue(), ".priority": this.getPriority().val() } : this.getValue() } hash() { if (null === this.lazyHash_) { let e = ""; this.priorityNode_.isEmpty() || (e += "priority:" + nG(this.priorityNode_.val()) + ":"); let t = typeof this.value_; e += t + ":", "number" === t ? e += t0(this.value_) : e += this.value_, this.lazyHash_ = tO(e) } return this.lazyHash_ } getValue() { return this.value_ } compareTo(e) { return e === nY.__childrenNodeConstructor.EMPTY_NODE ? 1 : e instanceof nY.__childrenNodeConstructor ? -1 : (w(e.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(e)) } compareToLeafNode_(e) { let t = typeof e.value_, n = typeof this.value_, i = nY.VALUE_TYPE_ORDER.indexOf(t), r = nY.VALUE_TYPE_ORDER.indexOf(n); return (w(i >= 0, "Unknown leaf type: " + t), w(r >= 0, "Unknown leaf type: " + n), i !== r) ? r - i : "object" === n ? 0 : this.value_ < e.value_ ? -1 : 1 * (this.value_ !== e.value_) } withIndex() { return this } isIndexed() { return !0 } equals(e) { return e === this || !!e.isLeafNode() && this.value_ === e.value_ && this.priorityNode_.equals(e.priorityNode_) } } nY.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"]; class nJ extends nF { compare(e, t) { let n = e.node.getPriority(), i = t.node.getPriority(), r = n.compareTo(i); return 0 === r ? tK(e.name, t.name) : r } isDefinedOn(e) { return !e.getPriority().isEmpty() } indexedValueChanged(e, t) { return !e.getPriority().equals(t.getPriority()) } minPost() { return nj.MIN } maxPost() { return new nj(tG, new nY("[PRIORITY-POST]", h)) } makePost(e, t) { return new nj(t, new nY("[PRIORITY-POST]", l(e))) } toString() { return ".priority" } } let nQ = new nJ, nX = Math.log(2); class nZ { constructor(e) { this.count = parseInt(Math.log(e + 1) / nX, 10), this.current_ = this.count - 1; let t = parseInt(Array(this.count + 1).join("1"), 2); this.bits_ = e + 1 & t } nextBitIsOne() { let e = !(this.bits_ & 1 << this.current_); return this.current_--, e } } let n0 = function (e, t, n, i) { e.sort(t); let r = function (t, i) { let s, o, a = i - t; if (0 === a) return null; if (1 === a) return s = e[t], new nz(n ? n(s) : s, s.node, nz.BLACK, null, null); { let o = parseInt(a / 2, 10) + t, l = r(t, o), h = r(o + 1, i); return s = e[o], new nz(n ? n(s) : s, s.node, nz.BLACK, l, h) } }; return new nB(i || t, function (t) { let i = null, s = null, o = e.length, a = function (t, i) { let s = o - t, a = o; o -= t; let h = r(s + 1, a), c = e[s]; l(new nz(n ? n(c) : c, c.node, i, null, h)) }, l = function (e) { i ? i.left = e : s = e, i = e }; for (let e = 0; e < t.count; ++e) { let n = t.nextBitIsOne(), i = Math.pow(2, t.count - (e + 1)); n ? a(i, nz.BLACK) : (a(i, nz.BLACK), a(i, nz.RED)) } return s }(new nZ(e.length))) }, n1 = {}; class n2 { constructor(e, t) { this.indexes_ = e, this.indexSet_ = t } static get Default() { return w(n1 && nQ, "ChildrenNode.ts has not been loaded"), c = c || new n2({ ".priority": n1 }, { ".priority": nQ }) } get(e) { let t = et(this.indexes_, e); if (!t) throw Error("No index defined for " + e); return t instanceof nB ? t : null } hasIndex(e) { return ee(this.indexSet_, e.toString()) } addIndex(e, t) { let n; w(e !== nq, "KeyIndex always exists and isn't meant to be added to the IndexMap."); let i = [], r = !1, s = t.getIterator(nj.Wrap), o = s.getNext(); for (; o;)r = r || e.isDefinedOn(o.node), i.push(o), o = s.getNext(); n = r ? n0(i, e.getCompare()) : n1; let a = e.toString(), l = Object.assign({}, this.indexSet_); l[a] = e; let h = Object.assign({}, this.indexes_); return h[a] = n, new n2(h, l) } addToIndexes(e, t) { return new n2(ei(this.indexes_, (n, i) => { let r = et(this.indexSet_, i); if (w(r, "Missing index implementation for " + i), n === n1) if (!r.isDefinedOn(e.node)) return n1; else { let n = [], i = t.getIterator(nj.Wrap), s = i.getNext(); for (; s;)s.name !== e.name && n.push(s), s = i.getNext(); return n.push(e), n0(n, r.getCompare()) } { let i = t.get(e.name), r = n; return i && (r = r.remove(new nj(e.name, i))), r.insert(e, e.node) } }), this.indexSet_) } removeFromIndexes(e, t) { return new n2(ei(this.indexes_, n => { if (n === n1) return n; { let i = t.get(e.name); return i ? n.remove(new nj(e.name, i)) : n } }), this.indexSet_) } } class n3 { constructor(e, t, n) { this.children_ = e, this.priorityNode_ = t, this.indexMap_ = n, this.lazyHash_ = null, this.priorityNode_ && nK(this.priorityNode_), this.children_.isEmpty() && w(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority") } static get EMPTY_NODE() { return u || (u = new n3(new nB(n$), null, n2.Default)) } isLeafNode() { return !1 } getPriority() { return this.priorityNode_ || u } updatePriority(e) { return this.children_.isEmpty() ? this : new n3(this.children_, e, this.indexMap_) } getImmediateChild(e) { if (".priority" === e) return this.getPriority(); { let t = this.children_.get(e); return null === t ? u : t } } getChild(e) { let t = nw(e); return null === t ? this : this.getImmediateChild(t).getChild(nI(e)) } hasChild(e) { return null !== this.children_.get(e) } updateImmediateChild(e, t) { if (w(t, "We should always be passing snapshot nodes"), ".priority" === e) return this.updatePriority(t); { let n, i, r = new nj(e, t); t.isEmpty() ? (n = this.children_.remove(e), i = this.indexMap_.removeFromIndexes(r, this.children_)) : (n = this.children_.insert(e, t), i = this.indexMap_.addToIndexes(r, this.children_)); let s = n.isEmpty() ? u : this.priorityNode_; return new n3(n, s, i) } } updateChild(e, t) { let n = nw(e); if (null === n) return t; { w(".priority" !== nw(e) || 1 === nb(e), ".priority must be the last token in a path"); let i = this.getImmediateChild(n).updateChild(nI(e), t); return this.updateImmediateChild(n, i) } } isEmpty() { return this.children_.isEmpty() } numChildren() { return this.children_.count() } val(e) { if (this.isEmpty()) return null; let t = {}, n = 0, i = 0, r = !0; if (this.forEachChild(nQ, (s, o) => { t[s] = o.val(e), n++, r && n3.INTEGER_REGEXP_.test(s) ? i = Math.max(i, Number(s)) : r = !1 }), e || !r || !(i < 2 * n)) return e && !this.getPriority().isEmpty() && (t[".priority"] = this.getPriority().val()), t; { let e = []; for (let n in t) e[n] = t[n]; return e } } hash() { if (null === this.lazyHash_) { let e = ""; this.getPriority().isEmpty() || (e += "priority:" + nG(this.getPriority().val()) + ":"), this.forEachChild(nQ, (t, n) => { let i = n.hash(); "" !== i && (e += ":" + t + ":" + i) }), this.lazyHash_ = "" === e ? "" : tO(e) } return this.lazyHash_ } getPredecessorChildName(e, t, n) { let i = this.resolveIndex_(n); if (!i) return this.children_.getPredecessorKey(e); { let n = i.getPredecessorKey(new nj(e, t)); return n ? n.name : null } } getFirstChildName(e) { let t = this.resolveIndex_(e); if (!t) return this.children_.minKey(); { let e = t.minKey(); return e && e.name } } getFirstChild(e) { let t = this.getFirstChildName(e); return t ? new nj(t, this.children_.get(t)) : null } getLastChildName(e) { let t = this.resolveIndex_(e); if (!t) return this.children_.maxKey(); { let e = t.maxKey(); return e && e.name } } getLastChild(e) { let t = this.getLastChildName(e); return t ? new nj(t, this.children_.get(t)) : null } forEachChild(e, t) { let n = this.resolveIndex_(e); return n ? n.inorderTraversal(e => t(e.name, e.node)) : this.children_.inorderTraversal(t) } getIterator(e) { return this.getIteratorFrom(e.minPost(), e) } getIteratorFrom(e, t) { let n = this.resolveIndex_(t); if (n) return n.getIteratorFrom(e, e => e); { let n = this.children_.getIteratorFrom(e.name, nj.Wrap), i = n.peek(); for (; null != i && 0 > t.compare(i, e);)n.getNext(), i = n.peek(); return n } } getReverseIterator(e) { return this.getReverseIteratorFrom(e.maxPost(), e) } getReverseIteratorFrom(e, t) { let n = this.resolveIndex_(t); if (n) return n.getReverseIteratorFrom(e, e => e); { let n = this.children_.getReverseIteratorFrom(e.name, nj.Wrap), i = n.peek(); for (; null != i && t.compare(i, e) > 0;)n.getNext(), i = n.peek(); return n } } compareTo(e) { if (this.isEmpty()) if (e.isEmpty()) return 0; else return -1; return e.isLeafNode() || e.isEmpty() ? 1 : e === n5 ? -1 : 0 } withIndex(e) { if (e === nq || this.indexMap_.hasIndex(e)) return this; { let t = this.indexMap_.addIndex(e, this.children_); return new n3(this.children_, this.priorityNode_, t) } } isIndexed(e) { return e === nq || this.indexMap_.hasIndex(e) } equals(e) { if (e === this) return !0; if (e.isLeafNode() || !this.getPriority().equals(e.getPriority())) return !1; if (this.children_.count() !== e.children_.count()) return !1; { let t = this.getIterator(nQ), n = e.getIterator(nQ), i = t.getNext(), r = n.getNext(); for (; i && r;) { if (i.name !== r.name || !i.node.equals(r.node)) return !1; i = t.getNext(), r = n.getNext() } return null === i && null === r } } resolveIndex_(e) { return e === nq ? null : this.indexMap_.get(e.toString()) } } n3.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/; class n4 extends n3 { constructor() { super(new nB(n$), n3.EMPTY_NODE, n2.Default) } compareTo(e) { return +(e !== this) } equals(e) { return e === this } getPriority() { return this } getImmediateChild(e) { return n3.EMPTY_NODE } isEmpty() { return !1 } } let n5 = new n4; function n6(e, t = null) { if (null === e) return n3.EMPTY_NODE; if ("object" == typeof e && ".priority" in e && (t = e[".priority"]), w(null === t || "string" == typeof t || "number" == typeof t || "object" == typeof t && ".sv" in t, "Invalid priority type found: " + typeof t), "object" == typeof e && ".value" in e && null !== e[".value"] && (e = e[".value"]), "object" != typeof e || ".sv" in e) return new nY(e, n6(t)); if (e instanceof Array) { let n = n3.EMPTY_NODE; return tZ(e, (t, i) => { if (ee(e, t) && "." !== t.substring(0, 1)) { let e = n6(i); (e.isLeafNode() || !e.isEmpty()) && (n = n.updateImmediateChild(t, e)) } }), n.updatePriority(n6(t)) } { let n = [], i = !1; if (tZ(e, (e, t) => { if ("." !== e.substring(0, 1)) { let r = n6(t); r.isEmpty() || (i = i || !r.getPriority().isEmpty(), n.push(new nj(e, r))) } }), 0 === n.length) return n3.EMPTY_NODE; let r = n0(n, nH, e => e.name, n$); if (!i) return new n3(r, n6(t), n2.Default); { let e = n0(n, nQ.getCompare()); return new n3(r, n6(t), new n2({ ".priority": e }, { ".priority": nQ })) } } } Object.defineProperties(nj, { MIN: { value: new nj(t$, n3.EMPTY_NODE) }, MAX: { value: new nj(tG, n5) } }), nU.__EMPTY_NODE = n3.EMPTY_NODE, nY.__childrenNodeConstructor = n3, o = n5, h = n5, l = n6; class n8 extends nF { constructor(e) { super(), this.indexPath_ = e, w(!nS(e) && ".priority" !== nw(e), "Can't create PathIndex with empty path or .priority key") } extractChild(e) { return e.getChild(this.indexPath_) } isDefinedOn(e) { return !e.getChild(this.indexPath_).isEmpty() } compare(e, t) { let n = this.extractChild(e.node), i = this.extractChild(t.node), r = n.compareTo(i); return 0 === r ? tK(e.name, t.name) : r } makePost(e, t) { let n = n6(e); return new nj(t, n3.EMPTY_NODE.updateChild(this.indexPath_, n)) } maxPost() { return new nj(tG, n3.EMPTY_NODE.updateChild(this.indexPath_, n5)) } toString() { return nT(this.indexPath_, 0).join("/") } } class n7 extends nF { compare(e, t) { let n = e.node.compareTo(t.node); return 0 === n ? tK(e.name, t.name) : n } isDefinedOn(e) { return !0 } indexedValueChanged(e, t) { return !e.equals(t) } minPost() { return nj.MIN } maxPost() { return nj.MAX } makePost(e, t) { return new nj(t, n6(e)) } toString() { return ".value" } } let n9 = new n7; function ie(e) { return { type: "value", snapshotNode: e } } function it(e, t) { return { type: "child_added", snapshotNode: t, childName: e } } function ii(e, t) { return { type: "child_removed", snapshotNode: t, childName: e } } function ir(e, t, n) { return { type: "child_changed", snapshotNode: t, childName: e, oldSnap: n } } class is { constructor(e) { this.index_ = e } updateChild(e, t, n, i, r, s) { w(e.isIndexed(this.index_), "A node must be indexed if only a child is updated"); let o = e.getImmediateChild(t); return o.getChild(i).equals(n.getChild(i)) && o.isEmpty() === n.isEmpty() || (null != s && (n.isEmpty() ? e.hasChild(t) ? s.trackChildChange(ii(t, o)) : w(e.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : o.isEmpty() ? s.trackChildChange(it(t, n)) : s.trackChildChange(ir(t, n, o))), e.isLeafNode() && n.isEmpty()) ? e : e.updateImmediateChild(t, n).withIndex(this.index_) } updateFullNode(e, t, n) { return null != n && (e.isLeafNode() || e.forEachChild(nQ, (e, i) => { t.hasChild(e) || n.trackChildChange(ii(e, i)) }), t.isLeafNode() || t.forEachChild(nQ, (t, i) => { if (e.hasChild(t)) { let r = e.getImmediateChild(t); r.equals(i) || n.trackChildChange(ir(t, i, r)) } else n.trackChildChange(it(t, i)) })), t.withIndex(this.index_) } updatePriority(e, t) { return e.isEmpty() ? n3.EMPTY_NODE : e.updatePriority(t) } filtersNodes() { return !1 } getIndexedFilter() { return this } getIndex() { return this.index_ } } class io { constructor(e) { this.indexedFilter_ = new is(e.getIndex()), this.index_ = e.getIndex(), this.startPost_ = io.getStartPost_(e), this.endPost_ = io.getEndPost_(e), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_ } getStartPost() { return this.startPost_ } getEndPost() { return this.endPost_ } matches(e) { let t = this.startIsInclusive_ ? 0 >= this.index_.compare(this.getStartPost(), e) : 0 > this.index_.compare(this.getStartPost(), e), n = this.endIsInclusive_ ? 0 >= this.index_.compare(e, this.getEndPost()) : 0 > this.index_.compare(e, this.getEndPost()); return t && n } updateChild(e, t, n, i, r, s) { return this.matches(new nj(t, n)) || (n = n3.EMPTY_NODE), this.indexedFilter_.updateChild(e, t, n, i, r, s) } updateFullNode(e, t, n) { t.isLeafNode() && (t = n3.EMPTY_NODE); let i = t.withIndex(this.index_); i = i.updatePriority(n3.EMPTY_NODE); let r = this; return t.forEachChild(nQ, (e, t) => { r.matches(new nj(e, t)) || (i = i.updateImmediateChild(e, n3.EMPTY_NODE)) }), this.indexedFilter_.updateFullNode(e, i, n) } updatePriority(e, t) { return e } filtersNodes() { return !0 } getIndexedFilter() { return this.indexedFilter_ } getIndex() { return this.index_ } static getStartPost_(e) { if (!e.hasStart()) return e.getIndex().minPost(); { let t = e.getIndexStartName(); return e.getIndex().makePost(e.getIndexStartValue(), t) } } static getEndPost_(e) { if (!e.hasEnd()) return e.getIndex().maxPost(); { let t = e.getIndexEndName(); return e.getIndex().makePost(e.getIndexEndValue(), t) } } } class ia { constructor(e) { this.withinDirectionalStart = e => this.reverse_ ? this.withinEndPost(e) : this.withinStartPost(e), this.withinDirectionalEnd = e => this.reverse_ ? this.withinStartPost(e) : this.withinEndPost(e), this.withinStartPost = e => { let t = this.index_.compare(this.rangedFilter_.getStartPost(), e); return this.startIsInclusive_ ? t <= 0 : t < 0 }, this.withinEndPost = e => { let t = this.index_.compare(e, this.rangedFilter_.getEndPost()); return this.endIsInclusive_ ? t <= 0 : t < 0 }, this.rangedFilter_ = new io(e), this.index_ = e.getIndex(), this.limit_ = e.getLimit(), this.reverse_ = !e.isViewFromLeft(), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_ } updateChild(e, t, n, i, r, s) { return (this.rangedFilter_.matches(new nj(t, n)) || (n = n3.EMPTY_NODE), e.getImmediateChild(t).equals(n)) ? e : e.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(e, t, n, i, r, s) : this.fullLimitUpdateChild_(e, t, n, r, s) } updateFullNode(e, t, n) { let i; if (t.isLeafNode() || t.isEmpty()) i = n3.EMPTY_NODE.withIndex(this.index_); else if (2 * this.limit_ < t.numChildren() && t.isIndexed(this.index_)) { let e; i = n3.EMPTY_NODE.withIndex(this.index_), e = this.reverse_ ? t.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : t.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_); let n = 0; for (; e.hasNext() && n < this.limit_;) { let t = e.getNext(); if (this.withinDirectionalStart(t)) if (this.withinDirectionalEnd(t)) i = i.updateImmediateChild(t.name, t.node), n++; else break } } else { let e; i = (i = t.withIndex(this.index_)).updatePriority(n3.EMPTY_NODE), e = this.reverse_ ? i.getReverseIterator(this.index_) : i.getIterator(this.index_); let n = 0; for (; e.hasNext();) { let t = e.getNext(); n < this.limit_ && this.withinDirectionalStart(t) && this.withinDirectionalEnd(t) ? n++ : i = i.updateImmediateChild(t.name, n3.EMPTY_NODE) } } return this.rangedFilter_.getIndexedFilter().updateFullNode(e, i, n) } updatePriority(e, t) { return e } filtersNodes() { return !0 } getIndexedFilter() { return this.rangedFilter_.getIndexedFilter() } getIndex() { return this.index_ } fullLimitUpdateChild_(e, t, n, i, r) { let s; if (this.reverse_) { let e = this.index_.getCompare(); s = (t, n) => e(n, t) } else s = this.index_.getCompare(); w(e.numChildren() === this.limit_, ""); let o = new nj(t, n), a = this.reverse_ ? e.getFirstChild(this.index_) : e.getLastChild(this.index_), l = this.rangedFilter_.matches(o); if (e.hasChild(t)) { let h = e.getImmediateChild(t), c = i.getChildAfterChild(this.index_, a, this.reverse_); for (; null != c && (c.name === t || e.hasChild(c.name));)c = i.getChildAfterChild(this.index_, c, this.reverse_); let u = null == c ? 1 : s(c, o); if (l && !n.isEmpty() && u >= 0) return null != r && r.trackChildChange(ir(t, n, h)), e.updateImmediateChild(t, n); { null != r && r.trackChildChange(ii(t, h)); let n = e.updateImmediateChild(t, n3.EMPTY_NODE); return null != c && this.rangedFilter_.matches(c) ? (null != r && r.trackChildChange(it(c.name, c.node)), n.updateImmediateChild(c.name, c.node)) : n } } return n.isEmpty() ? e : l ? s(a, o) >= 0 ? (null != r && (r.trackChildChange(ii(a.name, a.node)), r.trackChildChange(it(t, n))), e.updateImmediateChild(t, n).updateImmediateChild(a.name, n3.EMPTY_NODE)) : e : e } } class il { constructor() { this.limitSet_ = !1, this.startSet_ = !1, this.startNameSet_ = !1, this.startAfterSet_ = !1, this.endSet_ = !1, this.endNameSet_ = !1, this.endBeforeSet_ = !1, this.limit_ = 0, this.viewFrom_ = "", this.indexStartValue_ = null, this.indexStartName_ = "", this.indexEndValue_ = null, this.indexEndName_ = "", this.index_ = nQ } hasStart() { return this.startSet_ } isViewFromLeft() { return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_ } getIndexStartValue() { return w(this.startSet_, "Only valid if start has been set"), this.indexStartValue_ } getIndexStartName() { return (w(this.startSet_, "Only valid if start has been set"), this.startNameSet_) ? this.indexStartName_ : t$ } hasEnd() { return this.endSet_ } getIndexEndValue() { return w(this.endSet_, "Only valid if end has been set"), this.indexEndValue_ } getIndexEndName() { return (w(this.endSet_, "Only valid if end has been set"), this.endNameSet_) ? this.indexEndName_ : tG } hasLimit() { return this.limitSet_ } hasAnchoredLimit() { return this.limitSet_ && "" !== this.viewFrom_ } getLimit() { return w(this.limitSet_, "Only valid if limit has been set"), this.limit_ } getIndex() { return this.index_ } loadsAllData() { return !(this.startSet_ || this.endSet_ || this.limitSet_) } isDefault() { return this.loadsAllData() && this.index_ === nQ } copy() { let e = new il; return e.limitSet_ = this.limitSet_, e.limit_ = this.limit_, e.startSet_ = this.startSet_, e.startAfterSet_ = this.startAfterSet_, e.indexStartValue_ = this.indexStartValue_, e.startNameSet_ = this.startNameSet_, e.indexStartName_ = this.indexStartName_, e.endSet_ = this.endSet_, e.endBeforeSet_ = this.endBeforeSet_, e.indexEndValue_ = this.indexEndValue_, e.endNameSet_ = this.endNameSet_, e.indexEndName_ = this.indexEndName_, e.index_ = this.index_, e.viewFrom_ = this.viewFrom_, e } } function ih(e, t, n) { let i = e.copy(); return i.startSet_ = !0, void 0 === t && (t = null), i.indexStartValue_ = t, null != n ? (i.startNameSet_ = !0, i.indexStartName_ = n) : (i.startNameSet_ = !1, i.indexStartName_ = ""), i } function ic(e, t, n) { let i = e.copy(); return i.endSet_ = !0, void 0 === t && (t = null), i.indexEndValue_ = t, void 0 !== n ? (i.endNameSet_ = !0, i.indexEndName_ = n) : (i.endNameSet_ = !1, i.indexEndName_ = ""), i } function iu(e, t) { let n = e.copy(); return n.index_ = t, n } function id(e) { let t, n = {}; if (e.isDefault()) return n; if (e.index_ === nQ ? t = "$priority" : e.index_ === n9 ? t = "$value" : e.index_ === nq ? t = "$key" : (w(e.index_ instanceof n8, "Unrecognized index type!"), t = e.index_.toString()), n.orderBy = J(t), e.startSet_) { let t = e.startAfterSet_ ? "startAfter" : "startAt"; n[t] = J(e.indexStartValue_), e.startNameSet_ && (n[t] += "," + J(e.indexStartName_)) } if (e.endSet_) { let t = e.endBeforeSet_ ? "endBefore" : "endAt"; n[t] = J(e.indexEndValue_), e.endNameSet_ && (n[t] += "," + J(e.indexEndName_)) } return e.limitSet_ && (e.isViewFromLeft() ? n.limitToFirst = e.limit_ : n.limitToLast = e.limit_), n } function ip(e) { let t = {}; if (e.startSet_ && (t.sp = e.indexStartValue_, e.startNameSet_ && (t.sn = e.indexStartName_), t.sin = !e.startAfterSet_), e.endSet_ && (t.ep = e.indexEndValue_, e.endNameSet_ && (t.en = e.indexEndName_), t.ein = !e.endBeforeSet_), e.limitSet_) { t.l = e.limit_; let n = e.viewFrom_; "" === n && (n = e.isViewFromLeft() ? "l" : "r"), t.vf = n } return e.index_ !== nQ && (t.i = e.index_.toString()), t } class im extends nm { constructor(e, t, n, i) { super(), this.repoInfo_ = e, this.onDataUpdate_ = t, this.authTokenProvider_ = n, this.appCheckTokenProvider_ = i, this.log_ = tU("p:rest:"), this.listens_ = {} } reportStats(e) { throw Error("Method not implemented.") } static getListenId_(e, t) { return void 0 !== t ? "tag$" + t : (w(e._queryParams.isDefault(), "should have a tag if it's not a default query."), e._path.toString()) } listen(e, t, n, i) { let r = e._path.toString(); this.log_("Listen called for " + r + " " + e._queryIdentifier); let s = im.getListenId_(e, n), o = {}; this.listens_[s] = o; let a = id(e._queryParams); this.restRequest_(r + ".json", a, (e, t) => { let a = t; if (404 === e && (a = null, e = null), null === e && this.onDataUpdate_(r, a, !1, n), et(this.listens_, s) === o) { let t; i(e ? 401 === e ? "permission_denied" : "rest_error:" + e : "ok", null) } }) } unlisten(e, t) { let n = im.getListenId_(e, t); delete this.listens_[n] } get(e) { let t = id(e._queryParams), n = e._path.toString(), i = new M; return this.restRequest_(n + ".json", t, (e, t) => { let r = t; 404 === e && (r = null, e = null), null === e ? (this.onDataUpdate_(n, r, !1, null), i.resolve(r)) : i.reject(Error(r)) }), i.promise } refreshAuthToken(e) { } restRequest_(e, t = {}, n) { return t.format = "export", Promise.all([this.authTokenProvider_.getToken(!1), this.appCheckTokenProvider_.getToken(!1)]).then(([i, r]) => { i && i.accessToken && (t.auth = i.accessToken), r && r.token && (t.ac = r.token); let s = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + e + "?ns=" + this.repoInfo_.namespace + eo(t); this.log_("Sending REST request for " + s); let o = new XMLHttpRequest; o.onreadystatechange = () => { if (n && 4 === o.readyState) { this.log_("REST Response for " + s + " received. status:", o.status, "response:", o.responseText); let e = null; if (o.status >= 200 && o.status < 300) { try { e = Y(o.responseText) } catch (e) { tz("Failed to parse JSON response for " + s + ": " + o.responseText) } n(null, e) } else 401 !== o.status && 404 !== o.status && tz("Got unsuccessful REST response for " + s + " Status: " + o.status), n(o.status); n = null } }, o.open("GET", s, !0), o.send() }) } } class ig { constructor() { this.rootNode_ = n3.EMPTY_NODE } getNode(e) { return this.rootNode_.getChild(e) } updateSnapshot(e, t) { this.rootNode_ = this.rootNode_.updateChild(e, t) } } function i_() { return { value: null, children: new Map } } function iv(e, t, n) { if (nS(t)) e.value = n, e.children.clear(); else if (null !== e.value) e.value = e.value.updateChild(t, n); else { let i = nw(t); e.children.has(i) || e.children.set(i, i_()), iv(e.children.get(i), t = nI(t), n) } } function iy(e, t, n) { var i, r; null !== e.value ? n(t, e.value) : (i = e, r = (e, i) => { iy(i, new nv(t.toString() + "/" + e), n) }, i.children.forEach((e, t) => { r(t, e) })) } class iw { constructor(e) { this.collection_ = e, this.last_ = null } get() { let e = this.collection_.get(), t = Object.assign({}, e); return this.last_ && tZ(this.last_, (e, n) => { t[e] = t[e] - n }), this.last_ = e, t } } class ib { constructor(e, t) { this.server_ = t, this.statsToReport_ = {}, this.statsListener_ = new iw(e); let n = 1e4 + 2e4 * Math.random(); t4(this.reportStats_.bind(this), Math.floor(n)) } reportStats_() { let e = this.statsListener_.get(), t = {}, n = !1; tZ(e, (e, i) => { i > 0 && ee(this.statsToReport_, e) && (t[e] = i, n = !0) }), n && this.server_.reportStats(t), t4(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5)) } } function iI() { return { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 } } function iC() { return { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 } } function iT(e) { return { fromUser: !1, fromServer: !0, queryId: e, tagged: !0 } } !function (e) { e[e.OVERWRITE = 0] = "OVERWRITE", e[e.MERGE = 1] = "MERGE", e[e.ACK_USER_WRITE = 2] = "ACK_USER_WRITE", e[e.LISTEN_COMPLETE = 3] = "LISTEN_COMPLETE" }(g || (g = {})); class ik { constructor(e, t, n) { this.path = e, this.affectedTree = t, this.revert = n, this.type = g.ACK_USER_WRITE, this.source = iI() } operationForChild(e) { if (!nS(this.path)) return w(nw(this.path) === e, "operationForChild called for unrelated child."), new ik(nI(this.path), this.affectedTree, this.revert); if (null != this.affectedTree.value) return w(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths."), this; { let t = this.affectedTree.subtree(new nv(e)); return new ik(ny(), t, this.revert) } } } class iE { constructor(e, t) { this.source = e, this.path = t, this.type = g.LISTEN_COMPLETE } operationForChild(e) { return nS(this.path) ? new iE(this.source, ny()) : new iE(this.source, nI(this.path)) } } class iS { constructor(e, t, n) { this.source = e, this.path = t, this.snap = n, this.type = g.OVERWRITE } operationForChild(e) { return nS(this.path) ? new iS(this.source, ny(), this.snap.getImmediateChild(e)) : new iS(this.source, nI(this.path), this.snap) } } class iP { constructor(e, t, n) { this.source = e, this.path = t, this.children = n, this.type = g.MERGE } operationForChild(e) { if (!nS(this.path)) return w(nw(this.path) === e, "Can't get a merge for a child not on the path of the operation"), new iP(this.source, nI(this.path), this.children); { let t = this.children.subtree(new nv(e)); return t.isEmpty() ? null : t.value ? new iS(this.source, ny(), t.value) : new iP(this.source, ny(), t) } } toString() { return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")" } } class iN { constructor(e, t, n) { this.node_ = e, this.fullyInitialized_ = t, this.filtered_ = n } isFullyInitialized() { return this.fullyInitialized_ } isFiltered() { return this.filtered_ } isCompleteForPath(e) { if (nS(e)) return this.isFullyInitialized() && !this.filtered_; let t = nw(e); return this.isCompleteForChild(t) } isCompleteForChild(e) { return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(e) } getNode() { return this.node_ } } class iR { constructor(e) { this.query_ = e, this.index_ = this.query_._queryParams.getIndex() } } function ix(e, t, n, i, r, s) { let o = i.filter(e => e.type === n); o.sort((t, n) => (function (e, t, n) { if (null == t.childName || null == n.childName) throw b("Should only compare child_ events."); let i = new nj(t.childName, t.snapshotNode), r = new nj(n.childName, n.snapshotNode); return e.index_.compare(i, r) })(e, t, n)), o.forEach(n => { var i, o, a; let l = (i = e, o = n, a = s, "value" === o.type || "child_removed" === o.type || (o.prevName = a.getPredecessorChildName(o.childName, o.snapshotNode, i.index_)), o); r.forEach(i => { i.respondsTo(n.type) && t.push(i.createEvent(l, e.query_)) }) }) } function iA(e, t) { return { eventCache: e, serverCache: t } } function iO(e, t, n, i) { return iA(new iN(t, n, i), e.serverCache) } function iD(e, t, n, i) { return iA(e.eventCache, new iN(t, n, i)) } function iL(e) { return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null } function iM(e) { return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null } let ij = () => (d || (d = new nB(tY)), d); class iF { constructor(e, t = ij()) { this.value = e, this.children = t } static fromObject(e) { let t = new iF(null); return tZ(e, (e, n) => { t = t.set(new nv(e), n) }), t } isEmpty() { return null === this.value && this.children.isEmpty() } findRootMostMatchingPathAndValue(e, t) { if (null != this.value && t(this.value)) return { path: ny(), value: this.value }; { if (nS(e)) return null; let n = nw(e), i = this.children.get(n); if (null === i) return null; { let r = i.findRootMostMatchingPathAndValue(nI(e), t); return null != r ? { path: nE(new nv(n), r.path), value: r.value } : null } } } findRootMostValueAndPath(e) { return this.findRootMostMatchingPathAndValue(e, () => !0) } subtree(e) { if (nS(e)) return this; { let t = nw(e), n = this.children.get(t); return null !== n ? n.subtree(nI(e)) : new iF(null) } } set(e, t) { if (nS(e)) return new iF(t, this.children); { let n = nw(e), i = (this.children.get(n) || new iF(null)).set(nI(e), t), r = this.children.insert(n, i); return new iF(this.value, r) } } remove(e) { if (nS(e)) if (this.children.isEmpty()) return new iF(null); else return new iF(null, this.children); { let t = nw(e), n = this.children.get(t); if (!n) return this; { let i, r = n.remove(nI(e)); return (i = r.isEmpty() ? this.children.remove(t) : this.children.insert(t, r), null === this.value && i.isEmpty()) ? new iF(null) : new iF(this.value, i) } } } get(e) { if (nS(e)) return this.value; { let t = nw(e), n = this.children.get(t); return n ? n.get(nI(e)) : null } } setTree(e, t) { if (nS(e)) return t; { let n, i = nw(e), r = (this.children.get(i) || new iF(null)).setTree(nI(e), t); return n = r.isEmpty() ? this.children.remove(i) : this.children.insert(i, r), new iF(this.value, n) } } fold(e) { return this.fold_(ny(), e) } fold_(e, t) { let n = {}; return this.children.inorderTraversal((i, r) => { n[i] = r.fold_(nE(e, i), t) }), t(e, this.value, n) } findOnPath(e, t) { return this.findOnPath_(e, ny(), t) } findOnPath_(e, t, n) { let i = !!this.value && n(t, this.value); if (i) return i; { if (nS(e)) return null; let i = nw(e), r = this.children.get(i); return r ? r.findOnPath_(nI(e), nE(t, i), n) : null } } foreachOnPath(e, t) { return this.foreachOnPath_(e, ny(), t) } foreachOnPath_(e, t, n) { if (nS(e)) return this; { this.value && n(t, this.value); let i = nw(e), r = this.children.get(i); return r ? r.foreachOnPath_(nI(e), nE(t, i), n) : new iF(null) } } foreach(e) { this.foreach_(ny(), e) } foreach_(e, t) { this.children.inorderTraversal((n, i) => { i.foreach_(nE(e, n), t) }), this.value && t(e, this.value) } foreachChild(e) { this.children.inorderTraversal((t, n) => { n.value && e(t, n.value) }) } } class iU { constructor(e) { this.writeTree_ = e } static empty() { return new iU(new iF(null)) } } function iq(e, t, n) { if (nS(t)) return new iU(new iF(n)); { let i = e.writeTree_.findRootMostValueAndPath(t); if (null != i) { let r = i.path, s = i.value, o = nP(r, t); return s = s.updateChild(o, n), new iU(e.writeTree_.set(r, s)) } { let i = new iF(n); return new iU(e.writeTree_.setTree(t, i)) } } } function iW(e, t, n) { let i = e; return tZ(n, (e, n) => { i = iq(i, nE(t, e), n) }), i } function iz(e, t) { return nS(t) ? iU.empty() : new iU(e.writeTree_.setTree(t, new iF(null))) } function iV(e, t) { return null != iB(e, t) } function iB(e, t) { let n = e.writeTree_.findRootMostValueAndPath(t); return null != n ? e.writeTree_.get(n.path).getChild(nP(n.path, t)) : null } function iH(e) { let t = [], n = e.writeTree_.value; return null != n ? n.isLeafNode() || n.forEachChild(nQ, (e, n) => { t.push(new nj(e, n)) }) : e.writeTree_.children.inorderTraversal((e, n) => { null != n.value && t.push(new nj(e, n.value)) }), t } function i$(e, t) { if (nS(t)) return e; { let n = iB(e, t); return new iU(null != n ? new iF(n) : e.writeTree_.subtree(t)) } } function iG(e) { return e.writeTree_.isEmpty() } function iK(e, t) { return function e(t, n, i) { if (null != n.value) return i.updateChild(t, n.value); { let r = null; return n.children.inorderTraversal((n, s) => { ".priority" === n ? (w(null !== s.value, "Priority writes must always be leaf nodes"), r = s.value) : i = e(nE(t, n), s, i) }), i.getChild(t).isEmpty() || null === r || (i = i.updateChild(nE(t, ".priority"), r)), i } }(ny(), e.writeTree_, t) } function iY(e) { return e.visible } function iJ(e, t, n) { let i = iU.empty(); for (let r = 0; r < e.length; ++r) { let s = e[r]; if (t(s)) { let e, t = s.path; if (s.snap) nx(n, t) ? i = iq(i, e = nP(n, t), s.snap) : nx(t, n) && (e = nP(t, n), i = iq(i, ny(), s.snap.getChild(e))); else if (s.children) { if (nx(n, t)) i = iW(i, e = nP(n, t), s.children); else if (nx(t, n)) if (nS(e = nP(t, n))) i = iW(i, ny(), s.children); else { let t = et(s.children, nw(e)); if (t) { let n = t.getChild(nI(e)); i = iq(i, ny(), n) } } } else throw b("WriteRecord should have .snap or .children") } } return i } function iQ(e, t, n, i, r) { if (i || r) { let s = i$(e.visibleWrites, t); return !r && iG(s) ? n : r || null != n || iV(s, ny()) ? iK(iJ(e.allWrites, function (e) { return (e.visible || r) && (!i || !~i.indexOf(e.writeId)) && (nx(e.path, t) || nx(t, e.path)) }, t), n || n3.EMPTY_NODE) : null } { let i = iB(e.visibleWrites, t); if (null != i) return i; { let i = i$(e.visibleWrites, t); return iG(i) ? n : null != n || iV(i, ny()) ? iK(i, n || n3.EMPTY_NODE) : null } } } function iX(e, t, n, i) { return iQ(e.writeTree, e.treePath, t, n, i) } function iZ(e, t) { return function (e, t, n) { let i = n3.EMPTY_NODE, r = iB(e.visibleWrites, t); if (r) return r.isLeafNode() || r.forEachChild(nQ, (e, t) => { i = i.updateImmediateChild(e, t) }), i; if (!n) return iH(i$(e.visibleWrites, t)).forEach(e => { i = i.updateImmediateChild(e.name, e.node) }), i; { let r = i$(e.visibleWrites, t); return n.forEachChild(nQ, (e, t) => { let n = iK(i$(r, new nv(e)), t); i = i.updateImmediateChild(e, n) }), iH(r).forEach(e => { i = i.updateImmediateChild(e.name, e.node) }), i } }(e.writeTree, e.treePath, t) } function i0(e, t, n, i) { return function (e, t, n, i, r) { w(i || r, "Either existingEventSnap or existingServerSnap must exist"); let s = nE(t, n); if (iV(e.visibleWrites, s)) return null; { let t = i$(e.visibleWrites, s); return iG(t) ? r.getChild(n) : iK(t, r.getChild(n)) } }(e.writeTree, e.treePath, t, n, i) } function i1(e, t) { var n, i; return n = e.writeTree, i = nE(e.treePath, t), iB(n.visibleWrites, i) } function i2(e, t, n) { return function (e, t, n, i) { let r = nE(t, n), s = iB(e.visibleWrites, r); return null != s ? s : i.isCompleteForChild(n) ? iK(i$(e.visibleWrites, r), i.getNode().getImmediateChild(n)) : null }(e.writeTree, e.treePath, t, n) } function i3(e, t) { return i4(nE(e.treePath, t), e.writeTree) } function i4(e, t) { return { treePath: e, writeTree: t } } class i5 { constructor() { this.changeMap = new Map } trackChildChange(e) { let t = e.type, n = e.childName; w("child_added" === t || "child_changed" === t || "child_removed" === t, "Only child changes supported for tracking"), w(".priority" !== n, "Only non-priority child changes can be tracked."); let i = this.changeMap.get(n); if (i) { let r = i.type; if ("child_added" === t && "child_removed" === r) this.changeMap.set(n, ir(n, e.snapshotNode, i.snapshotNode)); else if ("child_removed" === t && "child_added" === r) this.changeMap.delete(n); else if ("child_removed" === t && "child_changed" === r) this.changeMap.set(n, ii(n, i.oldSnap)); else if ("child_changed" === t && "child_added" === r) this.changeMap.set(n, it(n, e.snapshotNode)); else if ("child_changed" === t && "child_changed" === r) this.changeMap.set(n, ir(n, e.snapshotNode, i.oldSnap)); else throw b("Illegal combination of changes: " + e + " occurred after " + i) } else this.changeMap.set(n, e) } getChanges() { return Array.from(this.changeMap.values()) } } class i6 { getCompleteChild(e) { return null } getChildAfterChild(e, t, n) { return null } } let i8 = new i6; class i7 { constructor(e, t, n = null) { this.writes_ = e, this.viewCache_ = t, this.optCompleteServerCache_ = n } getCompleteChild(e) { let t = this.viewCache_.eventCache; if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e); { let t = null != this.optCompleteServerCache_ ? new iN(this.optCompleteServerCache_, !0, !1) : this.viewCache_.serverCache; return i2(this.writes_, e, t) } } getChildAfterChild(e, t, n) { var i; let r = null != this.optCompleteServerCache_ ? this.optCompleteServerCache_ : iM(this.viewCache_), s = (i = this.writes_, function (e, t, n, i, r, s, o) { let a, l = i$(e.visibleWrites, t), h = iB(l, ny()); if (null != h) a = h; else { if (null == n) return []; a = iK(l, n) } if ((a = a.withIndex(o)).isEmpty() || a.isLeafNode()) return []; { let e = [], t = o.getCompare(), n = s ? a.getReverseIteratorFrom(i, o) : a.getIteratorFrom(i, o), r = n.getNext(); for (; r && e.length < 1;)0 !== t(r, i) && e.push(r), r = n.getNext(); return e } }(i.writeTree, i.treePath, r, t, 1, n, e)); return 0 === s.length ? null : s[0] } } function i9(e, t, n, i, r, s) { let o = t.eventCache; if (null != i1(i, n)) return t; { let a, l; if (nS(n)) if (w(t.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data"), t.serverCache.isFiltered()) { let n = iM(t), r = iZ(i, n instanceof n3 ? n : n3.EMPTY_NODE); a = e.filter.updateFullNode(t.eventCache.getNode(), r, s) } else { let n = iX(i, iM(t)); a = e.filter.updateFullNode(t.eventCache.getNode(), n, s) } else { let h = nw(n); if (".priority" === h) { w(1 === nb(n), "Can't have a priority with additional path components"); let r = o.getNode(), s = i0(i, n, r, l = t.serverCache.getNode()); a = null != s ? e.filter.updatePriority(r, s) : o.getNode() } else { let c, u = nI(n); if (o.isCompleteForChild(h)) { l = t.serverCache.getNode(); let e = i0(i, n, o.getNode(), l); c = null != e ? o.getNode().getImmediateChild(h).updateChild(u, e) : o.getNode().getImmediateChild(h) } else c = i2(i, h, t.serverCache); a = null != c ? e.filter.updateChild(o.getNode(), h, c, u, r, s) : o.getNode() } } return iO(t, a, o.isFullyInitialized() || nS(n), e.filter.filtersNodes()) } } function re(e, t, n, i, r, s, o, a) { let l, h = t.serverCache, c = o ? e.filter : e.filter.getIndexedFilter(); if (nS(n)) l = c.updateFullNode(h.getNode(), i, null); else if (c.filtersNodes() && !h.isFiltered()) { let e = h.getNode().updateChild(n, i); l = c.updateFullNode(h.getNode(), e, null) } else { let e = nw(n); if (!h.isCompleteForPath(n) && nb(n) > 1) return t; let r = nI(n), s = h.getNode().getImmediateChild(e).updateChild(r, i); l = ".priority" === e ? c.updatePriority(h.getNode(), s) : c.updateChild(h.getNode(), e, s, r, i8, null) } let u = iD(t, l, h.isFullyInitialized() || nS(n), c.filtersNodes()), d = new i7(r, u, s); return i9(e, u, n, r, d, a) } function rt(e, t, n, i, r, s, o) { let a, l, h = t.eventCache, c = new i7(r, t, s); if (nS(n)) l = e.filter.updateFullNode(t.eventCache.getNode(), i, o), a = iO(t, l, !0, e.filter.filtersNodes()); else { let r = nw(n); if (".priority" === r) l = e.filter.updatePriority(t.eventCache.getNode(), i), a = iO(t, l, h.isFullyInitialized(), h.isFiltered()); else { let s, l = nI(n), u = h.getNode().getImmediateChild(r); if (nS(l)) s = i; else { let e = c.getCompleteChild(r); s = null != e ? ".priority" === nC(l) && e.getChild(nk(l)).isEmpty() ? e : e.updateChild(l, i) : n3.EMPTY_NODE } a = u.equals(s) ? t : iO(t, e.filter.updateChild(h.getNode(), r, s, l, c, o), h.isFullyInitialized(), e.filter.filtersNodes()) } } return a } function rn(e, t) { return e.eventCache.isCompleteForChild(t) } function ri(e, t, n) { return n.foreach((e, n) => { t = t.updateChild(e, n) }), t } function rr(e, t, n, i, r, s, o, a) { let l; if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized()) return t; let h = t; l = nS(n) ? i : new iF(null).setTree(n, i); let c = t.serverCache.getNode(); return l.children.inorderTraversal((n, i) => { if (c.hasChild(n)) { let l = ri(e, t.serverCache.getNode().getImmediateChild(n), i); h = re(e, h, new nv(n), l, r, s, o, a) } }), l.children.inorderTraversal((n, i) => { let l = !t.serverCache.isCompleteForChild(n) && null === i.value; if (!c.hasChild(n) && !l) { let l = ri(e, t.serverCache.getNode().getImmediateChild(n), i); h = re(e, h, new nv(n), l, r, s, o, a) } }), h } class rs { constructor(e, t) { this.query_ = e, this.eventRegistrations_ = []; let n = this.query_._queryParams, i = new is(n.getIndex()), r = function (e) { return e.loadsAllData() ? new is(e.getIndex()) : e.hasLimit() ? new ia(e) : new io(e) }(n); this.processor_ = { filter: r }; let s = t.serverCache, o = t.eventCache, a = i.updateFullNode(n3.EMPTY_NODE, s.getNode(), null), l = r.updateFullNode(n3.EMPTY_NODE, o.getNode(), null), h = new iN(a, s.isFullyInitialized(), i.filtersNodes()), c = new iN(l, o.isFullyInitialized(), r.filtersNodes()); this.viewCache_ = iA(c, h), this.eventGenerator_ = new iR(this.query_) } get query() { return this.query_ } } function ro(e) { return 0 === e.eventRegistrations_.length } function ra(e, t, n) { let i = []; if (n) { w(null == t, "A cancel should cancel all event registrations."); let r = e.query._path; e.eventRegistrations_.forEach(e => { let t = e.createCancelEvent(n, r); t && i.push(t) }) } if (t) { let n = []; for (let i = 0; i < e.eventRegistrations_.length; ++i) { let r = e.eventRegistrations_[i]; if (r.matches(t)) { if (t.hasAnyCallback()) { n = n.concat(e.eventRegistrations_.slice(i + 1)); break } } else n.push(r) } e.eventRegistrations_ = n } else e.eventRegistrations_ = []; return i } function rl(e, t, n, i) { var r, s; t.type === g.MERGE && null !== t.source.queryId && (w(iM(e.viewCache_), "We should always have a full cache before handling merges"), w(iL(e.viewCache_), "Missing event cache, even though we have a server cache")); let o = e.viewCache_, a = function (e, t, n, i, r) { let s, o, a = new i5; if (n.type === g.OVERWRITE) n.source.fromUser ? s = rt(e, t, n.path, n.snap, i, r, a) : (w(n.source.fromServer, "Unknown source."), o = n.source.tagged || t.serverCache.isFiltered() && !nS(n.path), s = re(e, t, n.path, n.snap, i, r, o, a)); else if (n.type === g.MERGE) { var l, h, c, u, d, p, f; let m; n.source.fromUser ? (l = e, h = t, c = n.path, u = n.children, d = i, p = r, f = a, m = h, u.foreach((e, t) => { let n = nE(c, e); rn(h, nw(n)) && (m = rt(l, m, n, t, d, p, f)) }), u.foreach((e, t) => { let n = nE(c, e); rn(h, nw(n)) || (m = rt(l, m, n, t, d, p, f)) }), s = m) : (w(n.source.fromServer, "Unknown source."), o = n.source.tagged || t.serverCache.isFiltered(), s = rr(e, t, n.path, n.children, i, r, o, a)) } else if (n.type === g.ACK_USER_WRITE) s = n.revert ? function (e, t, n, i, r, s) { let o; if (null != i1(i, n)) return t; { let a, l = new i7(i, t, r), h = t.eventCache.getNode(); if (nS(n) || ".priority" === nw(n)) { let n; if (t.serverCache.isFullyInitialized()) n = iX(i, iM(t)); else { let e = t.serverCache.getNode(); w(e instanceof n3, "serverChildren would be complete if leaf node"), n = iZ(i, e) } a = e.filter.updateFullNode(h, n, s) } else { let r = nw(n), c = i2(i, r, t.serverCache); null == c && t.serverCache.isCompleteForChild(r) && (c = h.getImmediateChild(r)), (a = null != c ? e.filter.updateChild(h, r, c, nI(n), l, s) : t.eventCache.getNode().hasChild(r) ? e.filter.updateChild(h, r, n3.EMPTY_NODE, nI(n), l, s) : h).isEmpty() && t.serverCache.isFullyInitialized() && (o = iX(i, iM(t))).isLeafNode() && (a = e.filter.updateFullNode(a, o, s)) } return o = t.serverCache.isFullyInitialized() || null != i1(i, ny()), iO(t, a, o, e.filter.filtersNodes()) } }(e, t, n.path, i, r, a) : function (e, t, n, i, r, s, o) { if (null != i1(r, n)) return t; let a = t.serverCache.isFiltered(), l = t.serverCache; if (null != i.value) if (nS(n) && l.isFullyInitialized() || l.isCompleteForPath(n)) return re(e, t, n, l.getNode().getChild(n), r, s, a, o); else { if (!nS(n)) return t; let i = new iF(null); return l.getNode().forEachChild(nq, (e, t) => { i = i.set(new nv(e), t) }), rr(e, t, n, i, r, s, a, o) } { let h = new iF(null); return i.foreach((e, t) => { let i = nE(n, e); l.isCompleteForPath(i) && (h = h.set(e, l.getNode().getChild(i))) }), rr(e, t, n, h, r, s, a, o) } }(e, t, n.path, n.affectedTree, i, r, a); else if (n.type === g.LISTEN_COMPLETE) s = function (e, t, n, i, r) { let s = t.serverCache; return i9(e, iD(t, s.getNode(), s.isFullyInitialized() || nS(n), s.isFiltered()), n, i, i8, r) }(e, t, n.path, i, a); else throw b("Unknown operation type: " + n.type); let m = a.getChanges(); return function (e, t, n) { let i = t.eventCache; if (i.isFullyInitialized()) { let r = i.getNode().isLeafNode() || i.getNode().isEmpty(), s = iL(e); !(n.length > 0) && e.eventCache.isFullyInitialized() && (!r || i.getNode().equals(s)) && i.getNode().getPriority().equals(s.getPriority()) || n.push(ie(iL(t))) } }(t, s, m), { viewCache: s, changes: m } }(e.processor_, o, t, n, i); return r = e.processor_, w((s = a.viewCache).eventCache.getNode().isIndexed(r.filter.getIndex()), "Event snap not indexed"), w(s.serverCache.getNode().isIndexed(r.filter.getIndex()), "Server snap not indexed"), w(a.viewCache.serverCache.isFullyInitialized() || !o.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back"), e.viewCache_ = a.viewCache, rh(e, a.changes, a.viewCache.eventCache.getNode(), null) } function rh(e, t, n, i) { let r = i ? [i] : e.eventRegistrations_; var s = e.eventGenerator_; let o = [], a = []; return t.forEach(e => { var t; "child_changed" === e.type && s.index_.indexedValueChanged(e.oldSnap, e.snapshotNode) && a.push((t = e.childName, { type: "child_moved", snapshotNode: e.snapshotNode, childName: t })) }), ix(s, o, "child_removed", t, r, n), ix(s, o, "child_added", t, r, n), ix(s, o, "child_moved", a, r, n), ix(s, o, "child_changed", t, r, n), ix(s, o, "value", t, r, n), o } class rc { constructor() { this.views = new Map } } function ru(e, t, n, i) { let r = t.source.queryId; if (null !== r) { let s = e.views.get(r); return w(null != s, "SyncTree gave us an op for an invalid query."), rl(s, t, n, i) } { let r = []; for (let s of e.views.values()) r = r.concat(rl(s, t, n, i)); return r } } function rd(e, t, n, i, r) { let s = t._queryIdentifier, o = e.views.get(s); if (!o) { let e = iX(n, r ? i : null), s = !1; return e ? s = !0 : (e = i instanceof n3 ? iZ(n, i) : n3.EMPTY_NODE, s = !1), new rs(t, iA(new iN(e, s, !1), new iN(i, r, !1))) } return o } function rp(e) { let t = []; for (let n of e.views.values()) n.query._queryParams.loadsAllData() || t.push(n); return t } function rf(e, t) { let n = null; for (let i of e.views.values()) n = n || function (e, t) { let n = iM(e.viewCache_); return n && (e.query._queryParams.loadsAllData() || !nS(t) && !n.getImmediateChild(nw(t)).isEmpty()) ? n.getChild(t) : null }(i, t); return n } function rm(e, t) { if (t._queryParams.loadsAllData()) return r_(e); { let n = t._queryIdentifier; return e.views.get(n) } } function rg(e) { return null != r_(e) } function r_(e) { for (let t of e.views.values()) if (t.query._queryParams.loadsAllData()) return t; return null } let rv = 1; class ry { constructor(e) { this.listenProvider_ = e, this.syncPointTree_ = new iF(null), this.pendingWriteTree_ = { visibleWrites: iU.empty(), allWrites: [], lastWriteId: -1 }, this.tagToQueryMap = new Map, this.queryToTagMap = new Map } } function rw(e, t, n, i, r) { var s, o; return (s = e.pendingWriteTree_, o = r, w(i > s.lastWriteId, "Stacking an older write on top of newer ones"), void 0 === o && (o = !0), s.allWrites.push({ path: t, snap: n, writeId: i, visible: o }), o && (s.visibleWrites = iq(s.visibleWrites, t, n)), s.lastWriteId = i, r) ? rS(e, new iS(iI(), t, n)) : [] } function rb(e, t, n = !1) { let i = function (e, t) { for (let n = 0; n < e.allWrites.length; n++) { let i = e.allWrites[n]; if (i.writeId === t) return i } return null }(e.pendingWriteTree_, t); if (!function (e, t) { var n; let i = e.allWrites.findIndex(e => e.writeId === t); w(i >= 0, "removeWrite called with nonexistent writeId."); let r = e.allWrites[i]; e.allWrites.splice(i, 1); let s = r.visible, o = !1, a = e.allWrites.length - 1; for (; s && a >= 0;) { let t = e.allWrites[a]; t.visible && (a >= i && function (e, t) { if (e.snap) return nx(e.path, t); for (let n in e.children) if (e.children.hasOwnProperty(n) && nx(nE(e.path, n), t)) return !0; return !1 }(t, r.path) ? s = !1 : nx(r.path, t.path) && (o = !0)), a-- } return !!s && (o ? ((n = e).visibleWrites = iJ(n.allWrites, iY, ny()), n.allWrites.length > 0 ? n.lastWriteId = n.allWrites[n.allWrites.length - 1].writeId : n.lastWriteId = -1) : r.snap ? e.visibleWrites = iz(e.visibleWrites, r.path) : tZ(r.children, t => { e.visibleWrites = iz(e.visibleWrites, nE(r.path, t)) }), !0) }(e.pendingWriteTree_, t)) return []; { let t = new iF(null); return null != i.snap ? t = t.set(ny(), !0) : tZ(i.children, e => { t = t.set(new nv(e), !0) }), rS(e, new ik(i.path, t, n)) } } function rI(e, t, n) { return rS(e, new iS(iC(), t, n)) } function rC(e, t, n, i, r = !1) { let s = t._path, o = e.syncPointTree_.get(s), a = []; if (o && ("default" === t._queryIdentifier || null != rm(o, t))) { let c = function (e, t, n, i) { let r = t._queryIdentifier, s = [], o = [], a = rg(e); if ("default" === r) for (let [t, r] of e.views.entries()) o = o.concat(ra(r, n, i)), ro(r) && (e.views.delete(t), r.query._queryParams.loadsAllData() || s.push(r.query)); else { let t = e.views.get(r); t && (o = o.concat(ra(t, n, i)), ro(t) && (e.views.delete(r), t.query._queryParams.loadsAllData() || s.push(t.query))) } return a && !rg(e) && s.push(new (w(p, "Reference.ts has not been loaded"), p)(t._repo, t._path)), { removed: s, events: o } }(o, t, n, i); 0 === o.views.size && (e.syncPointTree_ = e.syncPointTree_.remove(s)); let u = c.removed; if (a = c.events, !r) { let n = -1 !== u.findIndex(e => e._queryParams.loadsAllData()), r = e.syncPointTree_.findOnPath(s, (e, t) => rg(t)); if (n && !r) { let t = e.syncPointTree_.subtree(s); if (!t.isEmpty()) { let n = t.fold((e, t, n) => { if (t && rg(t)) return [r_(t)]; { let e = []; return t && (e = rp(t)), tZ(n, (t, n) => { e = e.concat(n) }), e } }); for (let t = 0; t < n.length; ++t) { let i = n[t], r = i.query, s = rP(e, i); e.listenProvider_.startListening(rD(r), rN(e, r), s.hashFn, s.onComplete) } } } r || !(u.length > 0) || i || (n ? e.listenProvider_.stopListening(rD(t), null) : u.forEach(t => { let n = e.queryToTagMap.get(rR(t)); e.listenProvider_.stopListening(rD(t), n) })) } var l = e, h = u; for (let e = 0; e < h.length; ++e) { let t = h[e]; if (!t._queryParams.loadsAllData()) { let e = rR(t), n = l.queryToTagMap.get(e); l.queryToTagMap.delete(e), l.tagToQueryMap.delete(n) } } } return a } function rT(e, t, n, i) { let r = rx(e, i); if (null == r) return []; { let i = rA(r), s = i.path, o = i.queryId, a = nP(s, t); return rO(e, s, new iS(iT(o), a, n)) } } function rk(e, t, n, i = !1) { let r, s = t._path, o = null, a = !1; e.syncPointTree_.foreachOnPath(s, (e, t) => { let n = nP(e, s); o = o || rf(t, n), a = a || rg(t) }); let l = e.syncPointTree_.get(s); l ? (a = a || rg(l), o = o || rf(l, ny())) : (l = new rc, e.syncPointTree_ = e.syncPointTree_.set(s, l)), null != o ? r = !0 : (r = !1, o = n3.EMPTY_NODE, e.syncPointTree_.subtree(s).foreachChild((e, t) => { let n = rf(t, ny()); n && (o = o.updateImmediateChild(e, n)) })); let h = null != rm(l, t); if (!h && !t._queryParams.loadsAllData()) { let n = rR(t); w(!e.queryToTagMap.has(n), "View does not exist, but we have a tag"); let i = rv++; e.queryToTagMap.set(n, i), e.tagToQueryMap.set(i, n) } let c = function (e, t, n, i, r, s) { let o = rd(e, t, i, r, s); e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, o), o.eventRegistrations_.push(n); let a = o.viewCache_.eventCache, l = []; return a.getNode().isLeafNode() || a.getNode().forEachChild(nQ, (e, t) => { l.push(it(e, t)) }), a.isFullyInitialized() && l.push(ie(a.getNode())), rh(o, l, a.getNode(), n) }(l, t, n, i4(s, e.pendingWriteTree_), o, r); if (!h && !a && !i) { let n = rm(l, t); c = c.concat(function (e, t, n) { let i = t._path, r = rN(e, t), s = rP(e, n), o = e.listenProvider_.startListening(rD(t), r, s.hashFn, s.onComplete), a = e.syncPointTree_.subtree(i); if (r) w(!rg(a.value), "If we're adding a query, it shouldn't be shadowed"); else { let t = a.fold((e, t, n) => { if (!nS(e) && t && rg(t)) return [r_(t).query]; { let e = []; return t && (e = e.concat(rp(t).map(e => e.query))), tZ(n, (t, n) => { e = e.concat(n) }), e } }); for (let n = 0; n < t.length; ++n) { let i = t[n]; e.listenProvider_.stopListening(rD(i), rN(e, i)) } } return o }(e, t, n)) } return c } function rE(e, t, n) { let i = e.pendingWriteTree_, r = e.syncPointTree_.findOnPath(t, (e, n) => { let i = rf(n, nP(e, t)); if (i) return i }); return iQ(i, t, r, n, !0) } function rS(e, t) { var n; return function e(t, n, i, r) { if (nS(t.path)) return function e(t, n, i, r) { let s = n.get(ny()); null == i && null != s && (i = rf(s, ny())); let o = []; return n.children.inorderTraversal((n, s) => { let a = i ? i.getImmediateChild(n) : null, l = i3(r, n), h = t.operationForChild(n); h && (o = o.concat(e(h, s, a, l))) }), s && (o = o.concat(ru(s, t, r, i))), o }(t, n, i, r); { let s = n.get(ny()); null == i && null != s && (i = rf(s, ny())); let o = [], a = nw(t.path), l = t.operationForChild(a), h = n.children.get(a); if (h && l) { let t = i ? i.getImmediateChild(a) : null, n = i3(r, a); o = o.concat(e(l, h, t, n)) } return s && (o = o.concat(ru(s, t, r, i))), o } }(t, e.syncPointTree_, null, (n = e.pendingWriteTree_, i4(ny(), n))) } function rP(e, t) { let n = t.query, i = rN(e, n); return { hashFn: () => (t.viewCache_.serverCache.getNode() || n3.EMPTY_NODE).hash(), onComplete: t => { if ("ok" === t) if (i) return function (e, t, n) { let i = rx(e, n); if (!i) return []; { let n = rA(i), r = n.path, s = n.queryId, o = nP(r, t); return rO(e, r, new iE(iT(s), o)) } }(e, n._path, i); else { var r; return r = n._path, rS(e, new iE(iC(), r)) } { let i = function (e, t) { let n = "Unknown Error"; "too_big" === e ? n = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" === e ? n = "Client doesn't have permission to access the desired data." : "unavailable" === e && (n = "The service is unavailable"); let i = Error(e + " at " + t._path.toString() + ": " + n); return i.code = e.toUpperCase(), i }(t, n); return rC(e, n, null, i) } } } } function rN(e, t) { let n = rR(t); return e.queryToTagMap.get(n) } function rR(e) { return e._path.toString() + "$" + e._queryIdentifier } function rx(e, t) { return e.tagToQueryMap.get(t) } function rA(e) { let t = e.indexOf("$"); return w(-1 !== t && t < e.length - 1, "Bad queryKey."), { queryId: e.substr(t + 1), path: new nv(e.substr(0, t)) } } function rO(e, t, n) { let i = e.syncPointTree_.get(t); return w(i, "Missing sync point for query tag that we're tracking"), ru(i, n, i4(t, e.pendingWriteTree_), null) } function rD(e) { return e._queryParams.loadsAllData() && !e._queryParams.isDefault() ? new (w(f, "Reference.ts has not been loaded"), f)(e._repo, e._path) : e } class rL { constructor(e) { this.node_ = e } getImmediateChild(e) { return new rL(this.node_.getImmediateChild(e)) } node() { return this.node_ } } class rM { constructor(e, t) { this.syncTree_ = e, this.path_ = t } getImmediateChild(e) { let t = nE(this.path_, e); return new rM(this.syncTree_, t) } node() { return rE(this.syncTree_, this.path_) } } let rj = function (e, t, n) { return e && "object" == typeof e ? (w(".sv" in e, "Unexpected leaf node or priority contents"), "string" == typeof e[".sv"]) ? rF(e[".sv"], t, n) : "object" == typeof e[".sv"] ? rU(e[".sv"], t) : void w(!1, "Unexpected server value: " + JSON.stringify(e, null, 2)) : e }, rF = function (e, t, n) { if ("timestamp" === e) return n.timestamp; w(!1, "Unexpected server value: " + e) }, rU = function (e, t, n) { e.hasOwnProperty("increment") || w(!1, "Unexpected server value: " + JSON.stringify(e, null, 2)); let i = e.increment; "number" != typeof i && w(!1, "Unexpected increment value: " + i); let r = t.node(); if (w(null != r, "Expected ChildrenNode.EMPTY_NODE for nulls"), !r.isLeafNode()) return i; let s = r.getValue(); return "number" != typeof s ? i : s + i }, rq = function (e, t, n, i) { return rz(t, new rM(n, e), i) }, rW = function (e, t, n) { return rz(e, new rL(t), n) }; function rz(e, t, n) { let i, r = rj(e.getPriority().val(), t.getImmediateChild(".priority"), n); if (!e.isLeafNode()) return i = e, r !== e.getPriority().val() && (i = i.updatePriority(new nY(r))), e.forEachChild(nQ, (e, r) => { let s = rz(r, t.getImmediateChild(e), n); s !== r && (i = i.updateImmediateChild(e, s)) }), i; { let i = rj(e.getValue(), t, n); return i !== e.getValue() || r !== e.getPriority().val() ? new nY(i, n6(r)) : e } } class rV { constructor(e = "", t = null, n = { children: {}, childCount: 0 }) { this.name = e, this.parent = t, this.node = n } } function rB(e, t) { let n = t instanceof nv ? t : new nv(t), i = e, r = nw(n); for (; null !== r;) { let e = et(i.node.children, r) || { children: {}, childCount: 0 }; i = new rV(r, i, e), r = nw(n = nI(n)) } return i } function rH(e) { return e.node.value } function r$(e, t) { e.node.value = t, function e(t) { null !== t.parent && function (t, n, i) { let r = void 0 === rH(i) && !rG(i), s = ee(t.node.children, n); r && s ? (delete t.node.children[n], t.node.childCount--, e(t)) : r || s || (t.node.children[n] = i.node, t.node.childCount++, e(t)) }(t.parent, t.name, t) }(e) } function rG(e) { return e.node.childCount > 0 } function rK(e, t) { tZ(e.node.children, (n, i) => { t(new rV(n, e, i)) }) } function rY(e) { return new nv(null === e.parent ? e.name : rY(e.parent) + "/" + e.name) } let rJ = /[\[\].#$\/\u0000-\u001F\u007F]/, rQ = /[\[\].#$\u0000-\u001F\u007F]/, rX = function (e) { return "string" == typeof e && 0 !== e.length && !rJ.test(e) }, rZ = function (e) { return "string" == typeof e && 0 !== e.length && !rQ.test(e) }, r0 = function (e) { return null === e || "string" == typeof e || "number" == typeof e && !tB(e) || e && "object" == typeof e && ee(e, ".sv") }, r1 = function (e, t, n, i) { i && void 0 === t || r2(ef(e, "value"), t, n) }, r2 = function (e, t, n) { let i = n instanceof nv ? new nA(n, e) : n; if (void 0 === t) throw Error(e + "contains undefined " + nD(i)); if ("function" == typeof t) throw Error(e + "contains a function " + nD(i) + " with contents = " + t.toString()); if (tB(t)) throw Error(e + "contains " + t.toString() + " " + nD(i)); if ("string" == typeof t && t.length > 3495253.3333333335 && ev(t) > 0xa00000) throw Error(e + "contains a string greater than 10485760 utf8 bytes " + nD(i) + " ('" + t.substring(0, 50) + "...')"); if (t && "object" == typeof t) { let n = !1, r = !1; if (tZ(t, (t, s) => { if (".value" === t) n = !0; else if (".priority" !== t && ".sv" !== t && (r = !0, !rX(t))) throw Error(e + " contains an invalid key (" + t + ") " + nD(i) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'); i.parts_.length > 0 && (i.byteLength_ += 1), i.parts_.push(t), i.byteLength_ += ev(t), nO(i), r2(e, s, i); let o = i.parts_.pop(); i.byteLength_ -= ev(o), i.parts_.length > 0 && (i.byteLength_ -= 1) }), n && r) throw Error(e + ' contains ".value" child ' + nD(i) + " in addition to actual children.") } }, r3 = function (e, t) { let n, i; for (n = 0; n < t.length; n++) { let r = nT(i = t[n]); for (let t = 0; t < r.length; t++)if (".priority" === r[t] && t === r.length - 1); else if (!rX(r[t])) throw Error(e + "contains an invalid key (" + r[t] + ") in path " + i.toString() + '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"') } t.sort(nN); let r = null; for (n = 0; n < t.length; n++) { if (i = t[n], null !== r && nx(r, i)) throw Error(e + "contains a path " + r.toString() + " that is ancestor of another path " + i.toString()); r = i } }, r4 = function (e, t, n, i) { if (i && void 0 === t) return; let r = ef(e, "values"); if (!(t && "object" == typeof t) || Array.isArray(t)) throw Error(r + " must be an object containing the children to replace."); let s = []; tZ(t, (e, t) => { let i = new nv(e); if (r2(r, t, nE(n, i)), ".priority" === nC(i) && !r0(t)) throw Error(r + "contains an invalid value for '" + i.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null)."); s.push(i) }), r3(r, s) }, r5 = function (e, t, n) { if (!n || void 0 !== t) { if (tB(t)) throw Error(ef(e, "priority") + "is " + t.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null)."); if (!r0(t)) throw Error(ef(e, "priority") + "must be a valid Firebase priority (a string, finite number, server value, or null).") } }, r6 = function (e, t, n, i) { if ((!i || void 0 !== n) && !rX(n)) throw Error(ef(e, t) + 'was an invalid key = "' + n + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").') }, r8 = function (e, t, n, i) { if ((!i || void 0 !== n) && !rZ(n)) throw Error(ef(e, t) + 'was an invalid path = "' + n + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"') }, r7 = function (e, t, n, i) { n && (n = n.replace(/^\/*\.info(\/|$)/, "/")), r8(e, t, n, i) }, r9 = function (e, t) { if (".info" === nw(t)) throw Error(e + " failed = Can't modify data under /.info/") }, se = function (e, t) { var n; let i = t.path.toString(); if ("string" != typeof t.repoInfo.host || 0 === t.repoInfo.host.length || !rX(t.repoInfo.namespace) && "localhost" !== t.repoInfo.host.split(":")[0] || 0 !== i.length && ((n = i) && (n = n.replace(/^\/*\.info(\/|$)/, "/")), !rZ(n))) throw Error(ef(e, "url") + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".') }; class st { constructor() { this.eventLists_ = [], this.recursionDepth_ = 0 } } function sn(e, t) { let n = null; for (let i = 0; i < t.length; i++) { let r = t[i], s = r.getPath(); null === n || nR(s, n.path) || (e.eventLists_.push(n), n = null), null === n && (n = { events: [], path: s }), n.events.push(r) } n && e.eventLists_.push(n) } function si(e, t, n) { sn(e, n), ss(e, e => nR(e, t)) } function sr(e, t, n) { sn(e, n), ss(e, e => nx(e, t) || nx(t, e)) } function ss(e, t) { e.recursionDepth_++; let n = !0; for (let i = 0; i < e.eventLists_.length; i++) { let r = e.eventLists_[i]; r && (t(r.path) ? (function (e) { for (let t = 0; t < e.events.length; t++) { let n = e.events[t]; if (null !== n) { e.events[t] = null; let i = n.getEventRunner(); tL && tF("event: " + n.toString()), t3(i) } } }(e.eventLists_[i]), e.eventLists_[i] = null) : n = !1) } n && (e.eventLists_ = []), e.recursionDepth_-- } let so = "repo_interrupt"; class sa { constructor(e, t, n, i) { this.repoInfo_ = e, this.forceRestClient_ = t, this.authTokenProvider_ = n, this.appCheckProvider_ = i, this.dataUpdateCount = 0, this.statsListener_ = null, this.eventQueue_ = new st, this.nextWriteId_ = 1, this.interceptServerDataCallback_ = null, this.onDisconnect_ = i_(), this.transactionQueueTree_ = new rV, this.persistentConnection_ = null, this.key = this.repoInfo_.toURLString() } toString() { return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host } } function sl(e) { let t = e.infoData_.getNode(new nv(".info/serverTimeOffset")).val() || 0; return new Date().getTime() + t } function sh(e) { var t; return (t = t = { timestamp: sl(e) }).timestamp = t.timestamp || new Date().getTime(), t } function sc(e, t, n, i, r) { e.dataUpdateCount++; let s = new nv(t); n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n; let o = []; if (r) if (i) { let t = ei(n, e => n6(e)); o = function (e, t, n, i) { let r = rx(e, i); if (!r) return []; { let i = rA(r), s = i.path, o = i.queryId, a = nP(s, t), l = iF.fromObject(n); return rO(e, s, new iP(iT(o), a, l)) } }(e.serverSyncTree_, s, t, r) } else { let t = n6(n); o = rT(e.serverSyncTree_, s, t, r) } else if (i) { let t = ei(n, e => n6(e)); o = function (e, t, n) { let i = iF.fromObject(n); return rS(e, new iP(iC(), t, i)) }(e.serverSyncTree_, s, t) } else { let t = n6(n); o = rI(e.serverSyncTree_, s, t) } let a = s; o.length > 0 && (a = sI(e, s)), sr(e.eventQueue_, a, o) } function su(e, t) { sd(e, "connected", t), !1 === t && function (e) { sv(e, "onDisconnectEvents"); let t = sh(e), n = i_(); iy(e.onDisconnect_, ny(), (i, r) => { let s = rq(i, r, e.serverSyncTree_, t); iv(n, i, s) }); let i = []; iy(n, ny(), (t, n) => { i = i.concat(rI(e.serverSyncTree_, t, n)); let r = sE(e, t); sI(e, r) }), e.onDisconnect_ = i_(), sr(e.eventQueue_, ny(), i) }(e) } function sd(e, t, n) { let i = new nv("/.info/" + t), r = n6(n); e.infoData_.updateSnapshot(i, r); let s = rI(e.infoSyncTree_, i, r); sr(e.eventQueue_, i, s) } function sp(e) { return e.nextWriteId_++ } function sf(e, t, n, i, r) { sv(e, "set", { path: t.toString(), value: n, priority: i }); let s = sh(e), o = n6(n, i), a = rW(o, rE(e.serverSyncTree_, t), s), l = sp(e), h = rw(e.serverSyncTree_, t, a, l, !0); sn(e.eventQueue_, h), e.server_.put(t.toString(), o.val(!0), (n, i) => { let s = "ok" === n; s || tz("set at " + t + " failed: " + n); let o = rb(e.serverSyncTree_, l, !s); sr(e.eventQueue_, t, o), sy(e, r, n, i) }); let c = sE(e, t); sI(e, c), sr(e.eventQueue_, c, []) } function sm(e, t, n, i) { let r = n6(n); e.server_.onDisconnectPut(t.toString(), r.val(!0), (n, s) => { "ok" === n && iv(e.onDisconnect_, t, r), sy(e, i, n, s) }) } function sg(e, t, n) { let i; i = ".info" === nw(t._path) ? rC(e.infoSyncTree_, t, n) : rC(e.serverSyncTree_, t, n), si(e.eventQueue_, t._path, i) } function s_(e) { e.persistentConnection_ && e.persistentConnection_.interrupt(so) } function sv(e, ...t) { let n = ""; e.persistentConnection_ && (n = e.persistentConnection_.id + ":"), tF(n, ...t) } function sy(e, t, n, i) { t && t3(() => { if ("ok" === n) t(null); else { let e = (n || "error").toUpperCase(), r = e; i && (r += ": " + i); let s = Error(r); s.code = e, t(s) } }) } function sw(e, t, n) { return rE(e.serverSyncTree_, t, n) || n3.EMPTY_NODE } function sb(e, t = e.transactionQueueTree_) { if (t || sk(e, t), rH(t)) { let n = sT(e, t); w(n.length > 0, "Sending zero length transaction queue"), n.every(e => 0 === e.status) && function (e, t, n) { let i = sw(e, t, n.map(e => e.currentWriteId)), r = i, s = i.hash(); for (let e = 0; e < n.length; e++) { let i = n[e]; w(0 === i.status, "tryToSendTransactionQueue_: items in queue should all be run."), i.status = 1, i.retryCount++; let s = nP(t, i.path); r = r.updateChild(s, i.currentOutputSnapshotRaw) } let o = r.val(!0); e.server_.put(t.toString(), o, i => { sv(e, "transaction put response", { path: t.toString(), status: i }); let r = []; if ("ok" === i) { let i = []; for (let t = 0; t < n.length; t++)n[t].status = 2, r = r.concat(rb(e.serverSyncTree_, n[t].currentWriteId)), n[t].onComplete && i.push(() => n[t].onComplete(null, !0, n[t].currentOutputSnapshotResolved)), n[t].unwatcher(); sk(e, rB(e.transactionQueueTree_, t)), sb(e, e.transactionQueueTree_), sr(e.eventQueue_, t, r); for (let e = 0; e < i.length; e++)t3(i[e]) } else { if ("datastale" === i) for (let e = 0; e < n.length; e++)3 === n[e].status ? n[e].status = 4 : n[e].status = 0; else { tz("transaction at " + t.toString() + " failed: " + i); for (let e = 0; e < n.length; e++)n[e].status = 4, n[e].abortReason = i } sI(e, t) } }, s) }(e, rY(t), n) } else rG(t) && rK(t, t => { sb(e, t) }) } function sI(e, t) { let n = sC(e, t), i = rY(n), r = sT(e, n); return function (e, t, n) { if (0 === t.length) return; let i = [], r = [], s = t.filter(e => 0 === e.status).map(e => e.currentWriteId); for (let o = 0; o < t.length; o++) { let a = t[o], l = nP(n, a.path), h = !1, c; if (w(null !== l, "rerunTransactionsUnderNode_: relativePath should not be null."), 4 === a.status) h = !0, c = a.abortReason, r = r.concat(rb(e.serverSyncTree_, a.currentWriteId, !0)); else if (0 === a.status) if (a.retryCount >= 25) h = !0, c = "maxretry", r = r.concat(rb(e.serverSyncTree_, a.currentWriteId, !0)); else { let n = sw(e, a.path, s); a.currentInputSnapshot = n; let i = t[o].update(n.val()); if (void 0 !== i) { r2("transaction failed: Data returned ", i, a.path); let t = n6(i); "object" == typeof i && null != i && ee(i, ".priority") || (t = t.updatePriority(n.getPriority())); let o = a.currentWriteId, l = rW(t, n, sh(e)); a.currentOutputSnapshotRaw = t, a.currentOutputSnapshotResolved = l, a.currentWriteId = sp(e), s.splice(s.indexOf(o), 1), r = (r = r.concat(rw(e.serverSyncTree_, a.path, l, a.currentWriteId, a.applyLocally))).concat(rb(e.serverSyncTree_, o, !0)) } else h = !0, c = "nodata", r = r.concat(rb(e.serverSyncTree_, a.currentWriteId, !0)) } sr(e.eventQueue_, n, r), r = [], h && (t[o].status = 2, setTimeout(t[o].unwatcher, Math.floor(0)), t[o].onComplete && ("nodata" === c ? i.push(() => t[o].onComplete(null, !1, t[o].currentInputSnapshot)) : i.push(() => t[o].onComplete(Error(c), !1, null)))) } sk(e, e.transactionQueueTree_); for (let e = 0; e < i.length; e++)t3(i[e]); sb(e, e.transactionQueueTree_) }(e, r, i), i } function sC(e, t) { let n, i = e.transactionQueueTree_; for (n = nw(t); null !== n && void 0 === rH(i);)i = rB(i, n), n = nw(t = nI(t)); return i } function sT(e, t) { let n = []; return function e(t, n, i) { let r = rH(n); if (r) for (let e = 0; e < r.length; e++)i.push(r[e]); rK(n, n => { e(t, n, i) }) }(e, t, n), n.sort((e, t) => e.order - t.order), n } function sk(e, t) { let n = rH(t); if (n) { let e = 0; for (let t = 0; t < n.length; t++)2 !== n[t].status && (n[e] = n[t], e++); n.length = e, r$(t, n.length > 0 ? n : void 0) } rK(t, t => { sk(e, t) }) } function sE(e, t) { let n = rY(sC(e, t)), i = rB(e.transactionQueueTree_, t); return !function (e, t, n) { let i = e.parent; for (; null !== i;) { if (t(i)) return !0; i = i.parent } }(i, t => { sS(e, t) }), sS(e, i), !function e(t, n, i, r) { i && !r && n(t), rK(t, t => { e(t, n, !0, r) }), i && r && n(t) }(i, t => { sS(e, t) }), n } function sS(e, t) { let n = rH(t); if (n) { let i = [], r = [], s = -1; for (let t = 0; t < n.length; t++)3 === n[t].status || (1 === n[t].status ? (w(s === t - 1, "All SENT items should be at beginning of queue."), s = t, n[t].status = 3, n[t].abortReason = "set") : (w(0 === n[t].status, "Unexpected transaction status in abort"), n[t].unwatcher(), r = r.concat(rb(e.serverSyncTree_, n[t].currentWriteId, !0)), n[t].onComplete && i.push(n[t].onComplete.bind(null, Error("set"), !1, null)))); -1 === s ? r$(t, void 0) : n.length = s + 1, sr(e.eventQueue_, rY(t), r); for (let e = 0; e < i.length; e++)t3(i[e]) } } let sP = function (e, t) { let n = sN(e), i = n.namespace; "firebase.com" === n.domain && tW(n.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"), i && "undefined" !== i || "localhost" === n.domain || tW("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"), n.secure || tV(); let r = "ws" === n.scheme || "wss" === n.scheme; return { repoInfo: new nt(n.host, n.secure, i, r, t, "", i !== n.subdomain), path: new nv(n.pathString) } }, sN = function (e) { let t = "", n = "", i = "", r = "", s = "", o = !0, a = "https", l = 443; if ("string" == typeof e) { let h = e.indexOf("//"); h >= 0 && (a = e.substring(0, h - 1), e = e.substring(h + 2)); let c = e.indexOf("/"); -1 === c && (c = e.length); let u = e.indexOf("?"); -1 === u && (u = e.length), t = e.substring(0, Math.min(c, u)), c < u && (r = function (e) { let t = "", n = e.split("/"); for (let e = 0; e < n.length; e++)if (n[e].length > 0) { let i = n[e]; try { i = decodeURIComponent(i.replace(/\+/g, " ")) } catch (e) { } t += "/" + i } return t }(e.substring(c, u))); let d = function (e) { let t = {}; for (let n of ("?" === e.charAt(0) && (e = e.substring(1)), e.split("&"))) { if (0 === n.length) continue; let i = n.split("="); 2 === i.length ? t[decodeURIComponent(i[0])] = decodeURIComponent(i[1]) : tz(`Invalid query segment '${n}' in query '${e}'`) } return t }(e.substring(Math.min(e.length, u))); (h = t.indexOf(":")) >= 0 ? (o = "https" === a || "wss" === a, l = parseInt(t.substring(h + 1), 10)) : h = t.length; let p = t.slice(0, h); if ("localhost" === p.toLowerCase()) n = "localhost"; else if (p.split(".").length <= 2) n = p; else { let e = t.indexOf("."); i = t.substring(0, e).toLowerCase(), n = t.substring(e + 1), s = i } "ns" in d && (s = d.ns) } return { host: t, port: l, domain: n, subdomain: i, secure: o, scheme: a, pathString: r, namespace: s } }, sR = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz", sx = function () { let e = 0, t = []; return function (n) { let i, r = n === e; e = n; let s = Array(8); for (i = 7; i >= 0; i--)s[i] = sR.charAt(n % 64), n = Math.floor(n / 64); w(0 === n, "Cannot push at time == 0"); let o = s.join(""); if (r) { for (i = 11; i >= 0 && 63 === t[i]; i--)t[i] = 0; t[i]++ } else for (i = 0; i < 12; i++)t[i] = Math.floor(64 * Math.random()); for (i = 0; i < 12; i++)o += sR.charAt(t[i]); return w(20 === o.length, "nextPushId: Length should be 20."), o } }(); class sA { constructor(e, t, n, i) { this.eventType = e, this.eventRegistration = t, this.snapshot = n, this.prevName = i } getPath() { let e = this.snapshot.ref; return "value" === this.eventType ? e._path : e.parent._path } getEventType() { return this.eventType } getEventRunner() { return this.eventRegistration.getEventRunner(this) } toString() { return this.getPath().toString() + ":" + this.eventType + ":" + J(this.snapshot.exportVal()) } } class sO { constructor(e, t, n) { this.eventRegistration = e, this.error = t, this.path = n } getPath() { return this.path } getEventType() { return "cancel" } getEventRunner() { return this.eventRegistration.getEventRunner(this) } toString() { return this.path.toString() + ":cancel" } } class sD { constructor(e, t) { this.snapshotCallback = e, this.cancelCallback = t } onValue(e, t) { this.snapshotCallback.call(null, e, t) } onCancel(e) { return w(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback"), this.cancelCallback.call(null, e) } get hasCancelCallback() { return !!this.cancelCallback } matches(e) { return this.snapshotCallback === e.snapshotCallback || void 0 !== this.snapshotCallback.userCallback && this.snapshotCallback.userCallback === e.snapshotCallback.userCallback && this.snapshotCallback.context === e.snapshotCallback.context } } class sL { constructor(e, t) { this._repo = e, this._path = t } cancel() { var e, t, n; let i = new M; return e = this._repo, t = this._path, n = i.wrapCallback(() => { }), e.server_.onDisconnectCancel(t.toString(), (i, r) => { "ok" === i && function e(t, n) { if (nS(n)) return t.value = null, t.children.clear(), !0; if (null !== t.value) if (t.value.isLeafNode()) return !1; else { let i = t.value; return t.value = null, i.forEachChild(nQ, (e, n) => { iv(t, new nv(e), n) }), e(t, n) } if (!(t.children.size > 0)) return !0; { let i = nw(n); return n = nI(n), t.children.has(i) && e(t.children.get(i), n) && t.children.delete(i), 0 === t.children.size } }(e.onDisconnect_, t), sy(e, n, i, r) }), i.promise } remove() { r9("OnDisconnect.remove", this._path); let e = new M; return sm(this._repo, this._path, null, e.wrapCallback(() => { })), e.promise } set(e) { r9("OnDisconnect.set", this._path), r1("OnDisconnect.set", e, this._path, !1); let t = new M; return sm(this._repo, this._path, e, t.wrapCallback(() => { })), t.promise } setWithPriority(e, t) { r9("OnDisconnect.setWithPriority", this._path), r1("OnDisconnect.setWithPriority", e, this._path, !1), r5("OnDisconnect.setWithPriority", t, !1); let n = new M; return !function (e, t, n, i, r) { let s = n6(n, i); e.server_.onDisconnectPut(t.toString(), s.val(!0), (n, i) => { "ok" === n && iv(e.onDisconnect_, t, s), sy(e, r, n, i) }) }(this._repo, this._path, e, t, n.wrapCallback(() => { })), n.promise } update(e) { r9("OnDisconnect.update", this._path), r4("OnDisconnect.update", e, this._path, !1); let t = new M; return !function (e, t, n, i) { if (en(n)) { tF("onDisconnect().update() called with empty data.  Don't do anything."), sy(e, i, "ok", void 0); return } e.server_.onDisconnectMerge(t.toString(), n, (r, s) => { "ok" === r && tZ(n, (n, i) => { let r = n6(i); iv(e.onDisconnect_, nE(t, n), r) }), sy(e, i, r, s) }) }(this._repo, this._path, e, t.wrapCallback(() => { })), t.promise } } class sM { constructor(e, t, n, i) { this._repo = e, this._path = t, this._queryParams = n, this._orderByCalled = i } get key() { return nS(this._path) ? null : nC(this._path) } get ref() { return new sq(this._repo, this._path) } get _queryIdentifier() { let e = tQ(ip(this._queryParams)); return "{}" === e ? "default" : e } get _queryObject() { return ip(this._queryParams) } isEqual(e) { if (!((e = ey(e)) instanceof sM)) return !1; let t = this._repo === e._repo, n = nR(this._path, e._path), i = this._queryIdentifier === e._queryIdentifier; return t && n && i } toJSON() { return this.toString() } toString() { return this._repo.toString() + function (e) { let t = ""; for (let n = e.pieceNum_; n < e.pieces_.length; n++)"" !== e.pieces_[n] && (t += "/" + encodeURIComponent(String(e.pieces_[n]))); return t || "/" }(this._path) } } function sj(e, t) { if (!0 === e._orderByCalled) throw Error(t + ": You can't combine multiple orderBy calls.") } function sF(e) { let t = null, n = null; if (e.hasStart() && (t = e.getIndexStartValue()), e.hasEnd() && (n = e.getIndexEndValue()), e.getIndex() === nq) { let i = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().", r = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string."; if (e.hasStart()) { if (e.getIndexStartName() !== t$) throw Error(i); if ("string" != typeof t) throw Error(r) } if (e.hasEnd()) { if (e.getIndexEndName() !== tG) throw Error(i); if ("string" != typeof n) throw Error(r) } } else if (e.getIndex() === nQ) { if (null != t && !r0(t) || null != n && !r0(n)) throw Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).") } else if (w(e.getIndex() instanceof n8 || e.getIndex() === n9, "unknown index type."), null != t && "object" == typeof t || null != n && "object" == typeof n) throw Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.") } function sU(e) { if (e.hasStart() && e.hasEnd() && e.hasLimit() && !e.hasAnchoredLimit()) throw Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.") } class sq extends sM { constructor(e, t) { super(e, t, new il, !1) } get parent() { let e = nk(this._path); return null === e ? null : new sq(this._repo, e) } get root() { let e = this; for (; null !== e.parent;)e = e.parent; return e } } class sW { constructor(e, t, n) { this._node = e, this.ref = t, this._index = n } get priority() { return this._node.getPriority().val() } get key() { return this.ref.key } get size() { return this._node.numChildren() } child(e) { let t = new nv(e), n = sB(this.ref, e); return new sW(this._node.getChild(t), n, nQ) } exists() { return !this._node.isEmpty() } exportVal() { return this._node.val(!0) } forEach(e) { return !this._node.isLeafNode() && !!this._node.forEachChild(this._index, (t, n) => e(new sW(n, sB(this.ref, t), nQ))) } hasChild(e) { let t = new nv(e); return !this._node.getChild(t).isEmpty() } hasChildren() { return !this._node.isLeafNode() && !this._node.isEmpty() } toJSON() { return this.exportVal() } val() { return this._node.val() } } function sz(e, t) { return (e = ey(e))._checkNotDeleted("ref"), void 0 !== t ? sB(e._root, t) : e._root } function sV(e, t) { (e = ey(e))._checkNotDeleted("refFromURL"); let n = sP(t, e._repo.repoInfo_.nodeAdmin); se("refFromURL", n); let i = n.repoInfo; return e._repo.repoInfo_.isCustomHost() || i.host === e._repo.repoInfo_.host || tW("refFromURL: Host name does not match the current database: (found " + i.host + " but expected " + e._repo.repoInfo_.host + ")"), sz(e, n.path.toString()) } function sB(e, t) { return null === nw((e = ey(e))._path) ? r7("child", "path", t, !1) : r8("child", "path", t, !1), new sq(e._repo, nE(e._path, t)) } function sH(e, t) { r9("set", (e = ey(e))._path), r1("set", t, e._path, !1); let n = new M; return sf(e._repo, e._path, t, null, n.wrapCallback(() => { })), n.promise } class s$ { constructor(e) { this.callbackContext = e } respondsTo(e) { return "value" === e } createEvent(e, t) { let n = t._queryParams.getIndex(); return new sA("value", this, new sW(e.snapshotNode, new sq(t._repo, t._path), n)) } getEventRunner(e) { return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, null) } createCancelEvent(e, t) { return this.callbackContext.hasCancelCallback ? new sO(this, e, t) : null } matches(e) { return e instanceof s$ && (!e.callbackContext || !this.callbackContext || e.callbackContext.matches(this.callbackContext)) } hasAnyCallback() { return null !== this.callbackContext } } class sG { constructor(e, t) { this.eventType = e, this.callbackContext = t } respondsTo(e) { let t = "children_added" === e ? "child_added" : e; return t = "children_removed" === t ? "child_removed" : t, this.eventType === t } createCancelEvent(e, t) { return this.callbackContext.hasCancelCallback ? new sO(this, e, t) : null } createEvent(e, t) { w(null != e.childName, "Child events should have a childName."); let n = sB(new sq(t._repo, t._path), e.childName), i = t._queryParams.getIndex(); return new sA(e.type, this, new sW(e.snapshotNode, n, i), e.prevName) } getEventRunner(e) { return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, e.prevName) } matches(e) { return e instanceof sG && this.eventType === e.eventType && (!this.callbackContext || !e.callbackContext || this.callbackContext.matches(e.callbackContext)) } hasAnyCallback() { return !!this.callbackContext } } function sK(e, t, n, i, r) { var s; let o, a; if ("object" == typeof i && (o = void 0, r = i), "function" == typeof i && (o = i), r && r.onlyOnce) { let t = n, i = (n, i) => { sg(e._repo, e, h), t(n, i) }; i.userCallback = n.userCallback, i.context = n.context, n = i } let l = new sD(n, o || void 0), h = "value" === t ? new s$(l) : new sG(t, l); return s = e._repo, a = ".info" === nw(e._path) ? rk(s.infoSyncTree_, e, h) : rk(s.serverSyncTree_, e, h), si(s.eventQueue_, e._path, a), () => sg(e._repo, e, h) } function sY(e, t, n, i) { return sK(e, "value", t, n, i) } function sJ(e, t, n, i) { return sK(e, "child_added", t, n, i) } function sQ(e, t, n, i) { return sK(e, "child_changed", t, n, i) } function sX(e, t, n, i) { return sK(e, "child_moved", t, n, i) } function sZ(e, t, n, i) { return sK(e, "child_removed", t, n, i) } function s0(e, t, n) { let i = null, r = n ? new sD(n) : null; "value" === t ? i = new s$(r) : t && (i = new sG(t, r)), sg(e._repo, e, i) } class s1 { } class s2 extends s1 { constructor(e, t) { super(), this._value = e, this._key = t, this.type = "endAt" } _apply(e) { r1("endAt", this._value, e._path, !0); let t = ic(e._queryParams, this._value, this._key); if (sU(t), sF(t), e._queryParams.hasEnd()) throw Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo)."); return new sM(e._repo, e._path, t, e._orderByCalled) } } class s3 extends s1 { constructor(e, t) { super(), this._value = e, this._key = t, this.type = "endBefore" } _apply(e) { var t, n, i; let r; r1("endBefore", this._value, e._path, !1); let s = (t = e._queryParams, n = this._value, i = this._key, (r = t.index_ === nq || i ? ic(t, n, i) : ic(t, n, t$)).endBeforeSet_ = !0, r); if (sU(s), sF(s), e._queryParams.hasEnd()) throw Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo)."); return new sM(e._repo, e._path, s, e._orderByCalled) } } class s4 extends s1 { constructor(e, t) { super(), this._value = e, this._key = t, this.type = "startAt" } _apply(e) { r1("startAt", this._value, e._path, !0); let t = ih(e._queryParams, this._value, this._key); if (sU(t), sF(t), e._queryParams.hasStart()) throw Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo)."); return new sM(e._repo, e._path, t, e._orderByCalled) } } class s5 extends s1 { constructor(e, t) { super(), this._value = e, this._key = t, this.type = "startAfter" } _apply(e) { var t, n, i; let r; r1("startAfter", this._value, e._path, !1); let s = (t = e._queryParams, n = this._value, i = this._key, (r = t.index_ === nq || i ? ih(t, n, i) : ih(t, n, tG)).startAfterSet_ = !0, r); if (sU(s), sF(s), e._queryParams.hasStart()) throw Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo)."); return new sM(e._repo, e._path, s, e._orderByCalled) } } class s6 extends s1 { constructor(e) { super(), this._limit = e, this.type = "limitToFirst" } _apply(e) { if (e._queryParams.hasLimit()) throw Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast)."); return new sM(e._repo, e._path, function (e, t) { let n = e.copy(); return n.limitSet_ = !0, n.limit_ = t, n.viewFrom_ = "l", n }(e._queryParams, this._limit), e._orderByCalled) } } class s8 extends s1 { constructor(e) { super(), this._limit = e, this.type = "limitToLast" } _apply(e) { if (e._queryParams.hasLimit()) throw Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast)."); return new sM(e._repo, e._path, function (e, t) { let n = e.copy(); return n.limitSet_ = !0, n.limit_ = t, n.viewFrom_ = "r", n }(e._queryParams, this._limit), e._orderByCalled) } } class s7 extends s1 { constructor(e) { super(), this._path = e, this.type = "orderByChild" } _apply(e) { sj(e, "orderByChild"); let t = new nv(this._path); if (nS(t)) throw Error("orderByChild: cannot pass in empty path. Use orderByValue() instead."); let n = new n8(t), i = iu(e._queryParams, n); return sF(i), new sM(e._repo, e._path, i, !0) } } class s9 extends s1 { constructor() { super(...arguments), this.type = "orderByKey" } _apply(e) { sj(e, "orderByKey"); let t = iu(e._queryParams, nq); return sF(t), new sM(e._repo, e._path, t, !0) } } class oe extends s1 { constructor() { super(...arguments), this.type = "orderByPriority" } _apply(e) { sj(e, "orderByPriority"); let t = iu(e._queryParams, nQ); return sF(t), new sM(e._repo, e._path, t, !0) } } class ot extends s1 { constructor() { super(...arguments), this.type = "orderByValue" } _apply(e) { sj(e, "orderByValue"); let t = iu(e._queryParams, n9); return sF(t), new sM(e._repo, e._path, t, !0) } } class on extends s1 { constructor(e, t) { super(), this._value = e, this._key = t, this.type = "equalTo" } _apply(e) { if (r1("equalTo", this._value, e._path, !1), e._queryParams.hasStart()) throw Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo)."); if (e._queryParams.hasEnd()) throw Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo)."); return new s2(this._value, this._key)._apply(new s4(this._value, this._key)._apply(e)) } } function oi(e, ...t) { let n = ey(e); for (let e of t) n = e._apply(n); return n } w(!p, "__referenceConstructor has already been defined"), p = sq, w(!f, "__referenceConstructor has already been defined"), f = sq; let or = {}; function os(e, t, n, i, r) { var s, o, a, l; let h, c, u, d, p = i || e.options.databaseURL; void 0 === p && (e.options.projectId || tW("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."), tF("Using default host for project ", e.options.projectId), p = `${e.options.projectId}-default-rtdb.firebaseio.com`); let f = sP(p, r), m = f.repoInfo; void 0 !== tI && tI.env && (u = tI.env.FIREBASE_DATABASE_EMULATOR_HOST), u ? (d = !0, m = (f = sP(p = `http://${u}?ns=${m.namespace}`, r)).repoInfo) : d = !f.repoInfo.secure; let g = r && d ? new t8(t8.OWNER) : new t6(e.name, e.options, t); return se("Invalid Firebase Database URL", f), nS(f.path) || tW("Database URL must point to the root of a Firebase Database (not including a child path)."), new oo((s = m, o = e, a = g, l = new t5(e.name, n), (h = or[o.name]) || (h = {}, or[o.name] = h), (c = h[s.toURLString()]) && tW("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."), c = new sa(s, !1, a, l), h[s.toURLString()] = c, c), e) } class oo { constructor(e, t) { this._repoInternal = e, this.app = t, this.type = "database", this._instanceStarted = !1 } get _repo() { return this._instanceStarted || (!function (e, t, n) { if (e.stats_ = no(e.repoInfo_), e.forceRestClient_ || ("object" == typeof window && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0) e.server_ = new im(e.repoInfo_, (t, n, i, r) => { sc(e, t, n, i, r) }, e.authTokenProvider_, e.appCheckProvider_), setTimeout(() => su(e, !0), 0); else { if (null != n) { if ("object" != typeof n) throw Error("Only objects are supported for option databaseAuthVariableOverride"); try { J(n) } catch (e) { throw Error("Invalid authOverride provided: " + e) } } e.persistentConnection_ = new nM(e.repoInfo_, t, (t, n, i, r) => { sc(e, t, n, i, r) }, t => { su(e, t) }, t => { var n; n = e, tZ(t, (e, t) => { sd(n, e, t) }) }, e.authTokenProvider_, e.appCheckProvider_, n), e.server_ = e.persistentConnection_ } e.authTokenProvider_.addTokenChangeListener(t => { e.server_.refreshAuthToken(t) }), e.appCheckProvider_.addTokenChangeListener(t => { e.server_.refreshAppCheckToken(t.token) }), e.statsReporter_ = function (e, t) { let n = e.toString(); return ns[n] || (ns[n] = t()), ns[n] }(e.repoInfo_, () => new ib(e.stats_, e.server_)), e.infoData_ = new ig, e.infoSyncTree_ = new ry({ startListening: (t, n, i, r) => { let s = [], o = e.infoData_.getNode(t._path); return o.isEmpty() || (s = rI(e.infoSyncTree_, t._path, o), setTimeout(() => { r("ok") }, 0)), s }, stopListening: () => { } }), sd(e, "connected", !1), e.serverSyncTree_ = new ry({ startListening: (t, n, i, r) => (e.server_.listen(t, i, n, (n, i) => { let s = r(n, i); sr(e.eventQueue_, t._path, s) }), []), stopListening: (t, n) => { e.server_.unlisten(t, n) } }) }(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride), this._instanceStarted = !0), this._repoInternal } get _root() { return this._rootInternal || (this._rootInternal = new sq(this._repo, ny())), this._rootInternal } _delete() { return null !== this._rootInternal && (!function (e, t) { let n = or[t]; n && n[e.key] === e || tW(`Database ${t}(${e.repoInfo_}) has already been deleted.`), s_(e), delete n[e.key] }(this._repo, this.app.name), this._repoInternal = null, this._rootInternal = null), Promise.resolve() } _checkNotDeleted(e) { null === this._rootInternal && tW("Cannot call " + e + " on a deleted database.") } } function oa() { np.IS_TRANSPORT_INITIALIZED && tz("Transport has already been initialized. Please call this function before calling ref or setting up a listener") } function ol() { oa(), nh.forceDisallow() } function oh() { oa(), nd.forceDisallow(), nh.forceAllow() } function oc(e, t) { tj(e, t) } class ou { constructor(e, t) { this.committed = e, this.snapshot = t } toJSON() { return { committed: this.committed, snapshot: this.snapshot.toJSON() } } } nM.prototype.simpleListen = function (e, t) { this.sendRequest("q", { p: e }, t) }, nM.prototype.echo = function (e, t) { this.sendRequest("echo", { d: e }, t) }, tk = e9, e0(new ew("database", (e, { instanceIdentifier: t }) => { let n = e.getProvider("app").getImmediate(); return os(n, e.getProvider("auth-internal"), e.getProvider("app-check-internal"), t) }, "PUBLIC").setMultipleInstances(!0)), ts(tC, tT, void 0), ts(tC, tT, "esm2017"); let od = new eN("@firebase/database-compat"), op = function (e) { od.warn("FIREBASE WARNING: " + e) }, of = function (e, t, n, i) { if ((!i || void 0 !== n) && "boolean" != typeof n) throw Error(ef(e, t) + "must be a boolean.") }, om = function (e, t, n) { if (!n || void 0 !== t) switch (t) { case "value": case "child_added": case "child_removed": case "child_changed": case "child_moved": break; default: throw Error(ef(e, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".') } }; class og { constructor(e) { this._delegate = e } cancel(e) { ep("OnDisconnect.cancel", 0, 1, arguments.length), em("OnDisconnect.cancel", "onComplete", e, !0); let t = this._delegate.cancel(); return e && t.then(() => e(null), t => e(t)), t } remove(e) { ep("OnDisconnect.remove", 0, 1, arguments.length), em("OnDisconnect.remove", "onComplete", e, !0); let t = this._delegate.remove(); return e && t.then(() => e(null), t => e(t)), t } set(e, t) { ep("OnDisconnect.set", 1, 2, arguments.length), em("OnDisconnect.set", "onComplete", t, !0); let n = this._delegate.set(e); return t && n.then(() => t(null), e => t(e)), n } setWithPriority(e, t, n) { ep("OnDisconnect.setWithPriority", 2, 3, arguments.length), em("OnDisconnect.setWithPriority", "onComplete", n, !0); let i = this._delegate.setWithPriority(e, t); return n && i.then(() => n(null), e => n(e)), i } update(e, t) { if (ep("OnDisconnect.update", 1, 2, arguments.length), Array.isArray(e)) { let t = {}; for (let n = 0; n < e.length; ++n)t["" + n] = e[n]; e = t, op("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.") } em("OnDisconnect.update", "onComplete", t, !0); let n = this._delegate.update(e); return t && n.then(() => t(null), e => t(e)), n } } class o_ { constructor(e, t) { this.committed = e, this.snapshot = t } toJSON() { return ep("TransactionResult.toJSON", 0, 1, arguments.length), { committed: this.committed, snapshot: this.snapshot.toJSON() } } } class ov { constructor(e, t) { this._database = e, this._delegate = t } val() { return ep("DataSnapshot.val", 0, 0, arguments.length), this._delegate.val() } exportVal() { return ep("DataSnapshot.exportVal", 0, 0, arguments.length), this._delegate.exportVal() } toJSON() { return ep("DataSnapshot.toJSON", 0, 1, arguments.length), this._delegate.toJSON() } exists() { return ep("DataSnapshot.exists", 0, 0, arguments.length), this._delegate.exists() } child(e) { return ep("DataSnapshot.child", 0, 1, arguments.length), r8("DataSnapshot.child", "path", e = String(e), !1), new ov(this._database, this._delegate.child(e)) } hasChild(e) { return ep("DataSnapshot.hasChild", 1, 1, arguments.length), r8("DataSnapshot.hasChild", "path", e, !1), this._delegate.hasChild(e) } getPriority() { return ep("DataSnapshot.getPriority", 0, 0, arguments.length), this._delegate.priority } forEach(e) { return ep("DataSnapshot.forEach", 1, 1, arguments.length), em("DataSnapshot.forEach", "action", e, !1), this._delegate.forEach(t => e(new ov(this._database, t))) } hasChildren() { return ep("DataSnapshot.hasChildren", 0, 0, arguments.length), this._delegate.hasChildren() } get key() { return this._delegate.key } numChildren() { return ep("DataSnapshot.numChildren", 0, 0, arguments.length), this._delegate.size } getRef() { return ep("DataSnapshot.ref", 0, 0, arguments.length), new ow(this._database, this._delegate.ref) } get ref() { return this.getRef() } } class oy { constructor(e, t) { this.database = e, this._delegate = t } on(e, t, n, i) { var r; ep("Query.on", 2, 4, arguments.length), em("Query.on", "callback", t, !1); let s = oy.getCancelAndContextArgs_("Query.on", n, i), o = (e, n) => { t.call(s.context, new ov(this.database, e), n) }; o.userCallback = t, o.context = s.context; let a = null == (r = s.cancel) ? void 0 : r.bind(s.context); switch (e) { case "value": return sY(this._delegate, o, a), t; case "child_added": return sJ(this._delegate, o, a), t; case "child_removed": return sZ(this._delegate, o, a), t; case "child_changed": return sQ(this._delegate, o, a), t; case "child_moved": return sX(this._delegate, o, a), t; default: throw Error(ef("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".') } } off(e, t, n) { if (ep("Query.off", 0, 3, arguments.length), om("Query.off", e, !0), em("Query.off", "callback", t, !0), eg("Query.off", "context", n, !0), t) { let i = () => { }; i.userCallback = t, i.context = n, s0(this._delegate, e, i) } else s0(this._delegate, e) } get() { return (function (e) { e = ey(e); let t = new s$(new sD(() => { })); return (function (e, t, n) { let i = function (e, t) { var n; let i = t._path, r = null; e.syncPointTree_.foreachOnPath(i, (e, t) => { let n = nP(e, i); r = r || rf(t, n) }); let s = e.syncPointTree_.get(i); s ? r = r || rf(s, ny()) : (s = new rc, e.syncPointTree_ = e.syncPointTree_.set(i, s)); let o = null != r, a = o ? new iN(r, !0, !1) : null, l = (n = e.pendingWriteTree_, i4(t._path, n)); return iL(rd(s, t, l, o ? a.getNode() : n3.EMPTY_NODE, o).viewCache_) }(e.serverSyncTree_, t); return null != i ? Promise.resolve(i) : e.server_.get(t).then(i => { let r, s = n6(i).withIndex(t._queryParams.getIndex()); if (rk(e.serverSyncTree_, t, n, !0), t._queryParams.loadsAllData()) r = rI(e.serverSyncTree_, t._path, s); else { let n = rN(e.serverSyncTree_, t); r = rT(e.serverSyncTree_, t._path, s, n) } return sr(e.eventQueue_, t._path, r), rC(e.serverSyncTree_, t, n, null, !0), s }, n => (sv(e, "get for query " + J(t) + " failed: " + n), Promise.reject(Error(n)))) })(e._repo, e, t).then(t => new sW(t, new sq(e._repo, e._path), e._queryParams.getIndex())) })(this._delegate).then(e => new ov(this.database, e)) } once(e, t, n, i) { ep("Query.once", 1, 4, arguments.length), em("Query.once", "callback", t, !0); let r = oy.getCancelAndContextArgs_("Query.once", n, i), s = new M, o = (e, n) => { let i = new ov(this.database, e); t && t.call(r.context, i, n), s.resolve(i) }; o.userCallback = t, o.context = r.context; let a = e => { r.cancel && r.cancel.call(r.context, e), s.reject(e) }; switch (e) { case "value": sY(this._delegate, o, a, { onlyOnce: !0 }); break; case "child_added": sJ(this._delegate, o, a, { onlyOnce: !0 }); break; case "child_removed": sZ(this._delegate, o, a, { onlyOnce: !0 }); break; case "child_changed": sQ(this._delegate, o, a, { onlyOnce: !0 }); break; case "child_moved": sX(this._delegate, o, a, { onlyOnce: !0 }); break; default: throw Error(ef("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".') }return s.promise } limitToFirst(e) { return ep("Query.limitToFirst", 1, 1, arguments.length), new oy(this.database, oi(this._delegate, function (e) { if ("number" != typeof e || Math.floor(e) !== e || e <= 0) throw Error("limitToFirst: First argument must be a positive integer."); return new s6(e) }(e))) } limitToLast(e) { return ep("Query.limitToLast", 1, 1, arguments.length), new oy(this.database, oi(this._delegate, function (e) { if ("number" != typeof e || Math.floor(e) !== e || e <= 0) throw Error("limitToLast: First argument must be a positive integer."); return new s8(e) }(e))) } orderByChild(e) { return ep("Query.orderByChild", 1, 1, arguments.length), new oy(this.database, oi(this._delegate, function (e) { if ("$key" === e) throw Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.'); if ("$priority" === e) throw Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.'); if ("$value" === e) throw Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.'); return r8("orderByChild", "path", e, !1), new s7(e) }(e))) } orderByKey() { return ep("Query.orderByKey", 0, 0, arguments.length), new oy(this.database, oi(this._delegate, new s9)) } orderByPriority() { return ep("Query.orderByPriority", 0, 0, arguments.length), new oy(this.database, oi(this._delegate, new oe)) } orderByValue() { return ep("Query.orderByValue", 0, 0, arguments.length), new oy(this.database, oi(this._delegate, new ot)) } startAt(e = null, t) { return ep("Query.startAt", 0, 2, arguments.length), new oy(this.database, oi(this._delegate, function (e = null, t) { return r6("startAt", "key", t, !0), new s4(e, t) }(e, t))) } startAfter(e = null, t) { return ep("Query.startAfter", 0, 2, arguments.length), new oy(this.database, oi(this._delegate, (r6("startAfter", "key", t, !0), new s5(e, t)))) } endAt(e = null, t) { return ep("Query.endAt", 0, 2, arguments.length), new oy(this.database, oi(this._delegate, (r6("endAt", "key", t, !0), new s2(e, t)))) } endBefore(e = null, t) { return ep("Query.endBefore", 0, 2, arguments.length), new oy(this.database, oi(this._delegate, (r6("endBefore", "key", t, !0), new s3(e, t)))) } equalTo(e, t) { return ep("Query.equalTo", 1, 2, arguments.length), new oy(this.database, oi(this._delegate, (r6("equalTo", "key", t, !0), new on(e, t)))) } toString() { return ep("Query.toString", 0, 0, arguments.length), this._delegate.toString() } toJSON() { return ep("Query.toJSON", 0, 1, arguments.length), this._delegate.toJSON() } isEqual(e) { if (ep("Query.isEqual", 1, 1, arguments.length), !(e instanceof oy)) throw Error("Query.isEqual failed: First argument must be an instance of firebase.database.Query."); return this._delegate.isEqual(e._delegate) } static getCancelAndContextArgs_(e, t, n) { let i = { cancel: void 0, context: void 0 }; if (t && n) i.cancel = t, em(e, "cancel", i.cancel, !0), i.context = n, eg(e, "context", i.context, !0); else if (t) if ("object" == typeof t && null !== t) i.context = t; else if ("function" == typeof t) i.cancel = t; else throw Error(ef(e, "cancelOrContext") + " must either be a cancel callback or a context object."); return i } get ref() { return new ow(this.database, new sq(this._delegate._repo, this._delegate._path)) } } class ow extends oy { constructor(e, t) { super(e, new sM(t._repo, t._path, new il, !1)), this.database = e, this._delegate = t } getKey() { return ep("Reference.key", 0, 0, arguments.length), this._delegate.key } child(e) { return ep("Reference.child", 1, 1, arguments.length), "number" == typeof e && (e = String(e)), new ow(this.database, sB(this._delegate, e)) } getParent() { ep("Reference.parent", 0, 0, arguments.length); let e = this._delegate.parent; return e ? new ow(this.database, e) : null } getRoot() { return ep("Reference.root", 0, 0, arguments.length), new ow(this.database, this._delegate.root) } set(e, t) { ep("Reference.set", 1, 2, arguments.length), em("Reference.set", "onComplete", t, !0); let n = sH(this._delegate, e); return t && n.then(() => t(null), e => t(e)), n } update(e, t) { if (ep("Reference.update", 1, 2, arguments.length), Array.isArray(e)) { let t = {}; for (let n = 0; n < e.length; ++n)t["" + n] = e[n]; e = t, op("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.") } r9("Reference.update", this._delegate._path), em("Reference.update", "onComplete", t, !0); let n = function (e, t) { r4("update", t, e._path, !1); let n = new M; return !function (e, t, n, i) { sv(e, "update", { path: t.toString(), value: n }); let r = !0, s = sh(e), o = {}; if (tZ(n, (n, i) => { r = !1, o[n] = rq(nE(t, n), n6(i), e.serverSyncTree_, s) }), r) tF("update() called with empty data.  Don't do anything."), sy(e, i, "ok", void 0); else { let r = sp(e), s = function (e, t, n, i) { var r; r = e.pendingWriteTree_, w(i > r.lastWriteId, "Stacking an older merge on top of newer ones"), r.allWrites.push({ path: t, children: n, writeId: i, visible: !0 }), r.visibleWrites = iW(r.visibleWrites, t, n), r.lastWriteId = i; let s = iF.fromObject(n); return rS(e, new iP(iI(), t, s)) }(e.serverSyncTree_, t, o, r); sn(e.eventQueue_, s), e.server_.merge(t.toString(), n, (n, s) => { let o = "ok" === n; o || tz("update at " + t + " failed: " + n); let a = rb(e.serverSyncTree_, r, !o), l = a.length > 0 ? sI(e, t) : t; sr(e.eventQueue_, l, a), sy(e, i, n, s) }), tZ(n, n => { let i = sE(e, nE(t, n)); sI(e, i) }), sr(e.eventQueue_, t, []) } }(e._repo, e._path, t, n.wrapCallback(() => { })), n.promise }(this._delegate, e); return t && n.then(() => t(null), e => t(e)), n } setWithPriority(e, t, n) { ep("Reference.setWithPriority", 2, 3, arguments.length), em("Reference.setWithPriority", "onComplete", n, !0); let i = function (e, t, n) { if (r9("setWithPriority", e._path), r1("setWithPriority", t, e._path, !1), r5("setWithPriority", n, !1), ".length" === e.key || ".keys" === e.key) throw "setWithPriority failed: " + e.key + " is a read-only object."; let i = new M; return sf(e._repo, e._path, t, n, i.wrapCallback(() => { })), i.promise }(this._delegate, e, t); return n && i.then(() => n(null), e => n(e)), i } remove(e) { var t; ep("Reference.remove", 0, 1, arguments.length), em("Reference.remove", "onComplete", e, !0); let n = (r9("remove", (t = this._delegate)._path), sH(t, null)); return e && n.then(() => e(null), t => e(t)), n } transaction(e, t, n) { ep("Reference.transaction", 1, 3, arguments.length), em("Reference.transaction", "transactionUpdate", e, !1), em("Reference.transaction", "onComplete", t, !0), of("Reference.transaction", "applyLocally", n, !0); let i = (function (e, t, n) { var i; if (r9("Reference.transaction", (e = ey(e))._path), ".length" === e.key || ".keys" === e.key) throw "Reference.transaction failed: " + e.key + " is a read-only object."; let r = null == (i = null == n ? void 0 : n.applyLocally) || i, s = new M, o = sY(e, () => { }); return !function (e, t, n, i, r, s) { sv(e, "transaction on " + t); let o = { path: t, update: n, onComplete: i, status: null, order: tA(), applyLocally: s, retryCount: 0, unwatcher: r, abortReason: null, currentWriteId: null, currentInputSnapshot: null, currentOutputSnapshotRaw: null, currentOutputSnapshotResolved: null }, a = sw(e, t, void 0); o.currentInputSnapshot = a; let l = o.update(a.val()); if (void 0 === l) o.unwatcher(), o.currentOutputSnapshotRaw = null, o.currentOutputSnapshotResolved = null, o.onComplete && o.onComplete(null, !1, o.currentInputSnapshot); else { let n; r2("transaction failed: Data returned ", l, o.path), o.status = 0; let i = rB(e.transactionQueueTree_, t), r = rH(i) || []; r.push(o), r$(i, r), "object" == typeof l && null !== l && ee(l, ".priority") ? w(r0(n = et(l, ".priority")), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.") : n = (rE(e.serverSyncTree_, t) || n3.EMPTY_NODE).getPriority().val(); let s = sh(e), h = n6(l, n), c = rW(h, a, s); o.currentOutputSnapshotRaw = h, o.currentOutputSnapshotResolved = c, o.currentWriteId = sp(e); let u = rw(e.serverSyncTree_, t, c, o.currentWriteId, o.applyLocally); sr(e.eventQueue_, t, u), sb(e, e.transactionQueueTree_) } }(e._repo, e._path, t, (t, n, i) => { let r = null; t ? s.reject(t) : (r = new sW(i, new sq(e._repo, e._path), nQ), s.resolve(new ou(n, r))) }, o, r), s.promise })(this._delegate, e, { applyLocally: n }).then(e => new o_(e.committed, new ov(this.database, e.snapshot))); return t && i.then(e => t(null, e.committed, e.snapshot), e => t(e, !1, null)), i } setPriority(e, t) { ep("Reference.setPriority", 1, 2, arguments.length), em("Reference.setPriority", "onComplete", t, !0); let n = function (e, t) { r9("setPriority", (e = ey(e))._path), r5("setPriority", t, !1); let n = new M; return sf(e._repo, nE(e._path, ".priority"), t, null, n.wrapCallback(() => { })), n.promise }(this._delegate, e); return t && n.then(() => t(null), e => t(e)), n } push(e, t) { ep("Reference.push", 0, 2, arguments.length), em("Reference.push", "onComplete", t, !0); let n = function (e, t) { let n; r9("push", (e = ey(e))._path), r1("push", t, e._path, !0); let i = sx(sl(e._repo)), r = sB(e, i), s = sB(e, i); return r.then = (n = null != t ? sH(s, t).then(() => s) : Promise.resolve(s)).then.bind(n), r.catch = n.then.bind(n, void 0), r }(this._delegate, e), i = n.then(e => new ow(this.database, e)); t && i.then(() => t(null), e => t(e)); let r = new ow(this.database, n); return r.then = i.then.bind(i), r.catch = i.catch.bind(i, void 0), r } onDisconnect() { return r9("Reference.onDisconnect", this._delegate._path), new og(new sL(this._delegate._repo, this._delegate._path)) } get key() { return this.getKey() } get parent() { return this.getParent() } get root() { return this.getRoot() } } class ob { constructor(e, t) { this._delegate = e, this.app = t, this.INTERNAL = { delete: () => this._delegate._delete(), forceWebSockets: ol, forceLongPolling: oh } } useEmulator(e, t, n = {}) { !function (e, t, n, i = {}) { var r; let s; (e = ey(e))._checkNotDeleted("useEmulator"), e._instanceStarted && tW("Cannot call useEmulator() after instance has already been initialized."); let o = e._repoInternal; o.repoInfo_.nodeAdmin ? (i.mockUserToken && tW('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'), s = new t8(t8.OWNER)) : i.mockUserToken && (s = new t8("string" == typeof i.mockUserToken ? i.mockUserToken : function (e, t) { if (e.uid) throw Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); let n = t || "demo-project", i = e.iat || 0, r = e.sub || e.user_id; if (!r) throw Error("mockUserToken must contain 'sub' or 'user_id' field!"); let s = Object.assign({ iss: `https://securetoken.google.com/${n}`, aud: n, iat: i, exp: i + 3600, auth_time: i, sub: r, user_id: r, firebase: { sign_in_provider: "custom", identities: {} } }, e); return [S(JSON.stringify({ alg: "none", type: "JWT" })), S(JSON.stringify(s)), ""].join(".") }(i.mockUserToken, e.app.options.projectId))), r = s, o.repoInfo_ = new nt(`${t}:${n}`, !1, o.repoInfo_.namespace, o.repoInfo_.webSocketOnly, o.repoInfo_.nodeAdmin, o.repoInfo_.persistenceKey, o.repoInfo_.includeNamespaceInQueryParams, !0), r && (o.authTokenProvider_ = r) }(this._delegate, e, t, n) } ref(e) { return (ep("database.ref", 0, 1, arguments.length), e instanceof ow) ? new ow(this, sV(this._delegate, e.toString())) : new ow(this, sz(this._delegate, e)) } refFromURL(e) { return ep("database.refFromURL", 1, 1, arguments.length), new ow(this, sV(this._delegate, e)) } goOffline() { var e; return ep("database.goOffline", 0, 0, arguments.length), void ((e = ey(e = this._delegate))._checkNotDeleted("goOffline"), s_(e._repo)) } goOnline() { var e, t; return ep("database.goOnline", 0, 0, arguments.length), void ((e = ey(e = this._delegate))._checkNotDeleted("goOnline"), (t = e._repo).persistentConnection_ && t.persistentConnection_.resume(so)) } } ob.ServerValue = { TIMESTAMP: { ".sv": "timestamp" }, increment: e => ({ ".sv": { increment: e } }) }; var oI = Object.freeze({ __proto__: null, initStandalone: function ({ app: e, url: t, version: n, customAuthImpl: i, customAppCheckImpl: r, namespace: s, nodeAdmin: o = !1 }) { let a; tk = n; let l = new eC("database-standalone"), h = new eI("auth-internal", l); return h.setComponent(new ew("auth-internal", () => i, "PRIVATE")), r && (a = new eI("app-check-internal", l)).setComponent(new ew("app-check-internal", () => r, "PRIVATE")), { instance: new ob(os(e, h, a, t, o), e), namespace: s } } }); let oC = ob.ServerValue; !function (e) { e.INTERNAL.registerComponent(new ew("database-compat", (e, { instanceIdentifier: t }) => { let n = e.getProvider("app-compat").getImmediate(); return new ob(e.getProvider("database").getImmediate({ identifier: t }), n) }, "PUBLIC").setServiceProps({ Reference: ow, Query: oy, Database: ob, DataSnapshot: ov, enableLogging: oc, INTERNAL: oI, ServerValue: oC }).setMultipleInstances(!0)), e.registerVersion("@firebase/database-compat", "1.0.8") }(tw); function oT(e, t) { var n = {}; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && 0 > t.indexOf(i) && (n[i] = e[i]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)0 > t.indexOf(i[r]) && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]); return n } Object.create; Object.create, "function" == typeof SuppressedError && SuppressedError; let ok = { FACEBOOK: "facebook.com", GITHUB: "github.com", GOOGLE: "google.com", PASSWORD: "password", TWITTER: "twitter.com" }, oE = { EMAIL_SIGNIN: "EMAIL_SIGNIN", PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION", VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL", VERIFY_EMAIL: "VERIFY_EMAIL" }; function oS() { return { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." } } let oP = function () { return { "admin-restricted-operation": "This operation is restricted to administrators only.", "argument-error": "", "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.", "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.", "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.", "code-expired": "The SMS code has expired. Please re-send the verification code to try again.", "cordova-not-ready": "Cordova framework is not ready.", "cors-unsupported": "This browser is not supported.", "credential-already-in-use": "This credential is already associated with a different user account.", "custom-token-mismatch": "The custom token corresponds to a different audience.", "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.", "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.", "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.", "email-change-needs-verification": "Multi-factor users must always have a verified email.", "email-already-in-use": "The email address is already in use by another account.", "emulator-config-failed": 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.', "expired-action-code": "The action code has expired.", "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.", "internal-error": "An internal AuthError has occurred.", "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.", "invalid-app-id": "The mobile app identifier is not registered for the current project.", "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.", "invalid-auth-event": "An internal AuthError has occurred.", "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.", "invalid-continue-uri": "The continue URL provided in the request is invalid.", "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.", "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.", "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.", "invalid-email": "The email address is badly formatted.", "invalid-emulator-scheme": "Emulator URL must start with a valid scheme (http:// or https://).", "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.", "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.", "invalid-credential": "The supplied auth credential is incorrect, malformed or has expired.", "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.", "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.", "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.", "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.", "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.", "wrong-password": "The password is invalid or the user does not have a password.", "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.", "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].", "invalid-provider-id": "The specified provider ID is invalid.", "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.", "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.", "invalid-tenant-id": "The Auth instance's tenant ID is invalid.", "login-blocked": "Login blocked by user-provided method: {$originalMessage}", "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.", "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.", "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.", "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.", "missing-continue-uri": "A continue URL must be provided in the request.", "missing-iframe-start": "An internal AuthError has occurred.", "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.", "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.", "missing-password": "A non-empty password must be provided", "missing-multi-factor-info": "No second factor identifier is provided.", "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.", "missing-phone-number": "To send verification codes, provide a phone number for the recipient.", "missing-verification-id": "The phone auth credential was created with an empty verification ID.", "app-deleted": "This instance of FirebaseApp has been deleted.", "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.", "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.", "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.", "network-request-failed": "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.", "no-auth-event": "An internal AuthError has occurred.", "no-such-provider": "User was not linked to an account with the given provider.", "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.", "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.", "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.', "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.", "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.", "provider-already-linked": "User can only be linked to one identity for the given provider.", "quota-exceeded": "The project's quota for this operation has been exceeded.", "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.", "redirect-operation-pending": "A redirect sign-in operation is already pending.", "rejected-credential": "The request contains malformed or mismatching credentials.", "second-factor-already-in-use": "The second factor is already enrolled on this account.", "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.", "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID", timeout: "The operation has timed out.", "user-token-expired": "The user's credential is no longer valid. The user must sign in again.", "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.", "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.", "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.", "unsupported-persistence-type": "The current environment does not support the specified persistence type.", "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.", "unverified-email": "The operation requires a verified email.", "user-cancelled": "The user did not grant your application the permissions it requested.", "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.", "user-disabled": "The user account has been disabled by an administrator.", "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.", "user-signed-out": "", "weak-password": "The password must be 6 characters long or more.", "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled.", "already-initialized": "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance.", "missing-recaptcha-token": "The reCAPTCHA token is missing when sending request to the backend.", "invalid-recaptcha-token": "The reCAPTCHA token is invalid when sending request to the backend.", "invalid-recaptcha-action": "The reCAPTCHA action is invalid when sending request to the backend.", "recaptcha-not-enabled": "reCAPTCHA Enterprise integration is not enabled for this project.", "missing-client-type": "The reCAPTCHA client type is missing when sending request to the backend.", "missing-recaptcha-version": "The reCAPTCHA version is missing when sending request to the backend.", "invalid-req-type": "Invalid request parameters.", "invalid-recaptcha-version": "The reCAPTCHA version is invalid when sending request to the backend.", "unsupported-password-policy-schema-version": "The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.", "password-does-not-meet-requirements": "The password does not meet the requirements." } }, oN = new G("auth", "Firebase", oS()), oR = new eN("@firebase/auth"); function ox(e, ...t) { oR.logLevel <= m.ERROR && oR.error(`Auth (${e9}): ${e}`, ...t) } function oA(e, ...t) { throw oj(e, ...t) } function oO(e, ...t) { return oj(e, ...t) } function oD(e, t, n) { return new G("auth", "Firebase", Object.assign(Object.assign({}, oS()), { [t]: n })).create(t, { appName: e.name }) } function oL(e) { return oD(e, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp") } function oM(e, t, n) { if (!(t instanceof n)) throw n.name !== t.constructor.name && oA(e, "argument-error"), oD(e, "argument-error", `Type of ${t.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`) } function oj(e, ...t) { if ("string" != typeof e) { let n = t[0], i = [...t.slice(1)]; return i[0] && (i[0].appName = e.name), e._errorFactory.create(n, ...i) } return oN.create(e, ...t) } function oF(e, t, ...n) { if (!e) throw oj(t, ...n) } function oU(e) { let t = "INTERNAL ASSERTION FAILED: " + e; throw ox(t), Error(t) } function oq(e, t) { e || oU(t) } function oW() { var e; return "undefined" != typeof self && (null == (e = self.location) ? void 0 : e.href) || "" } function oz() { return "http:" === oV() || "https:" === oV() } function oV() { var e; return "undefined" != typeof self && (null == (e = self.location) ? void 0 : e.protocol) || null } class oB { constructor(e, t) { var n; this.shortDelay = e, this.longDelay = t, n = "Short delay should be less than long delay!", t > e || oU(n), this.isMobile = F() || z() } get() { return !("undefined" != typeof navigator && navigator && "onLine" in navigator && "boolean" == typeof navigator.onLine && (oz() || W() || "connection" in navigator)) || navigator.onLine ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay) } } function oH(e, t) { var n, i; n = e.emulator, i = "Emulator should always be set here", n || oU(i); let { url: r } = e.emulator; return t ? `${r}${t.startsWith("/") ? t.slice(1) : t}` : r } class o$ { static initialize(e, t, n) { this.fetchImpl = e, t && (this.headersImpl = t), n && (this.responseImpl = n) } static fetch() { return this.fetchImpl ? this.fetchImpl : "undefined" != typeof self && "fetch" in self ? self.fetch : "undefined" != typeof globalThis && globalThis.fetch ? globalThis.fetch : "undefined" != typeof fetch ? fetch : void oU("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static headers() { return this.headersImpl ? this.headersImpl : "undefined" != typeof self && "Headers" in self ? self.Headers : "undefined" != typeof globalThis && globalThis.Headers ? globalThis.Headers : "undefined" != typeof Headers ? Headers : void oU("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static response() { return this.responseImpl ? this.responseImpl : "undefined" != typeof self && "Response" in self ? self.Response : "undefined" != typeof globalThis && globalThis.Response ? globalThis.Response : "undefined" != typeof Response ? Response : void oU("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } } let oG = { CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_PASSWORD: "wrong-password", MISSING_PASSWORD: "missing-password", INVALID_LOGIN_CREDENTIALS: "invalid-credential", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_REQ_TYPE: "internal-error", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests", EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements", INVALID_CODE: "invalid-verification-code", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_SESSION_INFO: "missing-verification-id", SESSION_EXPIRED: "code-expired", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", ADMIN_ONLY_OPERATION: "admin-restricted-operation", INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session", MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found", MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info", MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session", SECOND_FACTOR_EXISTS: "second-factor-already-in-use", SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded", BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error", RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled", MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token", INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token", INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action", MISSING_CLIENT_TYPE: "missing-client-type", MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version", INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version", INVALID_REQ_TYPE: "invalid-req-type" }, oK = new oB(3e4, 6e4); function oY(e, t) { return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), { tenantId: e.tenantId }) : t } async function oJ(e, t, n, i, r = {}) { return oQ(e, r, async () => { let r = {}, s = {}; i && ("GET" === t ? s = i : r = { body: JSON.stringify(i) }); let o = eo(Object.assign({ key: e.config.apiKey }, s)).slice(1), a = await e._getAdditionalHeaders(); a["Content-Type"] = "application/json", e.languageCode && (a["X-Firebase-Locale"] = e.languageCode); let l = Object.assign({ method: t, headers: a }, r); return ("undefined" == typeof navigator || "Cloudflare-Workers" !== navigator.userAgent) && (l.referrerPolicy = "no-referrer"), o$.fetch()(oZ(e, e.config.apiHost, n, o), l) }) } async function oQ(e, t, n) { e._canInitEmulator = !1; let i = Object.assign(Object.assign({}, oG), t); try { let t = new o0(e), r = await Promise.race([n(), t.promise]); t.clearNetworkTimeout(); let s = await r.json(); if ("needConfirmation" in s) throw o1(e, "account-exists-with-different-credential", s); if (r.ok && !("errorMessage" in s)) return s; { let [t, n] = (r.ok ? s.errorMessage : s.error.message).split(" : "); if ("FEDERATED_USER_ID_ALREADY_LINKED" === t) throw o1(e, "credential-already-in-use", s); if ("EMAIL_EXISTS" === t) throw o1(e, "email-already-in-use", s); if ("USER_DISABLED" === t) throw o1(e, "user-disabled", s); let o = i[t] || t.toLowerCase().replace(/[_\s]+/g, "-"); if (n) throw oD(e, o, n); oA(e, o) } } catch (t) { if (t instanceof $) throw t; oA(e, "network-request-failed", { message: String(t) }) } } async function oX(e, t, n, i, r = {}) { let s = await oJ(e, t, n, i, r); return "mfaPendingCredential" in s && oA(e, "multi-factor-auth-required", { _serverResponse: s }), s } function oZ(e, t, n, i) { let r = `${t}${n}?${i}`; return e.config.emulator ? oH(e.config, r) : `${e.config.apiScheme}://${r}` } class o0 { constructor(e) { this.auth = e, this.timer = null, this.promise = new Promise((e, t) => { this.timer = setTimeout(() => t(oO(this.auth, "network-request-failed")), oK.get()) }) } clearNetworkTimeout() { clearTimeout(this.timer) } } function o1(e, t, n) { let i = { appName: e.name }; n.email && (i.email = n.email), n.phoneNumber && (i.phoneNumber = n.phoneNumber); let r = oO(e, t, i); return r.customData._tokenResponse = n, r } function o2(e) { return void 0 !== e && void 0 !== e.getResponse } function o3(e) { return void 0 !== e && void 0 !== e.enterprise } class o4 { constructor(e) { if (this.siteKey = "", this.recaptchaEnforcementState = [], void 0 === e.recaptchaKey) throw Error("recaptchaKey undefined"); this.siteKey = e.recaptchaKey.split("/")[3], this.recaptchaEnforcementState = e.recaptchaEnforcementState } getProviderEnforcementState(e) { if (!this.recaptchaEnforcementState || 0 === this.recaptchaEnforcementState.length) return null; for (let t of this.recaptchaEnforcementState) if (t.provider && t.provider === e) switch (t.enforcementState) { case "ENFORCE": return "ENFORCE"; case "AUDIT": return "AUDIT"; case "OFF": return "OFF"; default: return "ENFORCEMENT_STATE_UNSPECIFIED" }return null } isProviderEnabled(e) { return "ENFORCE" === this.getProviderEnforcementState(e) || "AUDIT" === this.getProviderEnforcementState(e) } } async function o5(e) { return (await oJ(e, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || "" } async function o6(e, t) { return oJ(e, "GET", "/v2/recaptchaConfig", oY(e, t)) } async function o8(e, t) { return oJ(e, "POST", "/v1/accounts:delete", t) } async function o7(e, t) { return oJ(e, "POST", "/v1/accounts:update", t) } async function o9(e, t) { return oJ(e, "POST", "/v1/accounts:lookup", t) } function ae(e) { if (e) try { let t = new Date(Number(e)); if (!isNaN(t.getTime())) return t.toUTCString() } catch (e) { } } async function at(e, t = !1) { let n = ey(e), i = await n.getIdToken(t), r = ai(i); oF(r && r.exp && r.auth_time && r.iat, n.auth, "internal-error"); let s = "object" == typeof r.firebase ? r.firebase : void 0, o = null == s ? void 0 : s.sign_in_provider; return { claims: r, token: i, authTime: ae(an(r.auth_time)), issuedAtTime: ae(an(r.iat)), expirationTime: ae(an(r.exp)), signInProvider: o || null, signInSecondFactor: (null == s ? void 0 : s.sign_in_second_factor) || null } } function an(e) { return 1e3 * Number(e) } function ai(e) { let [t, n, i] = e.split("."); if (void 0 === t || void 0 === n || void 0 === i) return ox("JWT malformed, contained fewer than 3 sections"), null; try { let e = P(n); if (!e) return ox("Failed to decode base64 JWT payload"), null; return JSON.parse(e) } catch (e) { return ox("Caught error parsing JWT payload as JSON", null == e ? void 0 : e.toString()), null } } function ar(e) { let t = ai(e); return oF(t, "internal-error"), oF(void 0 !== t.exp, "internal-error"), oF(void 0 !== t.iat, "internal-error"), Number(t.exp) - Number(t.iat) } async function as(e, t, n = !1) { if (n) return t; try { return await t } catch (t) { throw t instanceof $ && function ({ code: e }) { return "auth/user-disabled" === e || "auth/user-token-expired" === e }(t) && e.auth.currentUser === e && await e.auth.signOut(), t } } class ao { constructor(e) { this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4 } _start() { this.isRunning || (this.isRunning = !0, this.schedule()) } _stop() { this.isRunning && (this.isRunning = !1, null !== this.timerId && clearTimeout(this.timerId)) } getInterval(e) { var t; if (!e) return this.errorBackoff = 3e4, Math.max(0, (null != (t = this.user.stsTokenManager.expirationTime) ? t : 0) - Date.now() - 3e5); { let e = this.errorBackoff; return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), e } } schedule(e = !1) { if (!this.isRunning) return; let t = this.getInterval(e); this.timerId = setTimeout(async () => { await this.iteration() }, t) } async iteration() { try { await this.user.getIdToken(!0) } catch (e) { (null == e ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0); return } this.schedule() } } class aa { constructor(e, t) { this.createdAt = e, this.lastLoginAt = t, this._initializeTime() } _initializeTime() { this.lastSignInTime = ae(this.lastLoginAt), this.creationTime = ae(this.createdAt) } _copy(e) { this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime() } toJSON() { return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt } } } async function al(e) { var t, n, i; let r = e.auth, s = await e.getIdToken(), o = await as(e, o9(r, { idToken: s })); oF(null == o ? void 0 : o.users.length, r, "internal-error"); let a = o.users[0]; e._notifyReloadListener(a); let l = (null == (t = a.providerUserInfo) ? void 0 : t.length) ? ac(a.providerUserInfo) : [], h = (n = e.providerData, i = l, [...n.filter(e => !i.some(t => t.providerId === e.providerId)), ...i]), c = e.isAnonymous, u = !(e.email && a.passwordHash) && !(null == h ? void 0 : h.length); Object.assign(e, { uid: a.localId, displayName: a.displayName || null, photoURL: a.photoUrl || null, email: a.email || null, emailVerified: a.emailVerified || !1, phoneNumber: a.phoneNumber || null, tenantId: a.tenantId || null, providerData: h, metadata: new aa(a.createdAt, a.lastLoginAt), isAnonymous: !!c && u }) } async function ah(e) { let t = ey(e); await al(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t) } function ac(e) { return e.map(e => { var { providerId: t } = e, n = oT(e, ["providerId"]); return { providerId: t, uid: n.rawId || "", displayName: n.displayName || null, email: n.email || null, phoneNumber: n.phoneNumber || null, photoURL: n.photoUrl || null } }) } async function au(e, t) { let n = await oQ(e, {}, async () => { let n = eo({ grant_type: "refresh_token", refresh_token: t }).slice(1), { tokenApiHost: i, apiKey: r } = e.config, s = oZ(e, i, "/v1/token", `key=${r}`), o = await e._getAdditionalHeaders(); return o["Content-Type"] = "application/x-www-form-urlencoded", o$.fetch()(s, { method: "POST", headers: o, body: n }) }); return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token } } async function ad(e, t) { return oJ(e, "POST", "/v2/accounts:revokeToken", oY(e, t)) } class ap { constructor() { this.refreshToken = null, this.accessToken = null, this.expirationTime = null } get isExpired() { return !this.expirationTime || Date.now() > this.expirationTime - 3e4 } updateFromServerResponse(e) { oF(e.idToken, "internal-error"), oF(void 0 !== e.idToken, "internal-error"), oF(void 0 !== e.refreshToken, "internal-error"); let t = "expiresIn" in e && void 0 !== e.expiresIn ? Number(e.expiresIn) : ar(e.idToken); this.updateTokensAndExpiration(e.idToken, e.refreshToken, t) } updateFromIdToken(e) { oF(0 !== e.length, "internal-error"); let t = ar(e); this.updateTokensAndExpiration(e, null, t) } async getToken(e, t = !1) { return t || !this.accessToken || this.isExpired ? (oF(this.refreshToken, e, "user-token-expired"), this.refreshToken) ? (await this.refresh(e, this.refreshToken), this.accessToken) : null : this.accessToken } clearRefreshToken() { this.refreshToken = null } async refresh(e, t) { let { accessToken: n, refreshToken: i, expiresIn: r } = await au(e, t); this.updateTokensAndExpiration(n, i, Number(r)) } updateTokensAndExpiration(e, t, n) { this.refreshToken = t || null, this.accessToken = e || null, this.expirationTime = Date.now() + 1e3 * n } static fromJSON(e, t) { let { refreshToken: n, accessToken: i, expirationTime: r } = t, s = new ap; return n && (oF("string" == typeof n, "internal-error", { appName: e }), s.refreshToken = n), i && (oF("string" == typeof i, "internal-error", { appName: e }), s.accessToken = i), r && (oF("number" == typeof r, "internal-error", { appName: e }), s.expirationTime = r), s } toJSON() { return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime } } _assign(e) { this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime } _clone() { return Object.assign(new ap, this.toJSON()) } _performRefresh() { return oU("not implemented") } } function af(e, t) { oF("string" == typeof e || void 0 === e, "internal-error", { appName: t }) } class am { constructor(e) { var { uid: t, auth: n, stsTokenManager: i } = e, r = oT(e, ["uid", "auth", "stsTokenManager"]); this.providerId = "firebase", this.proactiveRefresh = new ao(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = t, this.auth = n, this.stsTokenManager = i, this.accessToken = i.accessToken, this.displayName = r.displayName || null, this.email = r.email || null, this.emailVerified = r.emailVerified || !1, this.phoneNumber = r.phoneNumber || null, this.photoURL = r.photoURL || null, this.isAnonymous = r.isAnonymous || !1, this.tenantId = r.tenantId || null, this.providerData = r.providerData ? [...r.providerData] : [], this.metadata = new aa(r.createdAt || void 0, r.lastLoginAt || void 0) } async getIdToken(e) { let t = await as(this, this.stsTokenManager.getToken(this.auth, e)); return oF(t, this.auth, "internal-error"), this.accessToken !== t && (this.accessToken = t, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), t } getIdTokenResult(e) { return at(this, e) } reload() { return ah(this) } _assign(e) { this !== e && (oF(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map(e => Object.assign({}, e)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager)) } _clone(e) { let t = new am(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() })); return t.metadata._copy(this.metadata), t } _onReload(e) { oF(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null) } _notifyReloadListener(e) { this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e } _startProactiveRefresh() { this.proactiveRefresh._start() } _stopProactiveRefresh() { this.proactiveRefresh._stop() } async _updateTokensIfNecessary(e, t = !1) { let n = !1; e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), n = !0), t && await al(this), await this.auth._persistUserIfCurrent(this), n && this.auth._notifyListenersIfCurrent(this) } async delete() { if (e4(this.auth.app)) return Promise.reject(oL(this.auth)); let e = await this.getIdToken(); return await as(this, o8(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut() } toJSON() { return Object.assign(Object.assign({ uid: this.uid, email: this.email || void 0, emailVerified: this.emailVerified, displayName: this.displayName || void 0, isAnonymous: this.isAnonymous, photoURL: this.photoURL || void 0, phoneNumber: this.phoneNumber || void 0, tenantId: this.tenantId || void 0, providerData: this.providerData.map(e => Object.assign({}, e)), stsTokenManager: this.stsTokenManager.toJSON(), _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { apiKey: this.auth.config.apiKey, appName: this.auth.name }) } get refreshToken() { return this.stsTokenManager.refreshToken || "" } static _fromJSON(e, t) { var n, i, r, s, o, a, l, h; let c = null != (n = t.displayName) ? n : void 0, u = null != (i = t.email) ? i : void 0, d = null != (r = t.phoneNumber) ? r : void 0, p = null != (s = t.photoURL) ? s : void 0, f = null != (o = t.tenantId) ? o : void 0, m = null != (a = t._redirectEventId) ? a : void 0, g = null != (l = t.createdAt) ? l : void 0, _ = null != (h = t.lastLoginAt) ? h : void 0, { uid: v, emailVerified: y, isAnonymous: w, providerData: b, stsTokenManager: I } = t; oF(v && I, e, "internal-error"); let C = ap.fromJSON(this.name, I); oF("string" == typeof v, e, "internal-error"), af(c, e.name), af(u, e.name), oF("boolean" == typeof y, e, "internal-error"), oF("boolean" == typeof w, e, "internal-error"), af(d, e.name), af(p, e.name), af(f, e.name), af(m, e.name), af(g, e.name), af(_, e.name); let T = new am({ uid: v, auth: e, email: u, emailVerified: y, displayName: c, isAnonymous: w, photoURL: p, phoneNumber: d, tenantId: f, stsTokenManager: C, createdAt: g, lastLoginAt: _ }); return b && Array.isArray(b) && (T.providerData = b.map(e => Object.assign({}, e))), m && (T._redirectEventId = m), T } static async _fromIdTokenResponse(e, t, n = !1) { let i = new ap; i.updateFromServerResponse(t); let r = new am({ uid: t.localId, auth: e, stsTokenManager: i, isAnonymous: n }); return await al(r), r } static async _fromGetAccountInfoResponse(e, t, n) { let i = t.users[0]; oF(void 0 !== i.localId, "internal-error"); let r = void 0 !== i.providerUserInfo ? ac(i.providerUserInfo) : [], s = !(i.email && i.passwordHash) && !(null == r ? void 0 : r.length), o = new ap; o.updateFromIdToken(n); let a = new am({ uid: i.localId, auth: e, stsTokenManager: o, isAnonymous: s }); return Object.assign(a, { uid: i.localId, displayName: i.displayName || null, photoURL: i.photoUrl || null, email: i.email || null, emailVerified: i.emailVerified || !1, phoneNumber: i.phoneNumber || null, tenantId: i.tenantId || null, providerData: r, metadata: new aa(i.createdAt, i.lastLoginAt), isAnonymous: !(i.email && i.passwordHash) && !(null == r ? void 0 : r.length) }), a } } let ag = new Map; function a_(e) { var t, n; t = "Expected a class definition", e instanceof Function || oU(t); let i = ag.get(e); return i ? (n = "Instance stored in cache mismatched with class", i instanceof e || oU(n)) : (i = new e, ag.set(e, i)), i } class av { constructor() { this.type = "NONE", this.storage = {} } async _isAvailable() { return !0 } async _set(e, t) { this.storage[e] = t } async _get(e) { let t = this.storage[e]; return void 0 === t ? null : t } async _remove(e) { delete this.storage[e] } _addListener(e, t) { } _removeListener(e, t) { } } function ay(e, t, n) { return `firebase:${e}:${t}:${n}` } av.type = "NONE"; class aw { constructor(e, t, n) { this.persistence = e, this.auth = t, this.userKey = n; let { config: i, name: r } = this.auth; this.fullUserKey = ay(this.userKey, i.apiKey, r), this.fullPersistenceKey = ay("persistence", i.apiKey, r), this.boundEventHandler = t._onStorageEvent.bind(t), this.persistence._addListener(this.fullUserKey, this.boundEventHandler) } setCurrentUser(e) { return this.persistence._set(this.fullUserKey, e.toJSON()) } async getCurrentUser() { let e = await this.persistence._get(this.fullUserKey); return e ? am._fromJSON(this.auth, e) : null } removeCurrentUser() { return this.persistence._remove(this.fullUserKey) } savePersistenceForRedirect() { return this.persistence._set(this.fullPersistenceKey, this.persistence.type) } async setPersistence(e) { if (this.persistence === e) return; let t = await this.getCurrentUser(); if (await this.removeCurrentUser(), this.persistence = e, t) return this.setCurrentUser(t) } delete() { this.persistence._removeListener(this.fullUserKey, this.boundEventHandler) } static async create(e, t, n = "authUser") { if (!t.length) return new aw(a_(av), e, n); let i = (await Promise.all(t.map(async e => { if (await e._isAvailable()) return e }))).filter(e => e), r = i[0] || a_(av), s = ay(n, e.config.apiKey, e.name), o = null; for (let n of t) try { let t = await n._get(s); if (t) { let i = am._fromJSON(e, t); n !== r && (o = i), r = n; break } } catch (e) { } let a = i.filter(e => e._shouldAllowMigration); return r._shouldAllowMigration && a.length && (r = a[0], o && await r._set(s, o.toJSON()), await Promise.all(t.map(async e => { if (e !== r) try { await e._remove(s) } catch (e) { } }))), new aw(r, e, n) } } function ab(e) { let t = e.toLowerCase(); if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/")) return "Opera"; { if (ak(t)) return "IEMobile"; if (t.includes("msie") || t.includes("trident/")) return "IE"; if (t.includes("edge/")) return "Edge"; if (aI(t)) return "Firefox"; if (t.includes("silk/")) return "Silk"; if (aS(t)) return "Blackberry"; if (aP(t)) return "Webos"; if (aC(t)) return "Safari"; if ((t.includes("chrome/") || aT(t)) && !t.includes("edge/")) return "Chrome"; if (aE(t)) return "Android"; let n = e.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/); if ((null == n ? void 0 : n.length) === 2) return n[1] } return "Other" } function aI(e = j()) { return /firefox\//i.test(e) } function aC(e = j()) { let t = e.toLowerCase(); return t.includes("safari/") && !t.includes("chrome/") && !t.includes("crios/") && !t.includes("android") } function aT(e = j()) { return /crios\//i.test(e) } function ak(e = j()) { return /iemobile/i.test(e) } function aE(e = j()) { return /android/i.test(e) } function aS(e = j()) { return /blackberry/i.test(e) } function aP(e = j()) { return /webos/i.test(e) } function aN(e = j()) { return /iphone|ipad|ipod/i.test(e) || /macintosh/i.test(e) && /mobile/i.test(e) } function aR(e = j()) { return aN(e) || aE(e) || aP(e) || aS(e) || /windows phone/i.test(e) || ak(e) } function ax(e, t = []) { let n; switch (e) { case "Browser": n = ab(j()); break; case "Worker": n = `${ab(j())}-${e}`; break; default: n = e }let i = t.length ? t.join(",") : "FirebaseCore-web"; return `${n}/JsCore/${e9}/${i}` } class aA { constructor(e) { this.auth = e, this.queue = [] } pushCallback(e, t) { let n = t => new Promise((n, i) => { try { let i = e(t); n(i) } catch (e) { i(e) } }); n.onAbort = t, this.queue.push(n); let i = this.queue.length - 1; return () => { this.queue[i] = () => Promise.resolve() } } async runMiddleware(e) { if (this.auth.currentUser === e) return; let t = []; try { for (let n of this.queue) await n(e), n.onAbort && t.push(n.onAbort) } catch (e) { for (let e of (t.reverse(), t)) try { e() } catch (e) { } throw this.auth._errorFactory.create("login-blocked", { originalMessage: null == e ? void 0 : e.message }) } } } async function aO(e, t = {}) { return oJ(e, "GET", "/v2/passwordPolicy", oY(e, t)) } class aD { constructor(e) { var t, n, i, r; let s = e.customStrengthOptions; this.customStrengthOptions = {}, this.customStrengthOptions.minPasswordLength = null != (t = s.minPasswordLength) ? t : 6, s.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = s.maxPasswordLength), void 0 !== s.containsLowercaseCharacter && (this.customStrengthOptions.containsLowercaseLetter = s.containsLowercaseCharacter), void 0 !== s.containsUppercaseCharacter && (this.customStrengthOptions.containsUppercaseLetter = s.containsUppercaseCharacter), void 0 !== s.containsNumericCharacter && (this.customStrengthOptions.containsNumericCharacter = s.containsNumericCharacter), void 0 !== s.containsNonAlphanumericCharacter && (this.customStrengthOptions.containsNonAlphanumericCharacter = s.containsNonAlphanumericCharacter), this.enforcementState = e.enforcementState, "ENFORCEMENT_STATE_UNSPECIFIED" === this.enforcementState && (this.enforcementState = "OFF"), this.allowedNonAlphanumericCharacters = null != (i = null == (n = e.allowedNonAlphanumericCharacters) ? void 0 : n.join("")) ? i : "", this.forceUpgradeOnSignin = null != (r = e.forceUpgradeOnSignin) && r, this.schemaVersion = e.schemaVersion } validatePassword(e) { var t, n, i, r, s, o; let a = { isValid: !0, passwordPolicy: this }; return this.validatePasswordLengthOptions(e, a), this.validatePasswordCharacterOptions(e, a), a.isValid && (a.isValid = null == (t = a.meetsMinPasswordLength) || t), a.isValid && (a.isValid = null == (n = a.meetsMaxPasswordLength) || n), a.isValid && (a.isValid = null == (i = a.containsLowercaseLetter) || i), a.isValid && (a.isValid = null == (r = a.containsUppercaseLetter) || r), a.isValid && (a.isValid = null == (s = a.containsNumericCharacter) || s), a.isValid && (a.isValid = null == (o = a.containsNonAlphanumericCharacter) || o), a } validatePasswordLengthOptions(e, t) { let n = this.customStrengthOptions.minPasswordLength, i = this.customStrengthOptions.maxPasswordLength; n && (t.meetsMinPasswordLength = e.length >= n), i && (t.meetsMaxPasswordLength = e.length <= i) } validatePasswordCharacterOptions(e, t) { let n; this.updatePasswordCharacterOptionsStatuses(t, !1, !1, !1, !1); for (let i = 0; i < e.length; i++)n = e.charAt(i), this.updatePasswordCharacterOptionsStatuses(t, n >= "a" && n <= "z", n >= "A" && n <= "Z", n >= "0" && n <= "9", this.allowedNonAlphanumericCharacters.includes(n)) } updatePasswordCharacterOptionsStatuses(e, t, n, i, r) { this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = t)), this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = n)), this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = i)), this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = r)) } } class aL { constructor(e, t, n, i) { this.app = e, this.heartbeatServiceProvider = t, this.appCheckServiceProvider = n, this.config = i, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new aM(this), this.idTokenSubscription = new aM(this), this.beforeStateQueue = new aA(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = oN, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this._projectPasswordPolicy = null, this._tenantPasswordPolicies = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = e.name, this.clientVersion = i.sdkClientVersion } _initializeWithPersistence(e, t) { return t && (this._popupRedirectResolver = a_(t)), this._initializationPromise = this.queue(async () => { var n, i; if (!this._deleted) { if (this.persistenceManager = await aw.create(this, e), !this._deleted) { if (null == (n = this._popupRedirectResolver) ? void 0 : n._shouldInitProactively) try { await this._popupRedirectResolver._initialize(this) } catch (e) { } await this.initializeCurrentUser(t), this.lastNotifiedUid = (null == (i = this.currentUser) ? void 0 : i.uid) || null, this._deleted || (this._isInitialized = !0) } } }), this._initializationPromise } async _onStorageEvent() { if (this._deleted) return; let e = await this.assertedPersistence.getCurrentUser(); if (this.currentUser || e) { if (this.currentUser && e && this.currentUser.uid === e.uid) { this._currentUser._assign(e), await this.currentUser.getIdToken(); return } await this._updateCurrentUser(e, !0) } } async initializeCurrentUserFromIdToken(e) { try { let t = await o9(this, { idToken: e }), n = await am._fromGetAccountInfoResponse(this, t, e); await this.directlySetCurrentUser(n) } catch (e) { console.warn("FirebaseServerApp could not login user with provided authIdToken: ", e), await this.directlySetCurrentUser(null) } } async initializeCurrentUser(e) { var t; if (e4(this.app)) { let e = this.app.settings.authIdToken; return e ? new Promise(t => { setTimeout(() => this.initializeCurrentUserFromIdToken(e).then(t, t)) }) : this.directlySetCurrentUser(null) } let n = await this.assertedPersistence.getCurrentUser(), i = n, r = !1; if (e && this.config.authDomain) { await this.getOrInitRedirectPersistenceManager(); let n = null == (t = this.redirectUser) ? void 0 : t._redirectEventId, s = null == i ? void 0 : i._redirectEventId, o = await this.tryRedirectSignIn(e); (!n || n === s) && (null == o ? void 0 : o.user) && (i = o.user, r = !0) } if (!i) return this.directlySetCurrentUser(null); if (!i._redirectEventId) { if (r) try { await this.beforeStateQueue.runMiddleware(i) } catch (e) { i = n, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e)) } return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null) } return (oF(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId) ? this.directlySetCurrentUser(i) : this.reloadAndSetCurrentUserOrClear(i) } async tryRedirectSignIn(e) { let t = null; try { t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0) } catch (e) { await this._setRedirectUser(null) } return t } async reloadAndSetCurrentUserOrClear(e) { try { await al(e) } catch (e) { if ((null == e ? void 0 : e.code) !== "auth/network-request-failed") return this.directlySetCurrentUser(null) } return this.directlySetCurrentUser(e) } useDeviceLanguage() { this.languageCode = function () { if ("undefined" == typeof navigator) return null; let e = navigator; return e.languages && e.languages[0] || e.language || null }() } async _delete() { this._deleted = !0 } async updateCurrentUser(e) { if (e4(this.app)) return Promise.reject(oL(this)); let t = e ? ey(e) : null; return t && oF(t.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(t && t._clone(this)) } async _updateCurrentUser(e, t = !1) { if (!this._deleted) return e && oF(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), t || await this.beforeStateQueue.runMiddleware(e), this.queue(async () => { await this.directlySetCurrentUser(e), this.notifyAuthListeners() }) } async signOut() { return e4(this.app) ? Promise.reject(oL(this)) : (await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0)) } setPersistence(e) { return e4(this.app) ? Promise.reject(oL(this)) : this.queue(async () => { await this.assertedPersistence.setPersistence(a_(e)) }) } _getRecaptchaConfig() { return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId] } async validatePassword(e) { this._getPasswordPolicyInternal() || await this._updatePasswordPolicy(); let t = this._getPasswordPolicyInternal(); return t.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : t.validatePassword(e) } _getPasswordPolicyInternal() { return null === this.tenantId ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId] } async _updatePasswordPolicy() { let e = new aD(await aO(this)); null === this.tenantId ? this._projectPasswordPolicy = e : this._tenantPasswordPolicies[this.tenantId] = e } _getPersistence() { return this.assertedPersistence.persistence.type } _updateErrorMap(e) { this._errorFactory = new G("auth", "Firebase", e()) } onAuthStateChanged(e, t, n) { return this.registerStateListener(this.authStateSubscription, e, t, n) } beforeAuthStateChanged(e, t) { return this.beforeStateQueue.pushCallback(e, t) } onIdTokenChanged(e, t, n) { return this.registerStateListener(this.idTokenSubscription, e, t, n) } authStateReady() { return new Promise((e, t) => { if (this.currentUser) e(); else { let n = this.onAuthStateChanged(() => { n(), e() }, t) } }) } async revokeAccessToken(e) { if (this.currentUser) { let t = { providerId: "apple.com", tokenType: "ACCESS_TOKEN", token: e, idToken: await this.currentUser.getIdToken() }; null != this.tenantId && (t.tenantId = this.tenantId), await ad(this, t) } } toJSON() { var e; return { apiKey: this.config.apiKey, authDomain: this.config.authDomain, appName: this.name, currentUser: null == (e = this._currentUser) ? void 0 : e.toJSON() } } async _setRedirectUser(e, t) { let n = await this.getOrInitRedirectPersistenceManager(t); return null === e ? n.removeCurrentUser() : n.setCurrentUser(e) } async getOrInitRedirectPersistenceManager(e) { if (!this.redirectPersistenceManager) { let t = e && a_(e) || this._popupRedirectResolver; oF(t, this, "argument-error"), this.redirectPersistenceManager = await aw.create(this, [a_(t._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser() } return this.redirectPersistenceManager } async _redirectUserForId(e) { var t, n; return (this._isInitialized && await this.queue(async () => { }), (null == (t = this._currentUser) ? void 0 : t._redirectEventId) === e) ? this._currentUser : (null == (n = this.redirectUser) ? void 0 : n._redirectEventId) === e ? this.redirectUser : null } async _persistUserIfCurrent(e) { if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e)) } _notifyListenersIfCurrent(e) { e === this.currentUser && this.notifyAuthListeners() } _key() { return `${this.config.authDomain}:${this.config.apiKey}:${this.name}` } _startProactiveRefresh() { this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh() } _stopProactiveRefresh() { this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh() } get _currentUser() { return this.currentUser } notifyAuthListeners() { var e, t; if (!this._isInitialized) return; this.idTokenSubscription.next(this.currentUser); let n = null != (t = null == (e = this.currentUser) ? void 0 : e.uid) ? t : null; this.lastNotifiedUid !== n && (this.lastNotifiedUid = n, this.authStateSubscription.next(this.currentUser)) } registerStateListener(e, t, n, i) { if (this._deleted) return () => { }; let r = "function" == typeof t ? t : t.next.bind(t), s = !1, o = this._isInitialized ? Promise.resolve() : this._initializationPromise; if (oF(o, this, "internal-error"), o.then(() => { s || r(this.currentUser) }), "function" == typeof t) { let r = e.addObserver(t, n, i); return () => { s = !0, r() } } { let n = e.addObserver(t); return () => { s = !0, n() } } } async directlySetCurrentUser(e) { this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser() } queue(e) { return this.operations = this.operations.then(e, e), this.operations } get assertedPersistence() { return oF(this.persistenceManager, this, "internal-error"), this.persistenceManager } _logFramework(e) { !e || this.frameworks.includes(e) || (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = ax(this.config.clientPlatform, this._getFrameworks())) } _getFrameworks() { return this.frameworks } async _getAdditionalHeaders() { var e; let t = { "X-Client-Version": this.clientVersion }; this.app.options.appId && (t["X-Firebase-gmpid"] = this.app.options.appId); let n = await (null == (e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) ? void 0 : e.getHeartbeatsHeader()); n && (t["X-Firebase-Client"] = n); let i = await this._getAppCheckToken(); return i && (t["X-Firebase-AppCheck"] = i), t } async _getAppCheckToken() { var e; let t = await (null == (e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) ? void 0 : e.getToken()); return (null == t ? void 0 : t.error) && function (e, ...t) { oR.logLevel <= m.WARN && oR.warn(`Auth (${e9}): ${e}`, ...t) }(`Error while retrieving App Check token: ${t.error}`), null == t ? void 0 : t.token } } class aM { constructor(e) { this.auth = e, this.observer = null, this.addObserver = ec(e => this.observer = e) } get next() { return oF(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer) } } let aj = { async loadJS() { throw Error("Unable to load external scripts") }, recaptchaV2Script: "", recaptchaEnterpriseScript: "", gapiScript: "" }; function aF(e) { return aj.loadJS(e) } function aU(e) { return `__${e}${Math.floor(1e6 * Math.random())}` } class aq { constructor(e) { this.type = "recaptcha-enterprise", this.auth = ey(e) } async verify(e = "verify", t = !1) { async function n(e) { if (!t) { if (null == e.tenantId && null != e._agentRecaptchaConfig) return e._agentRecaptchaConfig.siteKey; if (null != e.tenantId && void 0 !== e._tenantRecaptchaConfigs[e.tenantId]) return e._tenantRecaptchaConfigs[e.tenantId].siteKey } return new Promise(async (t, n) => { o6(e, { clientType: "CLIENT_TYPE_WEB", version: "RECAPTCHA_ENTERPRISE" }).then(i => { if (void 0 === i.recaptchaKey) n(Error("recaptcha Enterprise site key undefined")); else { let n = new o4(i); return null == e.tenantId ? e._agentRecaptchaConfig = n : e._tenantRecaptchaConfigs[e.tenantId] = n, t(n.siteKey) } }).catch(e => { n(e) }) }) } function i(t, n, i) { let r = window.grecaptcha; o3(r) ? r.enterprise.ready(() => { r.enterprise.execute(t, { action: e }).then(e => { n(e) }).catch(() => { n("NO_RECAPTCHA") }) }) : i(Error("No reCAPTCHA enterprise script loaded.")) } return new Promise((e, r) => { n(this.auth).then(n => { if (!t && o3(window.grecaptcha)) i(n, e, r); else { if ("undefined" == typeof window) return void r(Error("RecaptchaVerifier is only supported in browser")); let t = aj.recaptchaEnterpriseScript; 0 !== t.length && (t += n), aF(t).then(() => { i(n, e, r) }).catch(e => { r(e) }) } }).catch(e => { r(e) }) }) } } async function aW(e, t, n, i = !1) { let r, s = new aq(e); try { r = await s.verify(n) } catch (e) { r = await s.verify(n, !0) } let o = Object.assign({}, t); return i ? Object.assign(o, { captchaResp: r }) : Object.assign(o, { captchaResponse: r }), Object.assign(o, { clientType: "CLIENT_TYPE_WEB" }), Object.assign(o, { recaptchaVersion: "RECAPTCHA_ENTERPRISE" }), o } async function az(e, t, n, i) { var r; if (null == (r = e._getRecaptchaConfig()) || !r.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")) return i(e, t).catch(async r => { if ("auth/missing-recaptcha-token" !== r.code) return Promise.reject(r); { console.log(`${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`); let r = await aW(e, t, n, "getOobCode" === n); return i(e, r) } }); { let r = await aW(e, t, n, "getOobCode" === n); return i(e, r) } } function aV(e) { let t = e.indexOf(":"); return t < 0 ? "" : e.substr(0, t + 1) } function aB(e) { if (!e) return null; let t = Number(e); return isNaN(t) ? null : t } class aH { constructor(e, t) { this.providerId = e, this.signInMethod = t } toJSON() { return oU("not implemented") } _getIdTokenResponse(e) { return oU("not implemented") } _linkToIdToken(e, t) { return oU("not implemented") } _getReauthenticationResolver(e) { return oU("not implemented") } } async function a$(e, t) { return oJ(e, "POST", "/v1/accounts:resetPassword", oY(e, t)) } async function aG(e, t) { return oJ(e, "POST", "/v1/accounts:update", t) } async function aK(e, t) { return oJ(e, "POST", "/v1/accounts:signUp", t) } async function aY(e, t) { return oJ(e, "POST", "/v1/accounts:update", oY(e, t)) } async function aJ(e, t) { return oX(e, "POST", "/v1/accounts:signInWithPassword", oY(e, t)) } async function aQ(e, t) { return oJ(e, "POST", "/v1/accounts:sendOobCode", oY(e, t)) } async function aX(e, t) { return aQ(e, t) } async function aZ(e, t) { return aQ(e, t) } async function a0(e, t) { return aQ(e, t) } async function a1(e, t) { return aQ(e, t) } async function a2(e, t) { return oX(e, "POST", "/v1/accounts:signInWithEmailLink", oY(e, t)) } async function a3(e, t) { return oX(e, "POST", "/v1/accounts:signInWithEmailLink", oY(e, t)) } class a4 extends aH { constructor(e, t, n, i = null) { super("password", n), this._email = e, this._password = t, this._tenantId = i } static _fromEmailAndPassword(e, t) { return new a4(e, t, "password") } static _fromEmailAndCode(e, t, n = null) { return new a4(e, t, "emailLink", n) } toJSON() { return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId } } static fromJSON(e) { let t = "string" == typeof e ? JSON.parse(e) : e; if ((null == t ? void 0 : t.email) && (null == t ? void 0 : t.password)) { if ("password" === t.signInMethod) return this._fromEmailAndPassword(t.email, t.password); else if ("emailLink" === t.signInMethod) return this._fromEmailAndCode(t.email, t.password, t.tenantId) } return null } async _getIdTokenResponse(e) { switch (this.signInMethod) { case "password": return az(e, { returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" }, "signInWithPassword", aJ); case "emailLink": return a2(e, { email: this._email, oobCode: this._password }); default: oA(e, "internal-error") } } async _linkToIdToken(e, t) { switch (this.signInMethod) { case "password": return az(e, { idToken: t, returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" }, "signUpPassword", aK); case "emailLink": return a3(e, { idToken: t, email: this._email, oobCode: this._password }); default: oA(e, "internal-error") } } _getReauthenticationResolver(e) { return this._getIdTokenResponse(e) } } async function a5(e, t) { return oX(e, "POST", "/v1/accounts:signInWithIdp", oY(e, t)) } class a6 extends aH { constructor() { super(...arguments), this.pendingToken = null } static _fromParams(e) { let t = new a6(e.providerId, e.signInMethod); return e.idToken || e.accessToken ? (e.idToken && (t.idToken = e.idToken), e.accessToken && (t.accessToken = e.accessToken), e.nonce && !e.pendingToken && (t.nonce = e.nonce), e.pendingToken && (t.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (t.accessToken = e.oauthToken, t.secret = e.oauthTokenSecret) : oA("argument-error"), t } toJSON() { return { idToken: this.idToken, accessToken: this.accessToken, secret: this.secret, nonce: this.nonce, pendingToken: this.pendingToken, providerId: this.providerId, signInMethod: this.signInMethod } } static fromJSON(e) { let t = "string" == typeof e ? JSON.parse(e) : e, { providerId: n, signInMethod: i } = t, r = oT(t, ["providerId", "signInMethod"]); if (!n || !i) return null; let s = new a6(n, i); return s.idToken = r.idToken || void 0, s.accessToken = r.accessToken || void 0, s.secret = r.secret, s.nonce = r.nonce, s.pendingToken = r.pendingToken || null, s } _getIdTokenResponse(e) { return a5(e, this.buildRequest()) } _linkToIdToken(e, t) { let n = this.buildRequest(); return n.idToken = t, a5(e, n) } _getReauthenticationResolver(e) { let t = this.buildRequest(); return t.autoCreate = !1, a5(e, t) } buildRequest() { let e = { requestUri: "http://localhost", returnSecureToken: !0 }; if (this.pendingToken) e.pendingToken = this.pendingToken; else { let t = {}; this.idToken && (t.id_token = this.idToken), this.accessToken && (t.access_token = this.accessToken), this.secret && (t.oauth_token_secret = this.secret), t.providerId = this.providerId, this.nonce && !this.pendingToken && (t.nonce = this.nonce), e.postBody = eo(t) } return e } } async function a8(e, t) { return oJ(e, "POST", "/v1/accounts:sendVerificationCode", oY(e, t)) } async function a7(e, t) { return oX(e, "POST", "/v1/accounts:signInWithPhoneNumber", oY(e, t)) } async function a9(e, t) { let n = await oX(e, "POST", "/v1/accounts:signInWithPhoneNumber", oY(e, t)); if (n.temporaryProof) throw o1(e, "account-exists-with-different-credential", n); return n } let le = { USER_NOT_FOUND: "user-not-found" }; async function lt(e, t) { return oX(e, "POST", "/v1/accounts:signInWithPhoneNumber", oY(e, Object.assign(Object.assign({}, t), { operation: "REAUTH" })), le) } class ln extends aH { constructor(e) { super("phone", "phone"), this.params = e } static _fromVerification(e, t) { return new ln({ verificationId: e, verificationCode: t }) } static _fromTokenResponse(e, t) { return new ln({ phoneNumber: e, temporaryProof: t }) } _getIdTokenResponse(e) { return a7(e, this._makeVerificationRequest()) } _linkToIdToken(e, t) { return a9(e, Object.assign({ idToken: t }, this._makeVerificationRequest())) } _getReauthenticationResolver(e) { return lt(e, this._makeVerificationRequest()) } _makeVerificationRequest() { let { temporaryProof: e, phoneNumber: t, verificationId: n, verificationCode: i } = this.params; return e && t ? { temporaryProof: e, phoneNumber: t } : { sessionInfo: n, code: i } } toJSON() { let e = { providerId: this.providerId }; return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (e.verificationCode = this.params.verificationCode), this.params.verificationId && (e.verificationId = this.params.verificationId), e } static fromJSON(e) { "string" == typeof e && (e = JSON.parse(e)); let { verificationId: t, verificationCode: n, phoneNumber: i, temporaryProof: r } = e; return n || t || i || r ? new ln({ verificationId: t, verificationCode: n, phoneNumber: i, temporaryProof: r }) : null } } class li { constructor(e) { var t, n, i, r, s, o; let a = ea(el(e)), l = null != (t = a.apiKey) ? t : null, h = null != (n = a.oobCode) ? n : null, c = function (e) { switch (e) { case "recoverEmail": return "RECOVER_EMAIL"; case "resetPassword": return "PASSWORD_RESET"; case "signIn": return "EMAIL_SIGNIN"; case "verifyEmail": return "VERIFY_EMAIL"; case "verifyAndChangeEmail": return "VERIFY_AND_CHANGE_EMAIL"; case "revertSecondFactorAddition": return "REVERT_SECOND_FACTOR_ADDITION"; default: return null } }(null != (i = a.mode) ? i : null); oF(l && h && c, "argument-error"), this.apiKey = l, this.operation = c, this.code = h, this.continueUrl = null != (r = a.continueUrl) ? r : null, this.languageCode = null != (s = a.languageCode) ? s : null, this.tenantId = null != (o = a.tenantId) ? o : null } static parseLink(e) { let t = function (e) { let t = ea(el(e)).link, n = t ? ea(el(t)).deep_link_id : null, i = ea(el(e)).deep_link_id; return (i ? ea(el(i)).link : null) || i || n || t || e }(e); try { return new li(t) } catch (e) { return null } } } class lr { constructor() { this.providerId = lr.PROVIDER_ID } static credential(e, t) { return a4._fromEmailAndPassword(e, t) } static credentialWithLink(e, t) { let n = li.parseLink(t); return oF(n, "argument-error"), a4._fromEmailAndCode(e, n.code, n.tenantId) } } lr.PROVIDER_ID = "password", lr.EMAIL_PASSWORD_SIGN_IN_METHOD = "password", lr.EMAIL_LINK_SIGN_IN_METHOD = "emailLink"; class ls { constructor(e) { this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {} } setDefaultLanguage(e) { this.defaultLanguageCode = e } setCustomParameters(e) { return this.customParameters = e, this } getCustomParameters() { return this.customParameters } } class lo extends ls { constructor() { super(...arguments), this.scopes = [] } addScope(e) { return this.scopes.includes(e) || this.scopes.push(e), this } getScopes() { return [...this.scopes] } } class la extends lo { static credentialFromJSON(e) { let t = "string" == typeof e ? JSON.parse(e) : e; return oF("providerId" in t && "signInMethod" in t, "argument-error"), a6._fromParams(t) } credential(e) { return this._credential(Object.assign(Object.assign({}, e), { nonce: e.rawNonce })) } _credential(e) { return oF(e.idToken || e.accessToken, "argument-error"), a6._fromParams(Object.assign(Object.assign({}, e), { providerId: this.providerId, signInMethod: this.providerId })) } static credentialFromResult(e) { return la.oauthCredentialFromTaggedObject(e) } static credentialFromError(e) { return la.oauthCredentialFromTaggedObject(e.customData || {}) } static oauthCredentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; let { oauthIdToken: t, oauthAccessToken: n, oauthTokenSecret: i, pendingToken: r, nonce: s, providerId: o } = e; if (!n && !i && !t && !r || !o) return null; try { return new la(o)._credential({ idToken: t, accessToken: n, nonce: s, pendingToken: r }) } catch (e) { return null } } } class ll extends lo { constructor() { super("facebook.com") } static credential(e) { return a6._fromParams({ providerId: ll.PROVIDER_ID, signInMethod: ll.FACEBOOK_SIGN_IN_METHOD, accessToken: e }) } static credentialFromResult(e) { return ll.credentialFromTaggedObject(e) } static credentialFromError(e) { return ll.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null; try { return ll.credential(e.oauthAccessToken) } catch (e) { return null } } } ll.FACEBOOK_SIGN_IN_METHOD = "facebook.com", ll.PROVIDER_ID = "facebook.com"; class lh extends lo { constructor() { super("google.com"), this.addScope("profile") } static credential(e, t) { return a6._fromParams({ providerId: lh.PROVIDER_ID, signInMethod: lh.GOOGLE_SIGN_IN_METHOD, idToken: e, accessToken: t }) } static credentialFromResult(e) { return lh.credentialFromTaggedObject(e) } static credentialFromError(e) { return lh.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; let { oauthIdToken: t, oauthAccessToken: n } = e; if (!t && !n) return null; try { return lh.credential(t, n) } catch (e) { return null } } } lh.GOOGLE_SIGN_IN_METHOD = "google.com", lh.PROVIDER_ID = "google.com"; class lc extends lo { constructor() { super("github.com") } static credential(e) { return a6._fromParams({ providerId: lc.PROVIDER_ID, signInMethod: lc.GITHUB_SIGN_IN_METHOD, accessToken: e }) } static credentialFromResult(e) { return lc.credentialFromTaggedObject(e) } static credentialFromError(e) { return lc.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null; try { return lc.credential(e.oauthAccessToken) } catch (e) { return null } } } lc.GITHUB_SIGN_IN_METHOD = "github.com", lc.PROVIDER_ID = "github.com"; class lu extends aH { constructor(e, t) { super(e, e), this.pendingToken = t } _getIdTokenResponse(e) { return a5(e, this.buildRequest()) } _linkToIdToken(e, t) { let n = this.buildRequest(); return n.idToken = t, a5(e, n) } _getReauthenticationResolver(e) { let t = this.buildRequest(); return t.autoCreate = !1, a5(e, t) } toJSON() { return { signInMethod: this.signInMethod, providerId: this.providerId, pendingToken: this.pendingToken } } static fromJSON(e) { let { providerId: t, signInMethod: n, pendingToken: i } = "string" == typeof e ? JSON.parse(e) : e; return t && n && i && t === n ? new lu(t, i) : null } static _create(e, t) { return new lu(e, t) } buildRequest() { return { requestUri: "http://localhost", returnSecureToken: !0, pendingToken: this.pendingToken } } } class ld extends ls { constructor(e) { oF(e.startsWith("saml."), "argument-error"), super(e) } static credentialFromResult(e) { return ld.samlCredentialFromTaggedObject(e) } static credentialFromError(e) { return ld.samlCredentialFromTaggedObject(e.customData || {}) } static credentialFromJSON(e) { let t = lu.fromJSON(e); return oF(t, "argument-error"), t } static samlCredentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; let { pendingToken: t, providerId: n } = e; if (!t || !n) return null; try { return lu._create(n, t) } catch (e) { return null } } } class lp extends lo { constructor() { super("twitter.com") } static credential(e, t) { return a6._fromParams({ providerId: lp.PROVIDER_ID, signInMethod: lp.TWITTER_SIGN_IN_METHOD, oauthToken: e, oauthTokenSecret: t }) } static credentialFromResult(e) { return lp.credentialFromTaggedObject(e) } static credentialFromError(e) { return lp.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; let { oauthAccessToken: t, oauthTokenSecret: n } = e; if (!t || !n) return null; try { return lp.credential(t, n) } catch (e) { return null } } } async function lf(e, t) { return oX(e, "POST", "/v1/accounts:signUp", oY(e, t)) } lp.TWITTER_SIGN_IN_METHOD = "twitter.com", lp.PROVIDER_ID = "twitter.com"; class lm { constructor(e) { this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType } static async _fromIdTokenResponse(e, t, n, i = !1) { return new lm({ user: await am._fromIdTokenResponse(e, n, i), providerId: lg(n), _tokenResponse: n, operationType: t }) } static async _forOperation(e, t, n) { return await e._updateTokensIfNecessary(n, !0), new lm({ user: e, providerId: lg(n), _tokenResponse: n, operationType: t }) } } function lg(e) { return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null } async function l_(e) { var t; if (e4(e.app)) return Promise.reject(oL(e)); let n = ey(e); if (await n._initializationPromise, null == (t = n.currentUser) ? void 0 : t.isAnonymous) return new lm({ user: n.currentUser, providerId: null, operationType: "signIn" }); let i = await lf(n, { returnSecureToken: !0 }), r = await lm._fromIdTokenResponse(n, "signIn", i, !0); return await n._updateCurrentUser(r.user), r } class lv extends $ { constructor(e, t, n, i) { var r; super(t.code, t.message), this.operationType = n, this.user = i, Object.setPrototypeOf(this, lv.prototype), this.customData = { appName: e.name, tenantId: null != (r = e.tenantId) ? r : void 0, _serverResponse: t.customData._serverResponse, operationType: n } } static _fromErrorAndOperation(e, t, n, i) { return new lv(e, t, n, i) } } function ly(e, t, n, i) { return ("reauthenticate" === t ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch(n => { if ("auth/multi-factor-auth-required" === n.code) throw lv._fromErrorAndOperation(e, n, t, i); throw n }) } function lw(e) { return new Set(e.map(({ providerId: e }) => e).filter(e => !!e)) } async function lb(e, t) { let n = ey(e); await lC(!0, n, t); let { providerUserInfo: i } = await o7(n.auth, { idToken: await n.getIdToken(), deleteProvider: [t] }), r = lw(i || []); return n.providerData = n.providerData.filter(e => r.has(e.providerId)), r.has("phone") || (n.phoneNumber = null), await n.auth._persistUserIfCurrent(n), n } async function lI(e, t, n = !1) { let i = await as(e, t._linkToIdToken(e.auth, await e.getIdToken()), n); return lm._forOperation(e, "link", i) } async function lC(e, t, n) { await al(t), oF(lw(t.providerData).has(n) === e, t.auth, !1 === e ? "provider-already-linked" : "no-such-provider") } async function lT(e, t, n = !1) { let { auth: i } = e; if (e4(i.app)) return Promise.reject(oL(i)); let r = "reauthenticate"; try { let s = await as(e, ly(i, r, t, e), n); oF(s.idToken, i, "internal-error"); let o = ai(s.idToken); oF(o, i, "internal-error"); let { sub: a } = o; return oF(e.uid === a, i, "user-mismatch"), lm._forOperation(e, r, s) } catch (e) { throw (null == e ? void 0 : e.code) === "auth/user-not-found" && oA(i, "user-mismatch"), e } } async function lk(e, t, n = !1) { if (e4(e.app)) return Promise.reject(oL(e)); let i = "signIn", r = await ly(e, i, t), s = await lm._fromIdTokenResponse(e, i, r); return n || await e._updateCurrentUser(s.user), s } async function lE(e, t) { return lk(ey(e), t) } async function lS(e, t) { let n = ey(e); return await lC(!1, n, t.providerId), lI(n, t) } async function lP(e, t) { return lT(ey(e), t) } async function lN(e, t) { return oX(e, "POST", "/v1/accounts:signInWithCustomToken", oY(e, t)) } async function lR(e, t) { if (e4(e.app)) return Promise.reject(oL(e)); let n = ey(e), i = await lN(n, { token: t, returnSecureToken: !0 }), r = await lm._fromIdTokenResponse(n, "signIn", i); return await n._updateCurrentUser(r.user), r } class lx { constructor(e, t) { this.factorId = e, this.uid = t.mfaEnrollmentId, this.enrollmentTime = new Date(t.enrolledAt).toUTCString(), this.displayName = t.displayName } static _fromServerResponse(e, t) { return "phoneInfo" in t ? lA._fromServerResponse(e, t) : "totpInfo" in t ? lO._fromServerResponse(e, t) : oA(e, "internal-error") } } class lA extends lx { constructor(e) { super("phone", e), this.phoneNumber = e.phoneInfo } static _fromServerResponse(e, t) { return new lA(t) } } class lO extends lx { constructor(e) { super("totp", e) } static _fromServerResponse(e, t) { return new lO(t) } } function lD(e, t, n) { var i; oF((null == (i = n.url) ? void 0 : i.length) > 0, e, "invalid-continue-uri"), oF(void 0 === n.dynamicLinkDomain || n.dynamicLinkDomain.length > 0, e, "invalid-dynamic-link-domain"), t.continueUrl = n.url, t.dynamicLinkDomain = n.dynamicLinkDomain, t.canHandleCodeInApp = n.handleCodeInApp, n.iOS && (oF(n.iOS.bundleId.length > 0, e, "missing-ios-bundle-id"), t.iOSBundleId = n.iOS.bundleId), n.android && (oF(n.android.packageName.length > 0, e, "missing-android-pkg-name"), t.androidInstallApp = n.android.installApp, t.androidMinimumVersionCode = n.android.minimumVersion, t.androidPackageName = n.android.packageName) } async function lL(e) { let t = ey(e); t._getPasswordPolicyInternal() && await t._updatePasswordPolicy() } async function lM(e, t, n) { let i = ey(e), r = { requestType: "PASSWORD_RESET", email: t, clientType: "CLIENT_TYPE_WEB" }; n && lD(i, r, n), await az(i, r, "getOobCode", aZ) } async function lj(e, t, n) { await a$(ey(e), { oobCode: t, newPassword: n }).catch(async t => { throw "auth/password-does-not-meet-requirements" === t.code && lL(e), t }) } async function lF(e, t) { await aY(ey(e), { oobCode: t }) } async function lU(e, t) { let n = ey(e), i = await a$(n, { oobCode: t }), r = i.requestType; switch (oF(r, n, "internal-error"), r) { case "EMAIL_SIGNIN": break; case "VERIFY_AND_CHANGE_EMAIL": oF(i.newEmail, n, "internal-error"); break; case "REVERT_SECOND_FACTOR_ADDITION": oF(i.mfaInfo, n, "internal-error"); default: oF(i.email, n, "internal-error") }let s = null; return i.mfaInfo && (s = lx._fromServerResponse(ey(n), i.mfaInfo)), { data: { email: ("VERIFY_AND_CHANGE_EMAIL" === i.requestType ? i.newEmail : i.email) || null, previousEmail: ("VERIFY_AND_CHANGE_EMAIL" === i.requestType ? i.email : i.newEmail) || null, multiFactorInfo: s }, operation: r } } async function lq(e, t) { let { data: n } = await lU(ey(e), t); return n.email } async function lW(e, t, n) { if (e4(e.app)) return Promise.reject(oL(e)); let i = ey(e), r = az(i, { returnSecureToken: !0, email: t, password: n, clientType: "CLIENT_TYPE_WEB" }, "signUpPassword", lf), s = await r.catch(t => { throw "auth/password-does-not-meet-requirements" === t.code && lL(e), t }), o = await lm._fromIdTokenResponse(i, "signIn", s); return await i._updateCurrentUser(o.user), o } async function lz(e, t, n) { let i = ey(e), r = { requestType: "EMAIL_SIGNIN", email: t, clientType: "CLIENT_TYPE_WEB" }; oF(n.handleCodeInApp, i, "argument-error"), n && lD(i, r, n), await az(i, r, "getOobCode", a0) } async function lV(e, t, n) { if (e4(e.app)) return Promise.reject(oL(e)); let i = ey(e), r = lr.credentialWithLink(t, n || oW()); return oF(r._tenantId === (i.tenantId || null), i, "tenant-id-mismatch"), lE(i, r) } async function lB(e, t) { return oJ(e, "POST", "/v1/accounts:createAuthUri", oY(e, t)) } async function lH(e, t) { let n = oz() ? oW() : "http://localhost", { signinMethods: i } = await lB(ey(e), { identifier: t, continueUri: n }); return i || [] } async function l$(e, t) { let n = ey(e), i = { requestType: "VERIFY_EMAIL", idToken: await e.getIdToken() }; t && lD(n.auth, i, t); let { email: r } = await aX(n.auth, i); r !== e.email && await e.reload() } async function lG(e, t, n) { let i = ey(e), r = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: await e.getIdToken(), newEmail: t }; n && lD(i.auth, r, n); let { email: s } = await a1(i.auth, r); s !== e.email && await e.reload() } async function lK(e, t) { return oJ(e, "POST", "/v1/accounts:update", t) } async function lY(e, { displayName: t, photoURL: n }) { if (void 0 === t && void 0 === n) return; let i = ey(e), r = await i.getIdToken(), s = await as(i, lK(i.auth, { idToken: r, displayName: t, photoUrl: n, returnSecureToken: !0 })); i.displayName = s.displayName || null, i.photoURL = s.photoUrl || null; let o = i.providerData.find(({ providerId: e }) => "password" === e); o && (o.displayName = i.displayName, o.photoURL = i.photoURL), await i._updateTokensIfNecessary(s) } async function lJ(e, t, n) { let { auth: i } = e, r = { idToken: await e.getIdToken(), returnSecureToken: !0 }; t && (r.email = t), n && (r.password = n); let s = await as(e, aG(i, r)); await e._updateTokensIfNecessary(s, !0) } class lQ { constructor(e, t, n = {}) { this.isNewUser = e, this.providerId = t, this.profile = n } } class lX extends lQ { constructor(e, t, n, i) { super(e, t, n), this.username = i } } class lZ extends lQ { constructor(e, t) { super(e, "facebook.com", t) } } class l0 extends lX { constructor(e, t) { super(e, "github.com", t, "string" == typeof (null == t ? void 0 : t.login) ? null == t ? void 0 : t.login : null) } } class l1 extends lQ { constructor(e, t) { super(e, "google.com", t) } } class l2 extends lX { constructor(e, t, n) { super(e, "twitter.com", t, n) } } class l3 { constructor(e, t, n) { this.type = e, this.credential = t, this.user = n } static _fromIdtoken(e, t) { return new l3("enroll", e, t) } static _fromMfaPendingCredential(e) { return new l3("signin", e) } toJSON() { return { multiFactorSession: { ["enroll" === this.type ? "idToken" : "pendingCredential"]: this.credential } } } static fromJSON(e) { var t, n; if (null == e ? void 0 : e.multiFactorSession) { if (null == (t = e.multiFactorSession) ? void 0 : t.pendingCredential) return l3._fromMfaPendingCredential(e.multiFactorSession.pendingCredential); else if (null == (n = e.multiFactorSession) ? void 0 : n.idToken) return l3._fromIdtoken(e.multiFactorSession.idToken) } return null } } class l4 { constructor(e, t, n) { this.session = e, this.hints = t, this.signInResolver = n } static _fromError(e, t) { let n = ey(e), i = t.customData._serverResponse, r = (i.mfaInfo || []).map(e => lx._fromServerResponse(n, e)); oF(i.mfaPendingCredential, n, "internal-error"); let s = l3._fromMfaPendingCredential(i.mfaPendingCredential); return new l4(s, r, async e => { let r = await e._process(n, s); delete i.mfaInfo, delete i.mfaPendingCredential; let o = Object.assign(Object.assign({}, i), { idToken: r.idToken, refreshToken: r.refreshToken }); switch (t.operationType) { case "signIn": let a = await lm._fromIdTokenResponse(n, t.operationType, o); return await n._updateCurrentUser(a.user), a; case "reauthenticate": return oF(t.user, n, "internal-error"), lm._forOperation(t.user, t.operationType, o); default: oA(n, "internal-error") } }) } async resolveSignIn(e) { return this.signInResolver(e) } } class l5 { constructor(e) { this.user = e, this.enrolledFactors = [], e._onReload(t => { t.mfaInfo && (this.enrolledFactors = t.mfaInfo.map(t => lx._fromServerResponse(e.auth, t))) }) } static _fromUser(e) { return new l5(e) } async getSession() { return l3._fromIdtoken(await this.user.getIdToken(), this.user) } async enroll(e, t) { let n = await this.getSession(), i = await as(this.user, e._process(this.user.auth, n, t)); return await this.user._updateTokensIfNecessary(i), this.user.reload() } async unenroll(e) { let t = "string" == typeof e ? e : e.uid, n = await this.user.getIdToken(); try { var i, r; let e = await as(this.user, (i = this.user.auth, r = { idToken: n, mfaEnrollmentId: t }, oJ(i, "POST", "/v2/accounts/mfaEnrollment:withdraw", oY(i, r)))); this.enrolledFactors = this.enrolledFactors.filter(({ uid: e }) => e !== t), await this.user._updateTokensIfNecessary(e), await this.user.reload() } catch (e) { throw e } } } let l6 = new WeakMap, l8 = "__sak"; class l7 { constructor(e, t) { this.storageRetriever = e, this.type = t } _isAvailable() { try { if (!this.storage) return Promise.resolve(!1); return this.storage.setItem(l8, "1"), this.storage.removeItem(l8), Promise.resolve(!0) } catch (e) { return Promise.resolve(!1) } } _set(e, t) { return this.storage.setItem(e, JSON.stringify(t)), Promise.resolve() } _get(e) { let t = this.storage.getItem(e); return Promise.resolve(t ? JSON.parse(t) : null) } _remove(e) { return this.storage.removeItem(e), Promise.resolve() } get storage() { return this.storageRetriever() } } class l9 extends l7 { constructor() { super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (e, t) => this.onStorageEvent(e, t), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.fallbackToPolling = aR(), this._shouldAllowMigration = !0 } forAllChangedKeys(e) { for (let t of Object.keys(this.listeners)) { let n = this.storage.getItem(t), i = this.localCache[t]; n !== i && e(t, i, n) } } onStorageEvent(e, t = !1) { if (!e.key) return void this.forAllChangedKeys((e, t, n) => { this.notifyListeners(e, n) }); let n = e.key; t ? this.detachListener() : this.stopPolling(); let i = () => { let e = this.storage.getItem(n); (t || this.localCache[n] !== e) && this.notifyListeners(n, e) }, r = this.storage.getItem(n); V() && 10 === document.documentMode && r !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, 10) : i() } notifyListeners(e, t) { this.localCache[e] = t; let n = this.listeners[e]; if (n) for (let e of Array.from(n)) e(t ? JSON.parse(t) : t) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(() => { this.forAllChangedKeys((e, t, n) => { this.onStorageEvent(new StorageEvent("storage", { key: e, oldValue: t, newValue: n }), !0) }) }, 1e3) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } attachListener() { window.addEventListener("storage", this.boundEventHandler) } detachListener() { window.removeEventListener("storage", this.boundEventHandler) } _addListener(e, t) { 0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(t) } _removeListener(e, t) { this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling()) } async _set(e, t) { await super._set(e, t), this.localCache[e] = JSON.stringify(t) } async _get(e) { let t = await super._get(e); return this.localCache[e] = JSON.stringify(t), t } async _remove(e) { await super._remove(e), delete this.localCache[e] } } l9.type = "LOCAL"; class he extends l7 { constructor() { super(() => window.sessionStorage, "SESSION") } _addListener(e, t) { } _removeListener(e, t) { } } he.type = "SESSION"; class ht { constructor(e) { this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this) } static _getInstance(e) { let t = this.receivers.find(t => t.isListeningto(e)); if (t) return t; let n = new ht(e); return this.receivers.push(n), n } isListeningto(e) { return this.eventTarget === e } async handleEvent(e) { let { eventId: t, eventType: n, data: i } = e.data, r = this.handlersMap[n]; if (!(null == r ? void 0 : r.size)) return; e.ports[0].postMessage({ status: "ack", eventId: t, eventType: n }); let s = Array.from(r).map(async t => t(e.origin, i)), o = await Promise.all(s.map(async e => { try { let t = await e; return { fulfilled: !0, value: t } } catch (e) { return { fulfilled: !1, reason: e } } })); e.ports[0].postMessage({ status: "done", eventId: t, eventType: n, response: o }) } _subscribe(e, t) { 0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(t) } _unsubscribe(e, t) { this.handlersMap[e] && t && this.handlersMap[e].delete(t), t && 0 !== this.handlersMap[e].size || delete this.handlersMap[e], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler) } } function hn(e = "", t = 10) { let n = ""; for (let e = 0; e < t; e++)n += Math.floor(10 * Math.random()); return e + n } ht.receivers = []; class hi { constructor(e) { this.target = e, this.handlers = new Set } removeMessageHandler(e) { e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e) } async _send(e, t, n = 50) { let i, r, s = "undefined" != typeof MessageChannel ? new MessageChannel : null; if (!s) throw Error("connection_unavailable"); return new Promise((o, a) => { let l = hn("", 20); s.port1.start(); let h = setTimeout(() => { a(Error("unsupported_event")) }, n); r = { messageChannel: s, onMessage(e) { if (e.data.eventId === l) switch (e.data.status) { case "ack": clearTimeout(h), i = setTimeout(() => { a(Error("timeout")) }, 3e3); break; case "done": clearTimeout(i), o(e.data.response); break; default: clearTimeout(h), clearTimeout(i), a(Error("invalid_response")) } } }, this.handlers.add(r), s.port1.addEventListener("message", r.onMessage), this.target.postMessage({ eventType: e, eventId: l, data: t }, [s.port2]) }).finally(() => { r && this.removeMessageHandler(r) }) } } function hr() { return window } function hs() { return void 0 !== hr().WorkerGlobalScope && "function" == typeof hr().importScripts } async function ho() { if (!(null == navigator ? void 0 : navigator.serviceWorker)) return null; try { return (await navigator.serviceWorker.ready).active } catch (e) { return null } } let ha = "firebaseLocalStorageDb", hl = "firebaseLocalStorage", hh = "fbase_key"; class hc { constructor(e) { this.request = e } toPromise() { return new Promise((e, t) => { this.request.addEventListener("success", () => { e(this.request.result) }), this.request.addEventListener("error", () => { t(this.request.error) }) }) } } function hu(e, t) { return e.transaction([hl], t ? "readwrite" : "readonly").objectStore(hl) } function hd() { let e = indexedDB.open(ha, 1); return new Promise((t, n) => { e.addEventListener("error", () => { n(e.error) }), e.addEventListener("upgradeneeded", () => { let t = e.result; try { t.createObjectStore(hl, { keyPath: hh }) } catch (e) { n(e) } }), e.addEventListener("success", async () => { let n = e.result; n.objectStoreNames.contains(hl) ? t(n) : (n.close(), await new hc(indexedDB.deleteDatabase(ha)).toPromise(), t(await hd())) }) }) } async function hp(e, t, n) { return new hc(hu(e, !0).put({ [hh]: t, value: n })).toPromise() } async function hf(e, t) { let n = hu(e, !1).get(t), i = await new hc(n).toPromise(); return void 0 === i ? null : i.value } function hm(e, t) { return new hc(hu(e, !0).delete(t)).toPromise() } class hg { constructor() { this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => { }, () => { }) } async _openDb() { return this.db || (this.db = await hd()), this.db } async _withRetries(e) { let t = 0; for (; ;)try { let t = await this._openDb(); return await e(t) } catch (e) { if (t++ > 3) throw e; this.db && (this.db.close(), this.db = void 0) } } async initializeServiceWorkerMessaging() { return hs() ? this.initializeReceiver() : this.initializeSender() } async initializeReceiver() { this.receiver = ht._getInstance(hs() ? self : null), this.receiver._subscribe("keyChanged", async (e, t) => ({ keyProcessed: (await this._poll()).includes(t.key) })), this.receiver._subscribe("ping", async (e, t) => ["keyChanged"]) } async initializeSender() { var e, t; if (this.activeServiceWorker = await ho(), !this.activeServiceWorker) return; this.sender = new hi(this.activeServiceWorker); let n = await this.sender._send("ping", {}, 800); n && (null == (e = n[0]) ? void 0 : e.fulfilled) && (null == (t = n[0]) ? void 0 : t.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = !0) } async notifyServiceWorker(e) { var t; if (this.sender && this.activeServiceWorker && ((null == (t = null == navigator ? void 0 : navigator.serviceWorker) ? void 0 : t.controller) || null) === this.activeServiceWorker) try { await this.sender._send("keyChanged", { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50) } catch (e) { } } async _isAvailable() { try { if (!indexedDB) return !1; let e = await hd(); return await hp(e, l8, "1"), await hm(e, l8), !0 } catch (e) { } return !1 } async _withPendingWrite(e) { this.pendingWrites++; try { await e() } finally { this.pendingWrites-- } } async _set(e, t) { return this._withPendingWrite(async () => (await this._withRetries(n => hp(n, e, t)), this.localCache[e] = t, this.notifyServiceWorker(e))) } async _get(e) { let t = await this._withRetries(t => hf(t, e)); return this.localCache[e] = t, t } async _remove(e) { return this._withPendingWrite(async () => (await this._withRetries(t => hm(t, e)), delete this.localCache[e], this.notifyServiceWorker(e))) } async _poll() { let e = await this._withRetries(e => new hc(hu(e, !1).getAll()).toPromise()); if (!e || 0 !== this.pendingWrites) return []; let t = [], n = new Set; if (0 !== e.length) for (let { fbase_key: i, value: r } of e) n.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(r) && (this.notifyListeners(i, r), t.push(i)); for (let e of Object.keys(this.localCache)) this.localCache[e] && !n.has(e) && (this.notifyListeners(e, null), t.push(e)); return t } notifyListeners(e, t) { this.localCache[e] = t; let n = this.listeners[e]; if (n) for (let e of Array.from(n)) e(t) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), 800) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } _addListener(e, t) { 0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(t) } _removeListener(e, t) { this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && this.stopPolling() } } hg.type = "LOCAL"; class h_ { constructor(e) { this.auth = e, this.counter = 1e12, this._widgets = new Map } render(e, t) { let n = this.counter; return this._widgets.set(n, new hv(e, this.auth.name, t || {})), this.counter++, n } reset(e) { var t; let n = e || 1e12; null == (t = this._widgets.get(n)) || t.delete(), this._widgets.delete(n) } getResponse(e) { var t; return (null == (t = this._widgets.get(e || 1e12)) ? void 0 : t.getResponse()) || "" } async execute(e) { var t; return null == (t = this._widgets.get(e || 1e12)) || t.execute(), "" } } class hv { constructor(e, t, n) { this.params = n, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => { this.execute() }; let i = "string" == typeof e ? document.getElementById(e) : e; oF(i, "argument-error", { appName: t }), this.container = i, this.isVisible = "invisible" !== this.params.size, this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler) } getResponse() { return this.checkIfDeleted(), this.responseToken } delete() { this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler) } execute() { this.checkIfDeleted(), this.timerId || (this.timerId = window.setTimeout(() => { this.responseToken = function (e) { let t = [], n = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let e = 0; e < 50; e++)t.push(n.charAt(Math.floor(Math.random() * n.length))); return t.join("") }(50); let { callback: e, "expired-callback": t } = this.params; if (e) try { e(this.responseToken) } catch (e) { } this.timerId = window.setTimeout(() => { if (this.timerId = null, this.responseToken = null, t) try { t() } catch (e) { } this.isVisible && this.execute() }, 6e4) }, 500)) } checkIfDeleted() { if (this.deleted) throw Error("reCAPTCHA mock was already deleted!") } } let hy = aU("rcb"), hw = new oB(3e4, 6e4); class hb { constructor() { var e; this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !!(null == (e = hr().grecaptcha) ? void 0 : e.render) } load(e, t = "") { var n; return (oF((n = t).length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(n), e, "argument-error"), this.shouldResolveImmediately(t) && o2(hr().grecaptcha)) ? Promise.resolve(hr().grecaptcha) : new Promise((n, i) => { let r = hr().setTimeout(() => { i(oO(e, "network-request-failed")) }, hw.get()); hr()[hy] = () => { hr().clearTimeout(r), delete hr()[hy]; let s = hr().grecaptcha; if (!s || !o2(s)) return void i(oO(e, "internal-error")); let o = s.render; s.render = (e, t) => { let n = o(e, t); return this.counter++, n }, this.hostLanguage = t, n(s) }, aF(`${aj.recaptchaV2Script}?${eo({ onload: hy, render: "explicit", hl: t })}`).catch(() => { clearTimeout(r), i(oO(e, "internal-error")) }) }) } clearedOneInstance() { this.counter-- } shouldResolveImmediately(e) { var t; return !!(null == (t = hr().grecaptcha) ? void 0 : t.render) && (e === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded) } } class hI { async load(e) { return new h_(e) } clearedOneInstance() { } } let hC = "recaptcha", hT = { theme: "light", type: "image" }; class hk { constructor(e, t, n = Object.assign({}, hT)) { this.parameters = n, this.type = hC, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = new Set, this.renderPromise = null, this.recaptcha = null, this.auth = ey(e), this.isInvisible = "invisible" === this.parameters.size, oF("undefined" != typeof document, this.auth, "operation-not-supported-in-this-environment"); let i = "string" == typeof t ? document.getElementById(t) : t; oF(i, this.auth, "argument-error"), this.container = i, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new hI : new hb, this.validateStartingState() } async verify() { this.assertNotDestroyed(); let e = await this.render(), t = this.getAssertedRecaptcha(), n = t.getResponse(e); return n || new Promise(n => { let i = e => { e && (this.tokenChangeListeners.delete(i), n(e)) }; this.tokenChangeListeners.add(i), this.isInvisible && t.execute(e) }) } render() { try { this.assertNotDestroyed() } catch (e) { return Promise.reject(e) } return this.renderPromise || (this.renderPromise = this.makeRenderPromise().catch(e => { throw this.renderPromise = null, e })), this.renderPromise } _reset() { this.assertNotDestroyed(), null !== this.widgetId && this.getAssertedRecaptcha().reset(this.widgetId) } clear() { this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach(e => { this.container.removeChild(e) }) } validateStartingState() { oF(!this.parameters.sitekey, this.auth, "argument-error"), oF(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"), oF("undefined" != typeof document, this.auth, "operation-not-supported-in-this-environment") } makeTokenCallback(e) { return t => { if (this.tokenChangeListeners.forEach(e => e(t)), "function" == typeof e) e(t); else if ("string" == typeof e) { let n = hr()[e]; "function" == typeof n && n(t) } } } assertNotDestroyed() { oF(!this.destroyed, this.auth, "internal-error") } async makeRenderPromise() { if (await this.init(), !this.widgetId) { let e = this.container; if (!this.isInvisible) { let t = document.createElement("div"); e.appendChild(t), e = t } this.widgetId = this.getAssertedRecaptcha().render(e, this.parameters) } return this.widgetId } async init() { let e; oF(oz() && !hs(), this.auth, "internal-error"), await (e = null, new Promise(t => { if ("complete" === document.readyState) return void t(); e = () => t(), window.addEventListener("load", e) }).catch(t => { throw e && window.removeEventListener("load", e), t })), this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0); let t = await o5(this.auth); oF(t, this.auth, "internal-error"), this.parameters.sitekey = t } getAssertedRecaptcha() { return oF(this.recaptcha, this.auth, "internal-error"), this.recaptcha } } class hE { constructor(e, t) { this.verificationId = e, this.onConfirmation = t } confirm(e) { let t = ln._fromVerification(this.verificationId, e); return this.onConfirmation(t) } } async function hS(e, t, n) { if (e4(e.app)) return Promise.reject(oL(e)); let i = ey(e); return new hE(await hR(i, t, ey(n)), e => lE(i, e)) } async function hP(e, t, n) { let i = ey(e); return await lC(!1, i, "phone"), new hE(await hR(i.auth, t, ey(n)), e => lS(i, e)) } async function hN(e, t, n) { let i = ey(e); return e4(i.auth.app) ? Promise.reject(oL(i.auth)) : new hE(await hR(i.auth, t, ey(n)), e => lP(i, e)) } async function hR(e, t, n) { var i, r, s; let o = await n.verify(); try { let a; if (oF("string" == typeof o, e, "argument-error"), oF(n.type === hC, e, "argument-error"), a = "string" == typeof t ? { phoneNumber: t } : t, "session" in a) { let t = a.session; if ("phoneNumber" in a) return oF("enroll" === t.type, e, "internal-error"), (await (r = { idToken: t.credential, phoneEnrollmentInfo: { phoneNumber: a.phoneNumber, recaptchaToken: o } }, oJ(e, "POST", "/v2/accounts/mfaEnrollment:start", oY(e, r)))).phoneSessionInfo.sessionInfo; { oF("signin" === t.type, e, "internal-error"); let n = (null == (i = a.multiFactorHint) ? void 0 : i.uid) || a.multiFactorUid; return oF(n, e, "missing-multi-factor-info"), (await (s = { mfaPendingCredential: t.credential, mfaEnrollmentId: n, phoneSignInInfo: { recaptchaToken: o } }, oJ(e, "POST", "/v2/accounts/mfaSignIn:start", oY(e, s)))).phoneResponseInfo.sessionInfo } } { let { sessionInfo: t } = await a8(e, { phoneNumber: a.phoneNumber, recaptchaToken: o }); return t } } finally { n._reset() } } async function hx(e, t) { let n = ey(e); if (e4(n.auth.app)) return Promise.reject(oL(n.auth)); await lI(n, t) } class hA { constructor(e) { this.providerId = hA.PROVIDER_ID, this.auth = ey(e) } verifyPhoneNumber(e, t) { return hR(this.auth, e, ey(t)) } static credential(e, t) { return ln._fromVerification(e, t) } static credentialFromResult(e) { return hA.credentialFromTaggedObject(e) } static credentialFromError(e) { return hA.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; let { phoneNumber: t, temporaryProof: n } = e; return t && n ? ln._fromTokenResponse(t, n) : null } } function hO(e, t) { return t ? a_(t) : (oF(e._popupRedirectResolver, e, "argument-error"), e._popupRedirectResolver) } hA.PROVIDER_ID = "phone", hA.PHONE_SIGN_IN_METHOD = "phone"; class hD extends aH { constructor(e) { super("custom", "custom"), this.params = e } _getIdTokenResponse(e) { return a5(e, this._buildIdpRequest()) } _linkToIdToken(e, t) { return a5(e, this._buildIdpRequest(t)) } _getReauthenticationResolver(e) { return a5(e, this._buildIdpRequest()) } _buildIdpRequest(e) { let t = { requestUri: this.params.requestUri, sessionId: this.params.sessionId, postBody: this.params.postBody, tenantId: this.params.tenantId, pendingToken: this.params.pendingToken, returnSecureToken: !0, returnIdpCredential: !0 }; return e && (t.idToken = e), t } } function hL(e) { return lk(e.auth, new hD(e), e.bypassAuthState) } function hM(e) { let { auth: t, user: n } = e; return oF(n, t, "internal-error"), lT(n, new hD(e), e.bypassAuthState) } async function hj(e) { let { auth: t, user: n } = e; return oF(n, t, "internal-error"), lI(n, new hD(e), e.bypassAuthState) } class hF { constructor(e, t, n, i, r = !1) { this.auth = e, this.resolver = n, this.user = i, this.bypassAuthState = r, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(t) ? t : [t] } execute() { return new Promise(async (e, t) => { this.pendingPromise = { resolve: e, reject: t }; try { this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this) } catch (e) { this.reject(e) } }) } async onAuthEvent(e) { let { urlResponse: t, sessionId: n, postBody: i, tenantId: r, error: s, type: o } = e; if (s) return void this.reject(s); let a = { auth: this.auth, requestUri: t, sessionId: n, tenantId: r || void 0, postBody: i || void 0, user: this.user, bypassAuthState: this.bypassAuthState }; try { this.resolve(await this.getIdpTask(o)(a)) } catch (e) { this.reject(e) } } onError(e) { this.reject(e) } getIdpTask(e) { switch (e) { case "signInViaPopup": case "signInViaRedirect": return hL; case "linkViaPopup": case "linkViaRedirect": return hj; case "reauthViaPopup": case "reauthViaRedirect": return hM; default: oA(this.auth, "internal-error") } } resolve(e) { var t, n; t = this.pendingPromise, n = "Pending promise was never set", t || oU(n), this.pendingPromise.resolve(e), this.unregisterAndCleanUp() } reject(e) { var t, n; t = this.pendingPromise, n = "Pending promise was never set", t || oU(n), this.pendingPromise.reject(e), this.unregisterAndCleanUp() } unregisterAndCleanUp() { this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp() } } let hU = new oB(2e3, 1e4); async function hq(e, t, n) { if (e4(e.app)) return Promise.reject(oO(e, "operation-not-supported-in-this-environment")); let i = ey(e); oM(e, t, ls); let r = hO(i, n); return new hV(i, "signInViaPopup", t, r).executeNotNull() } async function hW(e, t, n) { let i = ey(e); if (e4(i.auth.app)) return Promise.reject(oO(i.auth, "operation-not-supported-in-this-environment")); oM(i.auth, t, ls); let r = hO(i.auth, n); return new hV(i.auth, "reauthViaPopup", t, r, i).executeNotNull() } async function hz(e, t, n) { let i = ey(e); oM(i.auth, t, ls); let r = hO(i.auth, n); return new hV(i.auth, "linkViaPopup", t, r, i).executeNotNull() } class hV extends hF { constructor(e, t, n, i, r) { super(e, t, i, r), this.provider = n, this.authWindow = null, this.pollId = null, hV.currentPopupAction && hV.currentPopupAction.cancel(), hV.currentPopupAction = this } async executeNotNull() { let e = await this.execute(); return oF(e, this.auth, "internal-error"), e } async onExecution() { var e, t; e = 1 === this.filter.length, t = "Popup operations only handle one event", e || oU(t); let n = hn(); this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], n), this.authWindow.associatedEvent = n, this.resolver._originValidation(this.auth).catch(e => { this.reject(e) }), this.resolver._isIframeWebStorageSupported(this.auth, e => { e || this.reject(oO(this.auth, "web-storage-unsupported")) }), this.pollUserCancellation() } get eventId() { var e; return (null == (e = this.authWindow) ? void 0 : e.associatedEvent) || null } cancel() { this.reject(oO(this.auth, "cancelled-popup-request")) } cleanUp() { this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, hV.currentPopupAction = null } pollUserCancellation() { let e = () => { var t, n; if (null == (n = null == (t = this.authWindow) ? void 0 : t.window) ? void 0 : n.closed) { this.pollId = window.setTimeout(() => { this.pollId = null, this.reject(oO(this.auth, "popup-closed-by-user")) }, 8e3); return } this.pollId = window.setTimeout(e, hU.get()) }; e() } } hV.currentPopupAction = null; let hB = new Map; class hH extends hF { constructor(e, t, n = !1) { super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], t, void 0, n), this.eventId = null } async execute() { let e = hB.get(this.auth._key()); if (!e) { try { let t = await h$(this.resolver, this.auth) ? await super.execute() : null; e = () => Promise.resolve(t) } catch (t) { e = () => Promise.reject(t) } hB.set(this.auth._key(), e) } return this.bypassAuthState || hB.set(this.auth._key(), () => Promise.resolve(null)), e() } async onAuthEvent(e) { if ("signInViaRedirect" === e.type) return super.onAuthEvent(e); if ("unknown" === e.type) return void this.resolve(null); if (e.eventId) { let t = await this.auth._redirectUserForId(e.eventId); if (t) return this.user = t, super.onAuthEvent(e); this.resolve(null) } } async onExecution() { } cleanUp() { } } async function h$(e, t) { let n = hJ(t), i = hY(e); if (!await i._isAvailable()) return !1; let r = await i._get(n) === "true"; return await i._remove(n), r } async function hG(e, t) { return hY(e)._set(hJ(t), "true") } function hK(e, t) { hB.set(e._key(), t) } function hY(e) { return a_(e._redirectPersistence) } function hJ(e) { return ay("pendingRedirect", e.config.apiKey, e.name) } async function hQ(e, t, n) { if (e4(e.app)) return Promise.reject(oL(e)); let i = ey(e); oM(e, t, ls), await i._initializationPromise; let r = hO(i, n); return await hG(r, i), r._openRedirect(i, t, "signInViaRedirect") } async function hX(e, t, n) { let i = ey(e); if (oM(i.auth, t, ls), e4(i.auth.app)) return Promise.reject(oL(i.auth)); await i.auth._initializationPromise; let r = hO(i.auth, n); await hG(r, i.auth); let s = await h2(i); return r._openRedirect(i.auth, t, "reauthViaRedirect", s) } async function hZ(e, t, n) { let i = ey(e); oM(i.auth, t, ls), await i.auth._initializationPromise; let r = hO(i.auth, n); await lC(!1, i, t.providerId), await hG(r, i.auth); let s = await h2(i); return r._openRedirect(i.auth, t, "linkViaRedirect", s) } async function h0(e, t) { return await ey(e)._initializationPromise, h1(e, t, !1) } async function h1(e, t, n = !1) { if (e4(e.app)) return Promise.reject(oL(e)); let i = ey(e), r = hO(i, t), s = new hH(i, r, n), o = await s.execute(); return o && !n && (delete o.user._redirectEventId, await i._persistUserIfCurrent(o.user), await i._setRedirectUser(null, t)), o } async function h2(e) { let t = hn(`${e.uid}:::`); return e._redirectEventId = t, await e.auth._setRedirectUser(e), await e.auth._persistUserIfCurrent(e), t } class h3 { constructor(e) { this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now() } registerConsumer(e) { this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null) } unregisterConsumer(e) { this.consumers.delete(e) } onEvent(e) { if (this.hasEventBeenHandled(e)) return !1; let t = !1; return this.consumers.forEach(n => { this.isEventForConsumer(e, n) && (t = !0, this.sendToConsumer(e, n), this.saveEventToCache(e)) }), this.hasHandledPotentialRedirect || !function (e) { switch (e.type) { case "signInViaRedirect": case "linkViaRedirect": case "reauthViaRedirect": return !0; case "unknown": return h5(e); default: return !1 } }(e) || (this.hasHandledPotentialRedirect = !0, t || (this.queuedRedirectEvent = e, t = !0)), t } sendToConsumer(e, t) { var n; if (e.error && !h5(e)) { let i = (null == (n = e.error.code) ? void 0 : n.split("auth/")[1]) || "internal-error"; t.onError(oO(this.auth, i)) } else t.onAuthEvent(e) } isEventForConsumer(e, t) { let n = null === t.eventId || !!e.eventId && e.eventId === t.eventId; return t.filter.includes(e.type) && n } hasEventBeenHandled(e) { return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(h4(e)) } saveEventToCache(e) { this.cachedEventUids.add(h4(e)), this.lastProcessedEventTime = Date.now() } } function h4(e) { return [e.type, e.eventId, e.sessionId, e.tenantId].filter(e => e).join("-") } function h5({ type: e, error: t }) { return "unknown" === e && (null == t ? void 0 : t.code) === "auth/no-auth-event" } async function h6(e, t = {}) { return oJ(e, "GET", "/v1/projects", t) } let h8 = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, h7 = /^https?/; async function h9(e) { if (e.config.emulator) return; let { authorizedDomains: t } = await h6(e); for (let e of t) try { if (function (e) { let t = oW(), { protocol: n, hostname: i } = new URL(t); if (e.startsWith("chrome-extension://")) { let r = new URL(e); return "" === r.hostname && "" === i ? "chrome-extension:" === n && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : "chrome-extension:" === n && r.hostname === i } if (!h7.test(n)) return !1; if (h8.test(e)) return i === e; let r = e.replace(/\./g, "\\."); return RegExp("^(.+\\." + r + "|" + r + ")$", "i").test(i) }(e)) return } catch (e) { } oA(e, "unauthorized-domain") } let ce = new oB(3e4, 6e4); function ct() { let e = hr().___jsl; if (null == e ? void 0 : e.H) { for (let t of Object.keys(e.H)) if (e.H[t].r = e.H[t].r || [], e.H[t].L = e.H[t].L || [], e.H[t].r = [...e.H[t].L], e.CP) for (let t = 0; t < e.CP.length; t++)e.CP[t] = null } } let cn = null, ci = new oB(5e3, 15e3), cr = { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" }, "aria-hidden": "true", tabindex: "-1" }, cs = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]); async function co(e) { let t = await (cn = cn || new Promise((t, n) => { var i, r, s; function o() { ct(), gapi.load("gapi.iframes", { callback: () => { t(gapi.iframes.getContext()) }, ontimeout: () => { ct(), n(oO(e, "network-request-failed")) }, timeout: ce.get() }) } if (null == (r = null == (i = hr().gapi) ? void 0 : i.iframes) ? void 0 : r.Iframe) t(gapi.iframes.getContext()); else if (null == (s = hr().gapi) ? void 0 : s.load) o(); else { let t = aU("iframefcb"); return hr()[t] = () => { gapi.load ? o() : n(oO(e, "network-request-failed")) }, aF(`${aj.gapiScript}?onload=${t}`).catch(e => n(e)) } }).catch(e => { throw cn = null, e })), n = hr().gapi; return oF(n, e, "internal-error"), t.open({ where: document.body, url: function (e) { let t = e.config; oF(t.authDomain, e, "auth-domain-config-required"); let n = t.emulator ? oH(t, "emulator/auth/iframe") : `https://${e.config.authDomain}/__/auth/iframe`, i = { apiKey: t.apiKey, appName: e.name, v: e9 }, r = cs.get(e.config.apiHost); r && (i.eid = r); let s = e._getFrameworks(); return s.length && (i.fw = s.join(",")), `${n}?${eo(i).slice(1)}` }(e), messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER, attributes: cr, dontclear: !0 }, t => new Promise(async (n, i) => { await t.restyle({ setHideOnLeave: !1 }); let r = oO(e, "network-request-failed"), s = hr().setTimeout(() => { i(r) }, ci.get()); function o() { hr().clearTimeout(s), n(t) } t.ping(o).then(o, () => { i(r) }) })) } let ca = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" }; class cl { constructor(e) { this.window = e, this.associatedEvent = null } close() { if (this.window) try { this.window.close() } catch (e) { } } } let ch = encodeURIComponent("fac"); async function cc(e, t, n, i, r, s) { oF(e.config.authDomain, e, "auth-domain-config-required"), oF(e.config.apiKey, e, "invalid-api-key"); let o = { apiKey: e.config.apiKey, appName: e.name, authType: n, redirectUrl: i, v: e9, eventId: r }; if (t instanceof ls) for (let [n, i] of (t.setDefaultLanguage(e.languageCode), o.providerId = t.providerId || "", en(t.getCustomParameters()) || (o.customParameters = JSON.stringify(t.getCustomParameters())), Object.entries(s || {}))) o[n] = i; if (t instanceof lo) { let e = t.getScopes().filter(e => "" !== e); e.length > 0 && (o.scopes = e.join(",")) } for (let t of (e.tenantId && (o.tid = e.tenantId), Object.keys(o))) void 0 === o[t] && delete o[t]; let a = await e._getAppCheckToken(), l = a ? `#${ch}=${encodeURIComponent(a)}` : ""; return `${function ({ config: e }) { return e.emulator ? oH(e, "emulator/auth/handler") : `https://${e.authDomain}/__/auth/handler` }(e)}?${eo(o).slice(1)}${l}` } let cu = "webStorageSupport"; class cd { constructor() { this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = he, this._completeRedirectFn = h1, this._overrideRedirectResult = hK } async _openPopup(e, t, n, i) { var r, s, o; s = null == (r = this.eventManagers[e._key()]) ? void 0 : r.manager, o = "_initialize() not called before _openPopup()", s || oU(o); let a = await cc(e, t, n, oW(), i); return function (e, t, n, i = 500, r = 600) { let s = Math.max((window.screen.availHeight - r) / 2, 0).toString(), o = Math.max((window.screen.availWidth - i) / 2, 0).toString(), a = "", l = Object.assign(Object.assign({}, ca), { width: i.toString(), height: r.toString(), top: s, left: o }), h = j().toLowerCase(); n && (a = aT(h) ? "_blank" : n), aI(h) && (t = t || "http://localhost", l.scrollbars = "yes"); let c = Object.entries(l).reduce((e, [t, n]) => `${e}${t}=${n},`, ""); if (function (e = j()) { var t; return aN(e) && !!(null == (t = window.navigator) ? void 0 : t.standalone) }(h) && "_self" !== a) return function (e, t) { let n = document.createElement("a"); n.href = e, n.target = t; let i = document.createEvent("MouseEvent"); i.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(i) }(t || "", a), new cl(null); let u = window.open(t || "", a, c); oF(u, e, "popup-blocked"); try { u.focus() } catch (e) { } return new cl(u) }(e, a, hn()) } async _openRedirect(e, t, n, i) { var r; return await this._originValidation(e), r = await cc(e, t, n, oW(), i), hr().location.href = r, new Promise(() => { }) } _initialize(e) { let t = e._key(); if (this.eventManagers[t]) { var n; let { manager: e, promise: i } = this.eventManagers[t]; return e ? Promise.resolve(e) : (n = "If manager is not set, promise should be", i || oU(n), i) } let i = this.initAndGetManager(e); return this.eventManagers[t] = { promise: i }, i.catch(() => { delete this.eventManagers[t] }), i } async initAndGetManager(e) { let t = await co(e), n = new h3(e); return t.register("authEvent", t => (oF(null == t ? void 0 : t.authEvent, e, "invalid-auth-event"), { status: n.onEvent(t.authEvent) ? "ACK" : "ERROR" }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = { manager: n }, this.iframes[e._key()] = t, n } _isIframeWebStorageSupported(e, t) { this.iframes[e._key()].send(cu, { type: cu }, n => { var i; let r = null == (i = null == n ? void 0 : n[0]) ? void 0 : i[cu]; void 0 !== r && t(!!r), oA(e, "internal-error") }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER) } _originValidation(e) { let t = e._key(); return this.originValidationPromises[t] || (this.originValidationPromises[t] = h9(e)), this.originValidationPromises[t] } get _shouldInitProactively() { return aR() || aC() || aN() } } class cp { constructor(e) { this.factorId = e } _process(e, t, n) { switch (t.type) { case "enroll": return this._finalizeEnroll(e, t.credential, n); case "signin": return this._finalizeSignIn(e, t.credential); default: return oU("unexpected MultiFactorSessionType") } } } class cf extends cp { constructor(e) { super("phone"), this.credential = e } static _fromCredential(e) { return new cf(e) } _finalizeEnroll(e, t, n) { return oJ(e, "POST", "/v2/accounts/mfaEnrollment:finalize", oY(e, { idToken: t, displayName: n, phoneVerificationInfo: this.credential._makeVerificationRequest() })) } _finalizeSignIn(e, t) { return oJ(e, "POST", "/v2/accounts/mfaSignIn:finalize", oY(e, { mfaPendingCredential: t, phoneVerificationInfo: this.credential._makeVerificationRequest() })) } } class cm { constructor() { } static assertion(e) { return cf._fromCredential(e) } } cm.FACTOR_ID = "phone"; class cg { static assertionForEnrollment(e, t) { return c_._fromSecret(e, t) } static assertionForSignIn(e, t) { return c_._fromEnrollmentId(e, t) } static async generateSecret(e) { var t, n; oF(void 0 !== (null == (t = e.user) ? void 0 : t.auth), "internal-error"); let i = await oJ(n = e.user.auth, "POST", "/v2/accounts/mfaEnrollment:start", oY(n, { idToken: e.credential, totpEnrollmentInfo: {} })); return cv._fromStartTotpMfaEnrollmentResponse(i, e.user.auth) } } cg.FACTOR_ID = "totp"; class c_ extends cp { constructor(e, t, n) { super("totp"), this.otp = e, this.enrollmentId = t, this.secret = n } static _fromSecret(e, t) { return new c_(t, void 0, e) } static _fromEnrollmentId(e, t) { return new c_(t, e) } async _finalizeEnroll(e, t, n) { return oF(void 0 !== this.secret, e, "argument-error"), oJ(e, "POST", "/v2/accounts/mfaEnrollment:finalize", oY(e, { idToken: t, displayName: n, totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp) })) } async _finalizeSignIn(e, t) { oF(void 0 !== this.enrollmentId && void 0 !== this.otp, e, "argument-error"); let n = { verificationCode: this.otp }; return oJ(e, "POST", "/v2/accounts/mfaSignIn:finalize", oY(e, { mfaPendingCredential: t, mfaEnrollmentId: this.enrollmentId, totpVerificationInfo: n })) } } class cv { constructor(e, t, n, i, r, s, o) { this.sessionInfo = s, this.auth = o, this.secretKey = e, this.hashingAlgorithm = t, this.codeLength = n, this.codeIntervalSeconds = i, this.enrollmentCompletionDeadline = r } static _fromStartTotpMfaEnrollmentResponse(e, t) { return new cv(e.totpSessionInfo.sharedSecretKey, e.totpSessionInfo.hashingAlgorithm, e.totpSessionInfo.verificationCodeLength, e.totpSessionInfo.periodSec, new Date(e.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), e.totpSessionInfo.sessionInfo, t) } _makeTotpVerificationInfo(e) { return { sessionInfo: this.sessionInfo, verificationCode: e } } generateQrCodeUrl(e, t) { var n; let i = !1; return (cy(e) || cy(t)) && (i = !0), i && (cy(e) && (e = (null == (n = this.auth.currentUser) ? void 0 : n.email) || "unknownuser"), cy(t) && (t = this.auth.name)), `otpauth://totp/${t}:${e}?secret=${this.secretKey}&issuer=${t}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}` } } function cy(e) { return void 0 === e || (null == e ? void 0 : e.length) === 0 } var cw = "@firebase/auth", cb = "1.7.9"; class cI { constructor(e) { this.auth = e, this.internalListeners = new Map } getUid() { var e; return this.assertAuthConfigured(), (null == (e = this.auth.currentUser) ? void 0 : e.uid) || null } async getToken(e) { return (this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser) ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null } addAuthTokenListener(e) { if (this.assertAuthConfigured(), this.internalListeners.has(e)) return; let t = this.auth.onIdTokenChanged(t => { e((null == t ? void 0 : t.stsTokenManager.accessToken) || null) }); this.internalListeners.set(e, t), this.updateProactiveRefresh() } removeAuthTokenListener(e) { this.assertAuthConfigured(); let t = this.internalListeners.get(e); t && (this.internalListeners.delete(e), t(), this.updateProactiveRefresh()) } assertAuthConfigured() { oF(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth") } updateProactiveRefresh() { this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh() } } let cC = (e => { var t; return null == (t = D()) ? void 0 : t[`_${e}`] })("authIdTokenMaxAge") || 300, cT = null; function ck() { return window } async function cE(e, t, n) { var i, r, s; let { BuildInfo: o } = ck(); r = t.sessionId, s = "AuthEvent did not contain a session ID", r || oU(s); let a = await cN(t.sessionId), l = {}; return aN() ? l.ibi = o.packageName : aE() ? l.apn = o.packageName : oA(e, "operation-not-supported-in-this-environment"), o.displayName && (l.appDisplayName = o.displayName), l.sessionId = a, cc(e, n, t.type, void 0, null != (i = t.eventId) ? i : void 0, l) } async function cS(e) { let { BuildInfo: t } = ck(), n = {}; aN() ? n.iosBundleId = t.packageName : aE() ? n.androidPackageName = t.packageName : oA(e, "operation-not-supported-in-this-environment"), await h6(e, n) } async function cP(e, t, n) { let { cordova: i } = ck(), r = () => { }; try { await new Promise((s, o) => { let a = null; function l() { var e; s(); let t = null == (e = i.plugins.browsertab) ? void 0 : e.close; "function" == typeof t && t(), "function" == typeof (null == n ? void 0 : n.close) && n.close() } function h() { a || (a = window.setTimeout(() => { o(oO(e, "redirect-cancelled-by-user")) }, 2e3)) } function c() { (null == document ? void 0 : document.visibilityState) === "visible" && h() } t.addPassiveListener(l), document.addEventListener("resume", h, !1), aE() && document.addEventListener("visibilitychange", c, !1), r = () => { t.removePassiveListener(l), document.removeEventListener("resume", h, !1), document.removeEventListener("visibilitychange", c, !1), a && window.clearTimeout(a) } }) } finally { r() } } async function cN(e) { let t = function (e) { var t, n; if (t = /[0-9a-zA-Z]+/.test(e), n = "Can only convert alpha-numeric strings", t || oU(n), "undefined" != typeof TextEncoder) return new TextEncoder().encode(e); let i = new Uint8Array(new ArrayBuffer(e.length)); for (let t = 0; t < e.length; t++)i[t] = e.charCodeAt(t); return i }(e); return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", t))).map(e => e.toString(16).padStart(2, "0")).join("") } aj = { loadJS: e => new Promise((t, n) => { let i = document.createElement("script"); i.setAttribute("src", e), i.onload = t, i.onerror = e => { let t = oO("internal-error"); t.customData = e, n(t) }, i.type = "text/javascript", i.charset = "UTF-8", (function () { var e, t; return null != (t = null == (e = document.getElementsByTagName("head")) ? void 0 : e[0]) ? t : document })().appendChild(i) }), gapiScript: "https://apis.google.com/js/api.js", recaptchaV2Script: "https://www.google.com/recaptcha/api.js", recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render=" }, function (e) { e0(new ew("auth", (t, { options: n }) => { let i = t.getProvider("app").getImmediate(), r = t.getProvider("heartbeat"), s = t.getProvider("app-check-internal"), { apiKey: o, authDomain: a } = i.options; oF(o && !o.includes(":"), "invalid-api-key", { appName: i.name }); let l = new aL(i, r, s, { apiKey: o, authDomain: a, clientPlatform: e, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: ax(e) }), h = (null == n ? void 0 : n.persistence) || [], c = (Array.isArray(h) ? h : [h]).map(a_); return (null == n ? void 0 : n.errorMap) && l._updateErrorMap(n.errorMap), l._initializeWithPersistence(c, null == n ? void 0 : n.popupRedirectResolver), l }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, t, n) => { e.getProvider("auth-internal").initialize() })), e0(new ew("auth-internal", e => new cI(ey(e.getProvider("auth").getImmediate())), "PRIVATE").setInstantiationMode("EXPLICIT")), ts(cw, cb, function (e) { switch (e) { case "Node": return "node"; case "ReactNative": return "rn"; case "Worker": return "webworker"; case "Cordova": return "cordova"; case "WebExtension": return "web-extension"; default: return } }(e)), ts(cw, cb, "esm2017") }("Browser"); class cR extends h3 { constructor() { super(...arguments), this.passiveListeners = new Set, this.initPromise = new Promise(e => { this.resolveInitialized = e }) } addPassiveListener(e) { this.passiveListeners.add(e) } removePassiveListener(e) { this.passiveListeners.delete(e) } resetRedirect() { this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1 } onEvent(e) { return this.resolveInitialized(), this.passiveListeners.forEach(t => t(e)), super.onEvent(e) } async initialized() { await this.initPromise } } async function cx(e) { let t = await a_(l9)._get(cA(e)); return t && await a_(l9)._remove(cA(e)), t } function cA(e) { return ay("authEvent", e.config.apiKey, e.name) } function cO(e) { if (!(null == e ? void 0 : e.includes("?"))) return {}; let [t, ...n] = e.split("?"); return ea(n.join("?")) } class cD { constructor() { this._redirectPersistence = he, this._shouldInitProactively = !0, this.eventManagers = new Map, this.originValidationPromises = {}, this._completeRedirectFn = h1, this._overrideRedirectResult = hK } async _initialize(e) { let t = e._key(), n = this.eventManagers.get(t); return n || (n = new cR(e), this.eventManagers.set(t, n), this.attachCallbackListeners(e, n)), n } _openPopup(e) { oA(e, "operation-not-supported-in-this-environment") } async _openRedirect(e, t, n, i) { !function (e) { var t, n, i, r, s, o, a, l, h, c; let u = ck(); oF("function" == typeof (null == (t = null == u ? void 0 : u.universalLinks) ? void 0 : t.subscribe), e, "invalid-cordova-configuration", { missingPlugin: "cordova-universal-links-plugin-fix" }), oF(void 0 !== (null == (n = null == u ? void 0 : u.BuildInfo) ? void 0 : n.packageName), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-buildInfo" }), oF("function" == typeof (null == (s = null == (r = null == (i = null == u ? void 0 : u.cordova) ? void 0 : i.plugins) ? void 0 : r.browsertab) ? void 0 : s.openUrl), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), oF("function" == typeof (null == (l = null == (a = null == (o = null == u ? void 0 : u.cordova) ? void 0 : o.plugins) ? void 0 : a.browsertab) ? void 0 : l.isAvailable), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), oF("function" == typeof (null == (c = null == (h = null == u ? void 0 : u.cordova) ? void 0 : h.InAppBrowser) ? void 0 : c.open), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-inappbrowser" }) }(e); let r = await this._initialize(e); await r.initialized(), r.resetRedirect(), hB.clear(), await this._originValidation(e); let s = function (e, t, n = null) { return { type: t, eventId: n, urlResponse: null, sessionId: function () { let e = [], t = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let n = 0; n < 20; n++) { let n = Math.floor(Math.random() * t.length); e.push(t.charAt(n)) } return e.join("") }(), postBody: null, tenantId: e.tenantId, error: oO(e, "no-auth-event") } }(e, n, i); await a_(l9)._set(cA(e), s); let o = await cE(e, s, t); return cP(e, r, await function (e) { let { cordova: t } = ck(); return new Promise(n => { t.plugins.browsertab.isAvailable(i => { let r = null; i ? t.plugins.browsertab.openUrl(e) : r = t.InAppBrowser.open(e, !function (e = j()) { return /(iPad|iPhone|iPod).*OS 7_\d/i.test(e) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(e) }() ? "_system" : "_blank", "location=yes"), n(r) }) }) }(o)) } _isIframeWebStorageSupported(e, t) { throw Error("Method not implemented.") } _originValidation(e) { let t = e._key(); return this.originValidationPromises[t] || (this.originValidationPromises[t] = cS(e)), this.originValidationPromises[t] } attachCallbackListeners(e, t) { let { universalLinks: n, handleOpenURL: i, BuildInfo: r } = ck(), s = setTimeout(async () => { await cx(e), t.onEvent(cL()) }, 500), o = async n => { clearTimeout(s); let i = await cx(e), r = null; i && (null == n ? void 0 : n.url) && (r = function (e, t) { var n, i; let r = function (e) { let t = cO(e), n = t.link ? decodeURIComponent(t.link) : void 0, i = cO(n).link, r = t.deep_link_id ? decodeURIComponent(t.deep_link_id) : void 0; return cO(r).link || r || i || n || e }(t); if (r.includes("/__/auth/callback")) { let t = cO(r), s = t.firebaseError ? function (e) { try { return JSON.parse(e) } catch (e) { return null } }(decodeURIComponent(t.firebaseError)) : null, o = null == (i = null == (n = null == s ? void 0 : s.code) ? void 0 : n.split("auth/")) ? void 0 : i[1], a = o ? oO(o) : null; return a ? { type: e.type, eventId: e.eventId, tenantId: e.tenantId, error: a, urlResponse: null, sessionId: null, postBody: null } : { type: e.type, eventId: e.eventId, tenantId: e.tenantId, sessionId: e.sessionId, urlResponse: r, postBody: null } } return null }(i, n.url)), t.onEvent(r || cL()) }; void 0 !== n && "function" == typeof n.subscribe && n.subscribe(null, o); let a = `${r.packageName.toLowerCase()}://`; ck().handleOpenURL = async e => { if (e.toLowerCase().startsWith(a) && o({ url: e }), "function" == typeof i) try { i(e) } catch (e) { console.error(e) } } } } function cL() { return { type: "unknown", eventId: null, sessionId: null, urlResponse: null, postBody: null, tenantId: null, error: oO("no-auth-event") } } function cM() { var e; return (null == (e = null == self ? void 0 : self.location) ? void 0 : e.protocol) || null } function cj(e = j()) { return !!(("file:" === cM() || "ionic:" === cM() || "capacitor:" === cM()) && e.toLowerCase().match(/iphone|ipad|ipod|android/)) } function cF() { try { let e = self.localStorage, t = hn(); if (e) { if (e.setItem(t, "1"), e.removeItem(t), function (e = j()) { return V() && (null == document ? void 0 : document.documentMode) === 11 || function (e = j()) { return /Edge\/\d+/.test(e) }(e) }()) return H(); return !0 } } catch (e) { return cU() && H() } return !1 } function cU() { return void 0 !== n.g && "WorkerGlobalScope" in n.g && "importScripts" in n.g } function cq() { return ("http:" === cM() || "https:" === cM() || W() || cj()) && !(z() || U()) && cF() && !cU() } function cW() { return cj() && "undefined" != typeof document } async function cz() { return !!cW() && new Promise(e => { let t = setTimeout(() => { e(!1) }, 1e3); document.addEventListener("deviceready", () => { clearTimeout(t), e(!0) }) }) } let cV = { LOCAL: "local", NONE: "none", SESSION: "session" }, cB = "persistence"; async function cH(e) { await e._initializationPromise; let t = c$(), n = ay(cB, e.config.apiKey, e.name); t && t.setItem(n, e._getPersistence()) } function c$() { var e; try { return (null == (e = "undefined" != typeof window ? window : null) ? void 0 : e.sessionStorage) || null } catch (e) { return null } } class cG { constructor() { this.browserResolver = a_(cd), this.cordovaResolver = a_(cD), this.underlyingResolver = null, this._redirectPersistence = he, this._completeRedirectFn = h1, this._overrideRedirectResult = hK } async _initialize(e) { return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._initialize(e) } async _openPopup(e, t, n, i) { return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._openPopup(e, t, n, i) } async _openRedirect(e, t, n, i) { return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._openRedirect(e, t, n, i) } _isIframeWebStorageSupported(e, t) { this.assertedUnderlyingResolver._isIframeWebStorageSupported(e, t) } _originValidation(e) { return this.assertedUnderlyingResolver._originValidation(e) } get _shouldInitProactively() { return cW() || this.browserResolver._shouldInitProactively } get assertedUnderlyingResolver() { return oF(this.underlyingResolver, "internal-error"), this.underlyingResolver } async selectUnderlyingResolver() { if (this.underlyingResolver) return; let e = await cz(); this.underlyingResolver = e ? this.cordovaResolver : this.browserResolver } } function cK(e) { let t, { _tokenResponse: n } = e instanceof $ ? e.customData : e; if (!n) return null; if (!(e instanceof $) && "temporaryProof" in n && "phoneNumber" in n) return hA.credentialFromResult(e); let i = n.providerId; if (!i || i === ok.PASSWORD) return null; switch (i) { case ok.GOOGLE: t = lh; break; case ok.FACEBOOK: t = ll; break; case ok.GITHUB: t = lc; break; case ok.TWITTER: t = lp; break; default: let { oauthIdToken: r, oauthAccessToken: s, oauthTokenSecret: o, pendingToken: a, nonce: l } = n; if (!s && !o && !r && !a) return null; if (a) if (i.startsWith("saml.")) return lu._create(i, a); else return a6._fromParams({ providerId: i, signInMethod: i, pendingToken: a, idToken: r, accessToken: s }); return new la(i).credential({ idToken: r, accessToken: s, rawNonce: l }) }return e instanceof $ ? t.credentialFromError(e) : t.credentialFromResult(e) } function cY(e, t) { return t.catch(t => { throw t instanceof $ && function (e, t) { var n; let i = null == (n = t.customData) ? void 0 : n._tokenResponse; if ((null == t ? void 0 : t.code) === "auth/multi-factor-auth-required") t.resolver = new cQ(e, function (e, t) { var n; let i = ey(e); return oF(t.customData.operationType, i, "argument-error"), oF(null == (n = t.customData._serverResponse) ? void 0 : n.mfaPendingCredential, i, "argument-error"), l4._fromError(i, t) }(e, t)); else if (i) { let e = cK(t); e && (t.credential = e, t.tenantId = i.tenantId || void 0, t.email = i.email || void 0, t.phoneNumber = i.phoneNumber || void 0) } }(e, t), t }).then(e => { let t = e.operationType, n = e.user; return { operationType: t, credential: cK(e), additionalUserInfo: function (e) { let { user: t, _tokenResponse: n } = e; return t.isAnonymous && !n ? { providerId: null, isNewUser: !1, profile: null } : function (e) { var t, n; if (!e) return null; let { providerId: i } = e, r = e.rawUserInfo ? JSON.parse(e.rawUserInfo) : {}, s = e.isNewUser || "identitytoolkit#SignupNewUserResponse" === e.kind; if (!i && (null == e ? void 0 : e.idToken)) { let i = null == (n = null == (t = ai(e.idToken)) ? void 0 : t.firebase) ? void 0 : n.sign_in_provider; if (i) return new lQ(s, "anonymous" !== i && "custom" !== i ? i : null) } if (!i) return null; switch (i) { case "facebook.com": return new lZ(s, r); case "github.com": return new l0(s, r); case "google.com": return new l1(s, r); case "twitter.com": return new l2(s, r, e.screenName || null); case "custom": case "anonymous": return new lQ(s, null); default: return new lQ(s, i, r) } }(n) }(e), user: cX.getOrCreate(n) } }) } async function cJ(e, t) { let n = await t; return { verificationId: n.verificationId, confirm: t => cY(e, n.confirm(t)) } } class cQ { constructor(e, t) { this.resolver = t, this.auth = e.wrapped() } get session() { return this.resolver.session } get hints() { return this.resolver.hints } resolveSignIn(e) { return cY(this.auth.unwrap(), this.resolver.resolveSignIn(e)) } } class cX { constructor(e) { this._delegate = e, this.multiFactor = function (e) { let t = ey(e); return l6.has(t) || l6.set(t, l5._fromUser(t)), l6.get(t) }(e) } static getOrCreate(e) { return cX.USER_MAP.has(e) || cX.USER_MAP.set(e, new cX(e)), cX.USER_MAP.get(e) } delete() { return this._delegate.delete() } reload() { return this._delegate.reload() } toJSON() { return this._delegate.toJSON() } getIdTokenResult(e) { return this._delegate.getIdTokenResult(e) } getIdToken(e) { return this._delegate.getIdToken(e) } linkAndRetrieveDataWithCredential(e) { return this.linkWithCredential(e) } async linkWithCredential(e) { return cY(this.auth, lS(this._delegate, e)) } async linkWithPhoneNumber(e, t) { return cJ(this.auth, hP(this._delegate, e, t)) } async linkWithPopup(e) { return cY(this.auth, hz(this._delegate, e, cG)) } async linkWithRedirect(e) { return await cH(ey(this.auth)), hZ(this._delegate, e, cG) } reauthenticateAndRetrieveDataWithCredential(e) { return this.reauthenticateWithCredential(e) } async reauthenticateWithCredential(e) { return cY(this.auth, lP(this._delegate, e)) } reauthenticateWithPhoneNumber(e, t) { return cJ(this.auth, hN(this._delegate, e, t)) } reauthenticateWithPopup(e) { return cY(this.auth, hW(this._delegate, e, cG)) } async reauthenticateWithRedirect(e) { return await cH(ey(this.auth)), hX(this._delegate, e, cG) } sendEmailVerification(e) { return l$(this._delegate, e) } async unlink(e) { return await lb(this._delegate, e), this } updateEmail(e) { let t = ey(this._delegate); return e4(t.auth.app) ? Promise.reject(oL(t.auth)) : lJ(t, e, null) } updatePassword(e) { var t; return t = this._delegate, lJ(ey(t), null, e) } updatePhoneNumber(e) { return hx(this._delegate, e) } updateProfile(e) { return lY(this._delegate, e) } verifyBeforeUpdateEmail(e, t) { return lG(this._delegate, e, t) } get emailVerified() { return this._delegate.emailVerified } get isAnonymous() { return this._delegate.isAnonymous } get metadata() { return this._delegate.metadata } get phoneNumber() { return this._delegate.phoneNumber } get providerData() { return this._delegate.providerData } get refreshToken() { return this._delegate.refreshToken } get tenantId() { return this._delegate.tenantId } get displayName() { return this._delegate.displayName } get email() { return this._delegate.email } get photoURL() { return this._delegate.photoURL } get providerId() { return this._delegate.providerId } get uid() { return this._delegate.uid } get auth() { return this._delegate.auth } } cX.USER_MAP = new WeakMap; class cZ { constructor(e, t) { if (this.app = e, t.isInitialized()) { this._delegate = t.getImmediate(), this.linkUnderlyingAuth(); return } let { apiKey: n } = e.options; oF(n, "invalid-api-key", { appName: e.name }), oF(n, "invalid-api-key", { appName: e.name }); let i = "undefined" != typeof window ? cG : void 0; this._delegate = t.initialize({ options: { persistence: function (e, t) { let n = function (e, t) { let n = c$(); if (!n) return []; let i = ay(cB, e, t); switch (n.getItem(i)) { case cV.NONE: return [av]; case cV.LOCAL: return [hg, he]; case cV.SESSION: return [he]; default: return [] } }(e, t); if ("undefined" == typeof self || n.includes(hg) || n.push(hg), "undefined" != typeof window) for (let e of [l9, he]) n.includes(e) || n.push(e); return n.includes(av) || n.push(av), n }(n, e.name), popupRedirectResolver: i } }), this._delegate._updateErrorMap(oP), this.linkUnderlyingAuth() } get emulatorConfig() { return this._delegate.emulatorConfig } get currentUser() { return this._delegate.currentUser ? cX.getOrCreate(this._delegate.currentUser) : null } get languageCode() { return this._delegate.languageCode } set languageCode(e) { this._delegate.languageCode = e } get settings() { return this._delegate.settings } get tenantId() { return this._delegate.tenantId } set tenantId(e) { this._delegate.tenantId = e } useDeviceLanguage() { this._delegate.useDeviceLanguage() } signOut() { return this._delegate.signOut() } useEmulator(e, t) { !function (e, t, n) { let i = ey(e); oF(i._canInitEmulator, i, "emulator-config-failed"), oF(/^https?:\/\//.test(t), i, "invalid-emulator-scheme"); let r = !!(null == n ? void 0 : n.disableWarnings), s = aV(t), { host: o, port: a } = function (e) { let t = aV(e), n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length)); if (!n) return { host: "", port: null }; let i = n[2].split("@").pop() || "", r = /^(\[[^\]]+\])(:|$)/.exec(i); if (r) { let e = r[1]; return { host: e, port: aB(i.substr(e.length + 1)) } } { let [e, t] = i.split(":"); return { host: e, port: aB(t) } } }(t), l = null === a ? "" : `:${a}`; i.config.emulator = { url: `${s}//${o}${l}/` }, i.settings.appVerificationDisabledForTesting = !0, i.emulatorConfig = Object.freeze({ host: o, port: a, protocol: s.replace(":", ""), options: Object.freeze({ disableWarnings: r }) }), r || function () { function e() { let e = document.createElement("p"), t = e.style; e.innerText = "Running in emulator mode. Do not use with production credentials.", t.position = "fixed", t.width = "100%", t.backgroundColor = "#ffffff", t.border = ".1em solid #000000", t.color = "#b50000", t.bottom = "0px", t.left = "0px", t.margin = "0px", t.zIndex = "10000", t.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e) } "undefined" != typeof console && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", e) : e()) }() }(this._delegate, e, t) } applyActionCode(e) { return lF(this._delegate, e) } checkActionCode(e) { return lU(this._delegate, e) } confirmPasswordReset(e, t) { return lj(this._delegate, e, t) } async createUserWithEmailAndPassword(e, t) { return cY(this._delegate, lW(this._delegate, e, t)) } fetchProvidersForEmail(e) { return this.fetchSignInMethodsForEmail(e) } fetchSignInMethodsForEmail(e) { return lH(this._delegate, e) } isSignInWithEmailLink(e) { this._delegate; let t = li.parseLink(e); return (null == t ? void 0 : t.operation) === "EMAIL_SIGNIN" } async getRedirectResult() { oF(cq(), this._delegate, "operation-not-supported-in-this-environment"); let e = await h0(this._delegate, cG); return e ? cY(this._delegate, Promise.resolve(e)) : { credential: null, user: null } } addFrameworkForLogging(e) { ey(this._delegate)._logFramework(e) } onAuthStateChanged(e, t, n) { let { next: i, error: r, complete: s } = c0(e, t, n); return this._delegate.onAuthStateChanged(i, r, s) } onIdTokenChanged(e, t, n) { let { next: i, error: r, complete: s } = c0(e, t, n); return this._delegate.onIdTokenChanged(i, r, s) } sendSignInLinkToEmail(e, t) { return lz(this._delegate, e, t) } sendPasswordResetEmail(e, t) { return lM(this._delegate, e, t || void 0) } async setPersistence(e) { var t; let n; switch (t = this._delegate, (oF(Object.values(cV).includes(e), t, "invalid-persistence-type"), z()) ? oF(e !== cV.SESSION, t, "unsupported-persistence-type") : U() ? oF(e === cV.NONE, t, "unsupported-persistence-type") : cU() ? oF(e === cV.NONE || e === cV.LOCAL && H(), t, "unsupported-persistence-type") : oF(e === cV.NONE || cF(), t, "unsupported-persistence-type"), e) { case cV.SESSION: n = he; break; case cV.LOCAL: n = await a_(hg)._isAvailable() ? hg : l9; break; case cV.NONE: n = av; break; default: return oA("argument-error", { appName: this._delegate.name }) }return this._delegate.setPersistence(n) } signInAndRetrieveDataWithCredential(e) { return this.signInWithCredential(e) } signInAnonymously() { return cY(this._delegate, l_(this._delegate)) } signInWithCredential(e) { return cY(this._delegate, lE(this._delegate, e)) } signInWithCustomToken(e) { return cY(this._delegate, lR(this._delegate, e)) } signInWithEmailAndPassword(e, t) { var n; return cY(this._delegate, (n = this._delegate, e4(n.app) ? Promise.reject(oL(n)) : lE(ey(n), lr.credential(e, t)).catch(async e => { throw "auth/password-does-not-meet-requirements" === e.code && lL(n), e }))) } signInWithEmailLink(e, t) { return cY(this._delegate, lV(this._delegate, e, t)) } signInWithPhoneNumber(e, t) { return cJ(this._delegate, hS(this._delegate, e, t)) } async signInWithPopup(e) { return oF(cq(), this._delegate, "operation-not-supported-in-this-environment"), cY(this._delegate, hq(this._delegate, e, cG)) } async signInWithRedirect(e) { return oF(cq(), this._delegate, "operation-not-supported-in-this-environment"), await cH(this._delegate), hQ(this._delegate, e, cG) } updateCurrentUser(e) { return this._delegate.updateCurrentUser(e) } verifyPasswordResetCode(e) { return lq(this._delegate, e) } unwrap() { return this._delegate } _delete() { return this._delegate._delete() } linkUnderlyingAuth() { this._delegate.wrapped = () => this } } function c0(e, t, n) { let i = e; "function" != typeof e && ({ next: i, error: t, complete: n } = e); let r = i; return { next: e => r(e && cX.getOrCreate(e)), error: t, complete: n } } cZ.Persistence = cV; class c1 { constructor() { this.providerId = "phone", this._delegate = new hA(tw.auth().unwrap()) } static credential(e, t) { return hA.credential(e, t) } verifyPhoneNumber(e, t) { return this._delegate.verifyPhoneNumber(e, t) } unwrap() { return this._delegate } } c1.PHONE_SIGN_IN_METHOD = hA.PHONE_SIGN_IN_METHOD, c1.PROVIDER_ID = hA.PROVIDER_ID; class c2 { constructor(e, t, n = tw.app()) { var i; oF(null == (i = n.options) ? void 0 : i.apiKey, "invalid-api-key", { appName: n.name }), this._delegate = new hk(n.auth(), e, t), this.type = this._delegate.type } clear() { this._delegate.clear() } render() { return this._delegate.render() } verify() { return this._delegate.verify() } } !function (e) { e.INTERNAL.registerComponent(new ew("auth-compat", e => new cZ(e.getProvider("app-compat").getImmediate(), e.getProvider("auth")), "PUBLIC").setServiceProps({ ActionCodeInfo: { Operation: { EMAIL_SIGNIN: oE.EMAIL_SIGNIN, PASSWORD_RESET: oE.PASSWORD_RESET, RECOVER_EMAIL: oE.RECOVER_EMAIL, REVERT_SECOND_FACTOR_ADDITION: oE.REVERT_SECOND_FACTOR_ADDITION, VERIFY_AND_CHANGE_EMAIL: oE.VERIFY_AND_CHANGE_EMAIL, VERIFY_EMAIL: oE.VERIFY_EMAIL } }, EmailAuthProvider: lr, FacebookAuthProvider: ll, GithubAuthProvider: lc, GoogleAuthProvider: lh, OAuthProvider: la, SAMLAuthProvider: ld, PhoneAuthProvider: c1, PhoneMultiFactorGenerator: cm, RecaptchaVerifier: c2, TwitterAuthProvider: lp, Auth: cZ, AuthCredential: aH, Error: $ }).setInstantiationMode("LAZY").setMultipleInstances(!1)), e.registerVersion("@firebase/auth-compat", "0.5.14") }(tw), tw.apps.length || tw.initializeApp({ apiKey: "AIzaSyCvB6oMNk-OJWIiiERzHYrOFkkH6VKyAFM", authDomain: "freesvgicons.firebaseapp.com", projectId: "freesvgicons", databaseURL: "https://freesvgicons-default-rtdb.firebaseio.com" }); let c3 = tw
  }, 3653: (e, t, n) => { "use strict"; n.d(t, { A: () => l, O: () => a }); var i = n(7876), r = n(4232), s = n(1784); let o = (0, r.createContext)(), a = e => { let { children: t } = e, [n, a] = (0, r.useState)(null), [l, h] = (0, r.useState)(!0), [c, u] = (0, r.useState)("free"), d = (0, r.useCallback)(async e => { try { let t = await fetch("/api/getUser", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ uid: e.uid, email: e.email, displayName: e.displayName }) }), n = await t.json(); n ? (a(n), u(n.plan || "free")) : a(e.toJSON()) } catch (t) { console.error("Error fetching user data:", t), a(e.toJSON()) } finally { h(!1) } }, []); (0, r.useEffect)(() => { let e = s.A.auth().onAuthStateChanged(async e => { e ? await d(e) : (a(null), u("free"), h(!1)) }); return () => e() }, [d]); let p = (0, r.useCallback)(async () => { let e = s.A.auth().currentUser; e && await d(e) }, [d]); return (0, i.jsx)(o.Provider, { value: { loading: l, userObj: n, userPlan: c, refreshUserData: p, isPro: "pro" === c }, children: t }) }, l = () => (0, r.useContext)(o) }, 4202: (e, t, n) => { "use strict"; n.d(t, { A: () => i }); let i = [{ company_name: "Anthropic", website: "https://www.anthropic.com", email: "dario@anthropic.ai", company_size: "Enterprise (1000+)", contact_name: "Dario Amodei" }, { company_name: "Wix", website: "https://www.wix.com", email: "dolphinh@wix.com", company_size: "Enterprise (5000+)", contact_name: "Dolphin Hayat" }, { company_name: "Walmart", website: "https://www.walmart.com", email: "samuel.lopez0@walmart.com", company_size: "Enterprise (2300000+)", contact_name: "Samuel Lopez" }, { company_name: "Shopify", website: "https://www.shopify.com", email: "adam@heyguest.ai", company_size: "Enterprise (10000+)", contact_name: "Adam Troman" }, { company_name: "Canva", website: "https://www.canva.com", email: "melcasey@canva.com", company_size: "Large (4000+)", contact_name: "Mel Casey" }, { company_name: "Appfire", website: "https://www.appfire.com", email: "alex.dolara@appfire.com", company_size: "Medium (500+)", contact_name: "Alexander Dolara" }, { company_name: "Airbnb", website: "https://www.airbnb.com", email: "jesse.howe@airbnb.com", company_size: "Large (6000+)", contact_name: "Jesse Howe" }, { company_name: "Sony", website: "https://www.sony.com", email: "avery.niou1@sony.com", company_size: "Enterprise (110000+)", contact_name: "Avery Niou" }, { company_name: "Builder.io", website: "https://www.builder.io", email: "hunter@builder.io", company_size: "Small (150+)", contact_name: "Hunter Gillispie" }, { company_name: "NVIDIA", website: "https://www.nvidia.com", email: "nhudait@nvidia.com", company_size: "Enterprise (29000+)", contact_name: "Neha Hudait" }, { company_name: "Revolut", website: "https://www.revolut.com", email: "mohammad.rashidi@revolut.com", company_size: "Large (8000+)", contact_name: "Mohammad Rashidi" }, { company_name: "Robinhood", website: "https://www.robinhood.com", email: "arnaud.frugier@robinhood.com", company_size: "Large (3800+)", contact_name: "Arnaud Frugier" }, { company_name: "DoorDash", website: "https://www.doordash.com", email: "ryan.dailey@doordash.com", company_size: "Large (8000+)", contact_name: "Ryan Dailey" }, { company_name: "Figma", website: "https://www.figma.com", email: "axel@azwedo.com", company_size: "Large (1000+)", contact_name: "Axel" }, { company_name: "Notion", website: "https://www.notion.so", email: "benjamin@azwedo.com", company_size: "Medium (500+)", contact_name: "Benjamin Fazli" }, { company_name: "Miro", website: "https://www.miro.com", email: "aziz@miro.com", company_size: "Large (2000+)", contact_name: "Aziz Antoun" }, { company_name: "Asana", website: "https://www.asana.com", email: "asana@asana.com", company_size: "Large (2000+)", contact_name: "Asana Team" }, { company_name: "Monday.com", website: "https://www.monday.com", email: "monday@monday.com", company_size: "Large (1500+)", contact_name: "Monday Team" }, { company_name: "Intercom", website: "https://www.intercom.com", email: "intercom@intercom.com", company_size: "Medium (800+)", contact_name: "Intercom Team" }, { company_name: "HubSpot", website: "https://www.hubspot.com", email: "hubspot@hubspot.com", company_size: "Large (7000+)", contact_name: "HubSpot Team" }, { company_name: "Mailchimp", website: "https://www.mailchimp.com", email: "mailchimp@mailchimp.com", company_size: "Large (1300+)", contact_name: "Mailchimp Team" }] }, 5105: (e, t, n) => { e.exports = n(7195) }, 6556: (e, t, n) => { (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function () { return n(8771) }]) }, 7384: () => { }, 7447: (e, t, n) => { "use strict"; n.d(t, { $: () => d, A: () => p }); var i = n(7876), r = n(4232), s = n(1713); let o = (0, s.A)("circle-check-big", [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]]), a = (0, s.A)("circle-alert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]), l = (0, s.A)("triangle-alert", [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3", key: "wmoenq" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]]), h = (0, s.A)("info", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]]); var c = n(672); let u = e => { let { toast: t, onClose: n } = e, { title: r, message: s, type: u = "success" } = t; return (0, i.jsxs)("div", { className: "toast", children: [(0, i.jsx)("div", { className: "toast-icon ".concat(u), children: (() => { switch (u) { case "success": return (0, i.jsx)(o, { size: 20 }); case "error": return (0, i.jsx)(a, { size: 20, className: "error" }); case "warning": return (0, i.jsx)(l, { size: 20 }); case "info": return (0, i.jsx)(h, { size: 20 }); default: return null } })() }), (0, i.jsxs)("div", { className: "toast-content", children: [r && (0, i.jsx)("div", { className: "toast-title", children: r }), s && (0, i.jsx)("div", { className: "toast-message", children: s })] }), (0, i.jsx)("button", { className: "toast-close", onClick: n, "aria-label": "Close notification", children: (0, i.jsx)(c.A, { size: 16 }) })] }) }, d = (0, r.createContext)(), p = e => { let { children: t } = e, [n, s] = (0, r.useState)([]), o = (0, r.useCallback)(e => { let t = Math.random().toString(36).substring(2, 9), n = { id: t, ...e }; return s(e => [...e, n]), setTimeout(() => { a(t) }, e.duration || 3e3), t }, []), a = (0, r.useCallback)(e => { s(t => t.filter(t => t.id !== e)) }, []); return (0, i.jsxs)(d.Provider, { value: { addToast: o, removeToast: a }, children: [t, (0, i.jsx)("div", { className: "toast-container", children: n.map(e => (0, i.jsx)(u, { toast: e, onClose: () => a(e.id) }, e.id)) })] }) } }, 8771: (e, t, n) => {
    "use strict"; n.r(t), n.d(t, { default: () => eC }); var i, r = n(7876), s = n(4232), o = n(3653), a = n(7447), l = n(5105), h = n.n(l); n(7384); var c = n(672), u = n(603); let d = { data: "" }, p = e => { if ("object" == typeof window) { let t = (e ? e.querySelector("#_goober") : window._goober) || Object.assign(document.createElement("style"), { innerHTML: " ", id: "_goober" }); return t.nonce = window.__nonce__, t.parentNode || (e || document.head).appendChild(t), t.firstChild } return e || d }, f = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, m = /\/\*[^]*?\*\/|  +/g, g = /\n+/g, _ = (e, t) => { let n = "", i = "", r = ""; for (let s in e) { let o = e[s]; "@" == s[0] ? "i" == s[1] ? n = s + " " + o + ";" : i += "f" == s[1] ? _(o, s) : s + "{" + _(o, "k" == s[1] ? "" : t) + "}" : "object" == typeof o ? i += _(o, t ? t.replace(/([^,])+/g, e => s.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, t => /&/.test(t) ? t.replace(/&/g, e) : e ? e + " " + t : t)) : s) : null != o && (s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase(), r += _.p ? _.p(s, o) : s + ":" + o + ";") } return n + (t && r ? t + "{" + r + "}" : r) + i }, v = {}, y = e => { if ("object" == typeof e) { let t = ""; for (let n in e) t += n + y(e[n]); return t } return e }, w = (e, t, n, i, r) => { let s = y(e), o = v[s] || (v[s] = (e => { let t = 0, n = 11; for (; t < e.length;)n = 101 * n + e.charCodeAt(t++) >>> 0; return "go" + n })(s)); if (!v[o]) { let t = s !== e ? e : (e => { let t, n, i = [{}]; for (; t = f.exec(e.replace(m, ""));)t[4] ? i.shift() : t[3] ? (n = t[3].replace(g, " ").trim(), i.unshift(i[0][n] = i[0][n] || {})) : i[0][t[1]] = t[2].replace(g, " ").trim(); return i[0] })(e); v[o] = _(r ? { ["@keyframes " + o]: t } : t, n ? "" : "." + o) } let a = n && v.g ? v.g : null; return n && (v.g = v[o]), ((e, t, n, i) => { i ? t.data = t.data.replace(i, e) : -1 === t.data.indexOf(e) && (t.data = n ? e + t.data : t.data + e) })(v[o], t, i, a), o }, b = (e, t, n) => e.reduce((e, i, r) => { let s = t[r]; if (s && s.call) { let e = s(n), t = e && e.props && e.props.className || /^go/.test(e) && e; s = t ? "." + t : e && "object" == typeof e ? e.props ? "" : _(e, "") : !1 === e ? "" : e } return e + i + (null == s ? "" : s) }, ""); function I(e) { let t = this || {}, n = e.call ? e(t.p) : e; return w(n.unshift ? n.raw ? b(n, [].slice.call(arguments, 1), t.p) : n.reduce((e, n) => Object.assign(e, n && n.call ? n(t.p) : n), {}) : n, p(t.target), t.g, t.o, t.k) } I.bind({ g: 1 }); let C, T, k, E = I.bind({ k: 1 }); function S(e, t) { let n = this || {}; return function () { let i = arguments; function r(s, o) { let a = Object.assign({}, s), l = a.className || r.className; n.p = Object.assign({ theme: T && T() }, a), n.o = / *go\d+/.test(l), a.className = I.apply(n, i) + (l ? " " + l : ""), t && (a.ref = o); let h = e; return e[0] && (h = a.as || e, delete a.as), k && h[0] && k(a), C(h, a) } return t ? t(r) : r } } var P = e => "function" == typeof e, N = (e, t) => P(e) ? e(t) : e, R = (() => { let e = 0; return () => (++e).toString() })(), x = (() => { let e; return () => { if (void 0 === e && "u" > typeof window) { let t = matchMedia("(prefers-reduced-motion: reduce)"); e = !t || t.matches } return e } })(), A = "default", O = (e, t) => { let { toastLimit: n } = e.settings; switch (t.type) { case 0: return { ...e, toasts: [t.toast, ...e.toasts].slice(0, n) }; case 1: return { ...e, toasts: e.toasts.map(e => e.id === t.toast.id ? { ...e, ...t.toast } : e) }; case 2: let { toast: i } = t; return O(e, { type: +!!e.toasts.find(e => e.id === i.id), toast: i }); case 3: let { toastId: r } = t; return { ...e, toasts: e.toasts.map(e => e.id === r || void 0 === r ? { ...e, dismissed: !0, visible: !1 } : e) }; case 4: return void 0 === t.toastId ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter(e => e.id !== t.toastId) }; case 5: return { ...e, pausedAt: t.time }; case 6: let s = t.time - (e.pausedAt || 0); return { ...e, pausedAt: void 0, toasts: e.toasts.map(e => ({ ...e, pauseDuration: e.pauseDuration + s })) } } }, D = [], L = { toasts: [], pausedAt: void 0, settings: { toastLimit: 20 } }, M = {}, j = (e, t = A) => { M[t] = O(M[t] || L, e), D.forEach(([e, n]) => { e === t && n(M[t]) }) }, F = e => Object.keys(M).forEach(t => j(e, t)), U = e => Object.keys(M).find(t => M[t].toasts.some(t => t.id === e)), q = (e = A) => t => { j(t, e) }, W = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, z = (e = {}, t = A) => { let [n, i] = (0, s.useState)(M[t] || L), r = (0, s.useRef)(M[t]); (0, s.useEffect)(() => (r.current !== M[t] && i(M[t]), D.push([t, i]), () => { let e = D.findIndex(([e]) => e === t); e > -1 && D.splice(e, 1) }), [t]); let o = n.toasts.map(t => { var n, i, r; return { ...e, ...e[t.type], ...t, removeDelay: t.removeDelay || (null == (n = e[t.type]) ? void 0 : n.removeDelay) || (null == e ? void 0 : e.removeDelay), duration: t.duration || (null == (i = e[t.type]) ? void 0 : i.duration) || (null == e ? void 0 : e.duration) || W[t.type], style: { ...e.style, ...null == (r = e[t.type]) ? void 0 : r.style, ...t.style } } }); return { ...n, toasts: o } }, V = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (null == n ? void 0 : n.id) || R() }), B = e => (t, n) => { let i = V(t, e, n); return q(i.toasterId || U(i.id))({ type: 2, toast: i }), i.id }, H = (e, t) => B("blank")(e, t); H.error = B("error"), H.success = B("success"), H.loading = B("loading"), H.custom = B("custom"), H.dismiss = (e, t) => { let n = { type: 3, toastId: e }; t ? q(t)(n) : F(n) }, H.dismissAll = e => H.dismiss(void 0, e), H.remove = (e, t) => { let n = { type: 4, toastId: e }; t ? q(t)(n) : F(n) }, H.removeAll = e => H.remove(void 0, e), H.promise = (e, t, n) => { let i = H.loading(t.loading, { ...n, ...null == n ? void 0 : n.loading }); return "function" == typeof e && (e = e()), e.then(e => { let r = t.success ? N(t.success, e) : void 0; return r ? H.success(r, { id: i, ...n, ...null == n ? void 0 : n.success }) : H.dismiss(i), e }).catch(e => { let r = t.error ? N(t.error, e) : void 0; r ? H.error(r, { id: i, ...n, ...null == n ? void 0 : n.error }) : H.dismiss(i) }), e }; var $ = 1e3, G = (e, t = "default") => { let { toasts: n, pausedAt: i } = z(e, t), r = (0, s.useRef)(new Map).current, o = (0, s.useCallback)((e, t = $) => { if (r.has(e)) return; let n = setTimeout(() => { r.delete(e), a({ type: 4, toastId: e }) }, t); r.set(e, n) }, []); (0, s.useEffect)(() => { if (i) return; let e = Date.now(), r = n.map(n => { if (n.duration === 1 / 0) return; let i = (n.duration || 0) + n.pauseDuration - (e - n.createdAt); if (i < 0) { n.visible && H.dismiss(n.id); return } return setTimeout(() => H.dismiss(n.id, t), i) }); return () => { r.forEach(e => e && clearTimeout(e)) } }, [n, i, t]); let a = (0, s.useCallback)(q(t), [t]), l = (0, s.useCallback)(() => { a({ type: 5, time: Date.now() }) }, [a]), h = (0, s.useCallback)((e, t) => { a({ type: 1, toast: { id: e, height: t } }) }, [a]), c = (0, s.useCallback)(() => { i && a({ type: 6, time: Date.now() }) }, [i, a]), u = (0, s.useCallback)((e, t) => { let { reverseOrder: i = !1, gutter: r = 8, defaultPosition: s } = t || {}, o = n.filter(t => (t.position || s) === (e.position || s) && t.height), a = o.findIndex(t => t.id === e.id), l = o.filter((e, t) => t < a && e.visible).length; return o.filter(e => e.visible).slice(...i ? [l + 1] : [0, l]).reduce((e, t) => e + (t.height || 0) + r, 0) }, [n]); return (0, s.useEffect)(() => { n.forEach(e => { if (e.dismissed) o(e.id, e.removeDelay); else { let t = r.get(e.id); t && (clearTimeout(t), r.delete(e.id)) } }) }, [n, o]), { toasts: n, handlers: { updateHeight: h, startPause: l, endPause: c, calculateOffset: u } } }, K = E`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Y = E`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, J = E`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Q = S("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${K} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Y} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${e => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${J} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, X = E`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Z = S("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${e => e.secondary || "#e0e0e0"};
  border-right-color: ${e => e.primary || "#616161"};
  animation: ${X} 1s linear infinite;
`, ee = E`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}

to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, et = E`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, en = S("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ee} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${et} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${e => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, ei = S("div")`
  position: absolute;
`, er = S("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, es = E`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, eo = S("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${es} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, ea = ({ toast: e }) => { let { icon: t, type: n, iconTheme: i } = e; return void 0 !== t ? "string" == typeof t ? s.createElement(eo, null, t) : t : "blank" === n ? null : s.createElement(er, null, s.createElement(Z, { ...i }), "loading" !== n && s.createElement(ei, null, "error" === n ? s.createElement(Q, { ...i }) : s.createElement(en, { ...i }))) }, el = e => `
0% {transform: translate3d(0,${-200 * e}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, eh = e => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${-150 * e}%,-1px) scale(.6); opacity:0;}
`, ec = S("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, eu = S("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ed = (e, t) => { let n = e.includes("top") ? 1 : -1, [i, r] = x() ? ["0%{opacity:0;} 100%{opacity:1;}", "0%{opacity:1;} 100%{opacity:0;}"] : [el(n), eh(n)]; return { animation: t ? `${E(i)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${E(r)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` } }, ep = s.memo(({ toast: e, position: t, style: n, children: i }) => { let r = e.height ? ed(e.position || t || "top-center", e.visible) : { opacity: 0 }, o = s.createElement(ea, { toast: e }), a = s.createElement(eu, { ...e.ariaProps }, N(e.message, e)); return s.createElement(ec, { className: e.className, style: { ...r, ...n, ...e.style } }, "function" == typeof i ? i({ icon: o, message: a }) : s.createElement(s.Fragment, null, o, a)) }); i = s.createElement, _.p = void 0, C = i, T = void 0, k = void 0; var ef = ({ id: e, className: t, style: n, onHeightUpdate: i, children: r }) => { let o = s.useCallback(t => { if (t) { let n = () => { i(e, t.getBoundingClientRect().height) }; n(), new MutationObserver(n).observe(t, { subtree: !0, childList: !0, characterData: !0 }) } }, [e, i]); return s.createElement("div", { ref: o, className: t, style: n }, r) }, em = (e, t) => { let n = e.includes("top"), i = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {}; return { left: 0, right: 0, display: "flex", position: "absolute", transition: x() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...n ? { top: 0 } : { bottom: 0 }, ...i } }, eg = I`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, e_ = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: i, children: r, toasterId: o, containerStyle: a, containerClassName: l }) => { let { toasts: h, handlers: c } = G(n, o); return s.createElement("div", { "data-rht-toaster": o || "", style: { position: "fixed", zIndex: 9999, top: 16, left: 16, right: 16, bottom: 16, pointerEvents: "none", ...a }, className: l, onMouseEnter: c.startPause, onMouseLeave: c.endPause }, h.map(n => { let o = n.position || t, a = em(o, c.calculateOffset(n, { reverseOrder: e, gutter: i, defaultPosition: t })); return s.createElement(ef, { id: n.id, key: n.id, onHeightUpdate: c.updateHeight, className: n.visible ? eg : "", style: a }, "custom" === n.type ? N(n.message, n) : r ? r(n) : s.createElement(ep, { toast: n, position: o })) })) }, ev = n(4202), ey = n(820); let ew = e => { let { onClose: t } = e, { userObj: n, isPro: i } = (0, o.A)(), { addToast: a } = (0, ey.d)(), [l, h] = (0, s.useState)(!1), [d, p] = (0, s.useState)(!1), f = async () => { p(!0); try { let e = JSON.stringify({ clientReferenceId: (null == n ? void 0 : n.uid) || "guest", price: "price_1SHT4eLSc9thM22ayOzfIY9J", uid: (null == n ? void 0 : n.uid) || "guest", email: (null == n ? void 0 : n.email) || void 0, mode: "payment", quantity: 1, couponCode: "O0Glzrqa" }), t = await fetch("".concat("https://freesvgicons.com", "/api/create_checkout_link"), { method: "POST", headers: { "Content-Type": "application/json" }, body: e }), i = await t.json(); if (!i.url) throw Error("No checkout URL returned"); window.location.href = i.url } catch (e) { console.error("Checkout error:", e), a({ title: "Error", message: "Failed to process payment", type: "error" }) } finally { p(!1) } }; return (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(e_, {}), (0, r.jsxs)("div", { className: "login-modal", children: [(0, r.jsx)("div", { className: "login-modal__overlay", onClick: t }), (0, r.jsxs)("div", { className: "login-modal__container", children: [(0, r.jsxs)("div", { className: "login-modal__form-section", children: [(0, r.jsx)("button", { className: "login-modal__close", onClick: t, disabled: l, children: (0, r.jsx)(c.A, { size: 18 }) }), (0, r.jsxs)("div", { className: "login-content", children: [(0, r.jsx)("div", { className: "highlight-fancy", children: "$60 OFF - Limited Slots (13 left)" }), (0, r.jsxs)("h2", { className: "heading-modal", children: ["Unlock ", (0, r.jsx)("span", { className: "scribble-even", children: "unlimited" }), " searches and ", (0, r.jsx)("span", { className: "scribble-even", children: "full plugin" }), " access."] }), (0, r.jsx)("div", { className: "pricing-value", children: (0, r.jsxs)("div", { className: "price", children: [(0, r.jsx)("div", { className: "actual-price price-hand", children: (0, r.jsxs)("h2", { style: { display: "flex", alignItems: "center" }, children: [(0, r.jsx)("span", { style: { fontSize: "1.1rem" }, children: "$" }), "89"] }) }), (0, r.jsx)("div", { className: "discounted-price", children: (0, r.jsx)("h2", { children: "$29" }) }), (0, r.jsx)("div", { children: "lifetime" })] }) }), (0, r.jsx)("button", { className: "button button--primary", style: { width: "100%" }, onClick: () => f(), children: d ? "Redirecting to checkout..." : "Subscribe Lifetime Access" }), (0, r.jsxs)("div", { className: "companies-grid", children: [(0, r.jsx)("div", { className: "tagline", children: "Used by 150K+ professionals worldwide" }), (0, r.jsx)("div", { className: "grid-list", children: ev.A.map((e, t) => (0, r.jsx)("div", { className: "company-logo", children: (0, r.jsx)("img", { src: "https://www.google.com/s2/favicons?sz=128&domain_url=".concat(e.website), alt: e.company_name }) }, t)) })] })] })] }), (0, r.jsx)("div", { className: "login-modal__testimonial-section", children: (0, r.jsx)("div", { className: "testimonial-content", children: (0, r.jsxs)("div", { className: "testimonials-grid-pricing", children: [(0, r.jsxs)("div", { className: "testimonial", children: [(0, r.jsx)("div", { className: "testimonal-icon", children: (0, r.jsx)(u.Q3, {}) }), (0, r.jsx)("p", { children: "I love everything about it! Such a clean and calm design and UX." }), (0, r.jsxs)("div", { className: "testimonial-author", children: [(0, r.jsx)("img", { src: "https://c1.tablecdn.com/iconbuddy/sobedominik.jpeg", alt: "Dominik Sobe " }), (0, r.jsxs)("div", { children: [(0, r.jsx)("h4", { children: "Dominik Sobe " }), (0, r.jsx)("span", { children: "Founder @HelpkitHQ" })] })] })] }), (0, r.jsx)("div", { style: { border: "1px solid #f6dce0", width: "100%" } }), (0, r.jsxs)("div", { className: "testimonial", children: [(0, r.jsx)("div", { className: "testimonal-icon", children: (0, r.jsx)(u.Q3, {}) }), (0, r.jsx)("p", { children: "The best place to get icons \uD83D\uDE09" }), (0, r.jsxs)("div", { className: "testimonial-author", children: [(0, r.jsx)("img", { src: "https://c1.tablecdn.com/iconbuddy/hqasmei.jpg", alt: "Hosna Qasmei" }), (0, r.jsxs)("div", { children: [(0, r.jsx)("h4", { children: "Hosna Qasmei" }), (0, r.jsx)("span", { children: "UI/UX Designer" })] })] })] })] }) }) })] })] })] }) }; var eb = n(1784); let eI = e => { let { onClose: t } = e, { userObj: n, refreshUserData: i, isPro: a } = (0, o.A)(), { addToast: l } = (0, ey.d)(); (0, s.useEffect)(() => { let e = e => { "Escape" === e.key && t() }; return () => { document.removeEventListener("keydown", e), document.body.style.overflow = "unset" } }, [t]); let h = async () => { try { let e = new eb.A.auth.GoogleAuthProvider; await eb.A.auth().signInWithPopup(e), l({ title: "Success", message: "Signed in successfully", type: "success" }), await i(), t() } catch (e) { console.error("Google sign in error:", e), l({ title: "Error", message: "Failed to sign in with Google", type: "error" }) } }; return (0, r.jsx)("div", { className: "auth-modal-overlay", onClick: e => { e.target === e.currentTarget && t() }, children: (0, r.jsxs)("div", { className: "auth-modal", children: [(0, r.jsx)("button", { className: "auth-modal__close", onClick: t, children: (0, r.jsx)("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", children: (0, r.jsx)("path", { d: "M18 6L6 18M6 6l12 12", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round" }) }) }), (0, r.jsx)("div", { className: "auth-modal__content", children: (0, r.jsxs)("div", { className: "auth-modal__left", children: [(0, r.jsxs)("div", { className: "auth-header", children: [(0, r.jsx)("h2", { children: "Get started" }), (0, r.jsx)("p", { style: { maxWidth: 280 }, children: "Access premium features and your personal icon library" })] }), (0, r.jsx)("div", { className: "auth-buttons", children: (0, r.jsxs)("button", { className: "button button--primary auth-btn--apple", onClick: h, children: [(0, r.jsxs)("svg", { width: "18", height: "18", viewBox: "0 0 24 24", children: [(0, r.jsx)("path", { fill: "#4285F4", d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" }), (0, r.jsx)("path", { fill: "#34A853", d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" }), (0, r.jsx)("path", { fill: "#FBBC05", d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" }), (0, r.jsx)("path", { fill: "#EA4335", d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" })] }), "Continue with Google"] }) }), (0, r.jsx)("div", { className: "auth-footer", children: (0, r.jsx)("p", { className: "auth-terms", children: "By continuing, you agree to our Terms of Service and Privacy Policy" }) })] }) })] }) }) }; function eC(e) { let { Component: t, pageProps: n } = e, [i, l] = (0, s.useState)(!1), [c, u] = (0, s.useState)(!1); (0, s.useEffect)(() => { let e = () => { l(!0) }; return window.addEventListener("showLoginModal", e), window.showLogin = e, () => { window.removeEventListener("showLoginModal", e), delete window.showLogin } }, []), (0, s.useEffect)(() => { let e = () => { l(!0) }; return window.addEventListener("showPayModal", e), window.showLogin = e, () => { window.removeEventListener("showPayModal", e), delete window.showLogin } }, []); let d = { ...n, showAuthModal: () => l(!0), showPricinghModal: () => u(!0) }; return (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(h(), { src: "https://a.imdanish.com/script.js", "data-website-id": "0aada39d-b750-4de5-ad61-a184a8525d5e", strategy: "lazyOnload" }), (0, r.jsx)(o.O, { children: (0, r.jsxs)(a.A, { children: [(0, r.jsx)(t, { ...d }), i && (0, r.jsx)(eI, { onClose: () => l(!1) }), c && (0, r.jsx)(ew, { onClose: () => u(!1) })] }) })] }) }
  }
}, e => { var t = t => e(e.s = t); e.O(0, [593, 792], () => (t(6556), t(8253))), _N_E = e.O() }]);